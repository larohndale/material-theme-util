/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/externs", ["require", "exports", "typescript", "tsickle/src/annotator_host", "tsickle/src/enum_transformer", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/jsdoc_transformer", "tsickle/src/module_type_translator", "tsickle/src/path", "tsickle/src/transformer_util", "tsickle/src/type_translator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateExterns = exports.getGeneratedExterns = void 0;
    /**
     * @fileoverview Externs creates Closure Compiler #externs definitions from the
     * ambient declarations in a TypeScript file.
     *
     * (Note that we cannot write the "@" form of the externs tag, even in comments,
     * because the compiler greps for it in source files(!).  So we write #externs
     * instead.)
     *
     * For example, a
     *   declare interface Foo { bar: string; }
     *
     * Would generate a
     *   /.. #externs ./
     *   /.. @record ./
     *   var Foo = function() {};
     *   /.. @type {string} ./
     *   Foo.prototype.bar;
     *
     * The generated externs indicate to Closure Compiler that symbols are external
     * to the optimization process, i.e. they are provided by outside code. That
     * most importantly means they must not be renamed or removed.
     *
     * A major difficulty here is that TypeScript supports module-scoped external
     * symbols; `.d.ts` files can contain `export`s and `import` other files.
     * Closure Compiler does not have such a concept, so tsickle must emulate the
     * behaviour. It does so by following this scheme:
     *
     * 1. non-module .d.ts produces global symbols
     * 2. module .d.ts produce symbols namespaced to the module, by creating a
     *    mangled name matching the current file's path. tsickle expects outside
     *    code (e.g. build system integration or manually written code) to contain a
     *    goog.module/provide that references the mangled path.
     * 3. declarations in `.ts` files produce types that can be separately emitted
     *    in e.g. an `externs.js`, using `getGeneratedExterns` below.
     *    1. non-exported symbols produce global types, because that's what users
     *       expect and it matches TypeScripts emit, which just references `Foo` for
     *       a locally declared symbol `Foo` in a module. Arguably these should be
     *       wrapped in `declare global { ... }`.
     *    2. exported symbols are scoped to the `.ts` file by prefixing them with a
     *       mangled name. Exported types are re-exported from the JavaScript
     *       `goog.module`, allowing downstream code to reference them. This has the
     *       same problem regarding ambient values as above, it is unclear where the
     *       value symbol would be defined, so for the time being this is
     *       unsupported.
     *
     * The effect of this is that:
     * - symbols in a module (i.e. not globals) are generally scoped to the local
     *   module using a mangled name, preventing symbol collisions on the Closure
     *   side.
     * - importing code can unconditionally refer to and import any symbol defined
     *   in a module `X` as `path.to.module.X`, regardless of whether the defining
     *   location is a `.d.ts` file or a `.ts` file, and regardless whether the
     *   symbol is ambient (assuming there's an appropriate shim).
     * - if there is a shim present, tsickle avoids emitting the Closure namespace
     *   itself, expecting the shim to provide the namespace and initialize it to a
     *   symbol that provides the right value at runtime (i.e. the implementation of
     *   whatever third party library the .d.ts describes).
     */
    const ts = require("typescript");
    const annotator_host_1 = require("tsickle/src/annotator_host");
    const enum_transformer_1 = require("tsickle/src/enum_transformer");
    const googmodule_1 = require("tsickle/src/googmodule");
    const jsdoc = require("tsickle/src/jsdoc");
    const jsdoc_transformer_1 = require("tsickle/src/jsdoc_transformer");
    const module_type_translator_1 = require("tsickle/src/module_type_translator");
    const path = require("tsickle/src/path");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    const type_translator_1 = require("tsickle/src/type_translator");
    /**
     * Symbols that are already declared as externs in Closure, that should
     * be avoided by tsickle's "declare ..." => externs.js conversion.
     */
    const CLOSURE_EXTERNS_BLACKLIST = [
        'exports',
        'global',
        'module',
        // ErrorConstructor is the interface of the Error object itself.
        // tsickle detects that this is part of the TypeScript standard library
        // and assumes it's part of the Closure standard library, but this
        // assumption is wrong for ErrorConstructor.  To properly handle this
        // we'd somehow need to map methods defined on the ErrorConstructor
        // interface into properties on Closure's Error object, but for now it's
        // simpler to just blacklist it.
        'ErrorConstructor',
        'Symbol',
        'WorkerGlobalScope',
    ];
    /**
     * The header to be used in generated externs.  This is not included in the output of
     * generateExterns() because generateExterns() works one file at a time, and typically you create
     * one externs file from the entire compilation unit.
     *
     * Suppressions:
     * - duplicate: because externs might duplicate re-opened definitions from other JS files.
     * - checkTypes: Closure's type system does not match TS'.
     * - undefinedNames: code below tries to be careful not to overwrite previously emitted definitions,
     *   but on the flip side might accidentally miss definitions.
     */
    const EXTERNS_HEADER = `/**
 * @${''}externs
 * @suppress {duplicate,checkTypes}
 */
// NOTE: generated by tsickle, do not edit.
`;
    /**
     * Concatenate all generated externs definitions together into a string, including a file comment
     * header.
     *
     * @param rootDir Project root.  Emitted comments will reference paths relative to this root.
     *    This param is effectively required, but made optional here until Angular is fixed.
     */
    function getGeneratedExterns(externs, rootDir) {
        let allExterns = EXTERNS_HEADER;
        for (const fileName of Object.keys(externs)) {
            const srcPath = rootDir ? path.relative(rootDir, fileName) :
                'ERROR: getGeneratedExterns called without rootDir';
            allExterns += `// externs from ${srcPath}:\n`;
            allExterns += externs[fileName];
        }
        return allExterns;
    }
    exports.getGeneratedExterns = getGeneratedExterns;
    /**
     * isInGlobalAugmentation returns true if declaration is the immediate child of a 'declare global'
     * block.
     */
    function isInGlobalAugmentation(declaration) {
        // declare global { ... } creates a ModuleDeclaration containing a ModuleBlock containing the
        // declaration, with the ModuleDeclaration having the GlobalAugmentation flag set.
        if (!declaration.parent || !declaration.parent.parent)
            return false;
        return (declaration.parent.parent.flags & ts.NodeFlags.GlobalAugmentation) !== 0;
    }
    /**
     * generateExterns generates extern definitions for all ambient declarations in the given source
     * file. It returns a string representation of the Closure JavaScript, not including the initial
     * comment with \@fileoverview and #externs (see above for that).
     */
    function generateExterns(typeChecker, sourceFile, host, moduleResolutionHost, options) {
        let output = '';
        const diagnostics = [];
        const isDts = transformer_util_1.isDtsFileName(sourceFile.fileName);
        const isExternalModule = ts.isExternalModule(sourceFile);
        const mtt = new module_type_translator_1.ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, /*isForExterns*/ true);
        // .d.ts files declare symbols. The code below translates these into a form understood by Closure
        // Compiler, converting the type syntax, but also converting symbol names into a form accessible
        // to Closure Compiler.
        // Like regular .ts files, .d.ts can be either scripts or modules. Scripts declare symbols in the
        // global namespace, which has the same semantics in Closure and TypeScript, so the code below
        // emits those with the same name.
        // Modules however declare symbols scoped to the module that can be exported. Closure has no
        // concept of externs that are non-global, so tsickle needs to mangle the symbol names, both at
        // their declaration and at their use site.
        // This mangling happens by wrapping all declared symbols in a namespace based on the file name.
        // This namespace is then essentially the exports object for the ambient module (externs in
        // Closure terms). This namespace is called `moduleNamespace` below:
        let moduleNamespace = '';
        if (isExternalModule) {
            moduleNamespace = annotator_host_1.moduleNameAsIdentifier(host, sourceFile.fileName);
        }
        // Symbols are generated starting in rootNamespace. For script .d.ts with global symbols, this is
        // the empty string. For most module `.d.ts` files, this is the mangled namespace object. The
        // remaining special case are `.d.ts` files containing an `export = something;` statement. In
        // these, the effective exports object, i.e. the object containing the symbols that importing code
        // receives, is different from the main module scope.
        // tsickle handles the `export =` case by generating symbols in a different namespace (escaped
        // with a `_`) below, and then assigning whatever is actually exported into the `moduleNamespace`
        // below.
        let rootNamespace = moduleNamespace;
        // There can only be one export =, and if there is one, there cannot be any other exports.
        const exportAssignment = sourceFile.statements.find(ts.isExportAssignment);
        const hasExportEquals = exportAssignment && exportAssignment.isExportEquals;
        if (hasExportEquals) {
            // If so, move all generated symbols into a different sub-namespace, so that later on we can
            // control what exactly goes on the actual exported namespace.
            rootNamespace = rootNamespace + '_';
        }
        for (const stmt of sourceFile.statements) {
            if (!isDts && !transformer_util_1.hasModifierFlag(stmt, ts.ModifierFlags.Ambient)) {
                continue;
            }
            visitor(stmt, []);
        }
        /**
         * Convert a qualified name from a .d.ts file or declaration context into a mangled identifier.
         * E.g. for a qualified name in `export = someName;` or `import = someName;`.
         * If `someName` is `declare global { namespace someName {...} }`, tsickle must not qualify access
         * to it with the mangled module namespace as it is emitted in the global namespace. Similarly, if
         * the symbol is declared in a non-module context, it must not be mangled.
         */
        function qualifiedNameToMangledIdentifier(name) {
            const entityName = transformer_util_1.getEntityNameText(name);
            let symbol = typeChecker.getSymbolAtLocation(name);
            if (symbol) {
                // If this is an aliased name (e.g. from an import), use the alias to refer to it.
                if (symbol.flags & ts.SymbolFlags.Alias) {
                    symbol = typeChecker.getAliasedSymbol(symbol);
                }
                const alias = mtt.symbolsToAliasedNames.get(symbol);
                if (alias)
                    return alias;
                const isGlobalSymbol = symbol && symbol.declarations && symbol.declarations.some(d => {
                    if (isInGlobalAugmentation(d))
                        return true;
                    // If the declaration's source file is not a module, it must be global.
                    // If it is a module, the identifier must be local to this file, or handled above via the
                    // alias.
                    return !ts.isExternalModule(d.getSourceFile());
                });
                if (isGlobalSymbol)
                    return entityName;
            }
            return rootNamespace + '.' + entityName;
        }
        if (output && isExternalModule) {
            // If tsickle generated any externs and this is an external module, prepend the namespace
            // declaration for it.
            output = `/** @const */\nvar ${rootNamespace} = {};\n` + output;
            let exportedNamespace = rootNamespace;
            if (exportAssignment && hasExportEquals) {
                if (ts.isIdentifier(exportAssignment.expression) ||
                    ts.isQualifiedName(exportAssignment.expression)) {
                    // E.g. export = someName;
                    // If someName is "declare global { namespace someName {...} }", tsickle must not qualify
                    // access to it with module namespace as it is emitted in the global namespace.
                    exportedNamespace = qualifiedNameToMangledIdentifier(exportAssignment.expression);
                }
                else {
                    transformer_util_1.reportDiagnostic(diagnostics, exportAssignment.expression, `export = expression must be a qualified name, got ${ts.SyntaxKind[exportAssignment.expression.kind]}.`);
                }
                // Assign the actually exported namespace object (which lives somewhere under rootNamespace)
                // into the module's namespace.
                emit(`/**\n * export = ${exportAssignment.expression.getText()}\n * @const\n */\n`);
                emit(`var ${moduleNamespace} = ${exportedNamespace};\n`);
            }
            if (isDts && host.provideExternalModuleDtsNamespace) {
                // In a non-shimmed module, create a global namespace. This exists purely for backwards
                // compatiblity, in the medium term all code using tsickle should always use `goog.module`s,
                // so global names should not be neccessary.
                for (const nsExport of sourceFile.statements.filter(ts.isNamespaceExportDeclaration)) {
                    const namespaceName = transformer_util_1.getIdentifierText(nsExport.name);
                    emit(`// export as namespace ${namespaceName}\n`);
                    writeVariableStatement(namespaceName, [], exportedNamespace);
                }
            }
        }
        return { output, diagnostics };
        function emit(str) {
            output += str;
        }
        /**
         * isFirstDeclaration returns true if decl is the first declaration
         * of its symbol.  E.g. imagine
         *   interface Foo { x: number; }
         *   interface Foo { y: number; }
         * we only want to emit the "\@record" for Foo on the first one.
         *
         * The exception are variable declarations, which - in externs - do not assign a value:
         *   /.. \@type {...} ./
         *   var someVariable;
         *   /.. \@type {...} ./
         *   someNamespace.someVariable;
         * If a later declaration wants to add additional properties on someVariable, tsickle must still
         * emit an assignment into the object, as it's otherwise absent.
         */
        function isFirstValueDeclaration(decl) {
            if (!decl.name)
                return true;
            const sym = typeChecker.getSymbolAtLocation(decl.name);
            if (!sym.declarations || sym.declarations.length < 2)
                return true;
            const earlierDecls = sym.declarations.slice(0, sym.declarations.indexOf(decl));
            // Either there are no earlier declarations, or all of them are variables (see above). tsickle
            // emits a value for all other declaration kinds (function for functions, classes, interfaces,
            // {} object for namespaces).
            return earlierDecls.length === 0 || earlierDecls.every(ts.isVariableDeclaration);
        }
        /** Writes the actual variable statement of a Closure variable declaration. */
        function writeVariableStatement(name, namespace, value) {
            const qualifiedName = namespace.concat([name]).join('.');
            if (namespace.length === 0)
                emit(`var `);
            emit(qualifiedName);
            if (value)
                emit(` = ${value}`);
            emit(';\n');
        }
        /**
         * Writes a Closure variable declaration, i.e. the variable statement with a leading JSDoc
         * comment making it a declaration.
         */
        function writeVariableDeclaration(decl, namespace) {
            if (decl.name.kind === ts.SyntaxKind.Identifier) {
                const name = transformer_util_1.getIdentifierText(decl.name);
                if (CLOSURE_EXTERNS_BLACKLIST.indexOf(name) >= 0)
                    return;
                emit(jsdoc.toString([{ tagName: 'type', type: mtt.typeToClosure(decl) }]));
                emit('\n');
                writeVariableStatement(name, namespace);
            }
            else {
                errorUnimplementedKind(decl.name, 'externs for variable');
            }
        }
        /**
         * Emits a JSDoc declaration that merges the signatures of the given function declaration (for
         * overloads), and returns the parameter names chosen.
         */
        function emitFunctionType(decls, extraTags = []) {
            const { tags, parameterNames } = mtt.getFunctionTypeJSDoc(decls, extraTags);
            emit('\n');
            emit(jsdoc.toString(tags));
            return parameterNames;
        }
        function writeFunction(name, params, namespace) {
            const paramsStr = params.join(', ');
            if (namespace.length > 0) {
                let fqn = namespace.join('.');
                if (name.kind === ts.SyntaxKind.Identifier) {
                    fqn += '.'; // computed names include [ ] in their getText() representation.
                }
                fqn += name.getText();
                emit(`${fqn} = function(${paramsStr}) {};\n`);
            }
            else {
                if (name.kind !== ts.SyntaxKind.Identifier) {
                    transformer_util_1.reportDiagnostic(diagnostics, name, 'Non-namespaced computed name in externs');
                }
                emit(`function ${name.getText()}(${paramsStr}) {}\n`);
            }
        }
        function writeEnum(decl, namespace) {
            // E.g. /** @enum {number} */ var COUNTRY = {US: 1, CA: 1};
            const name = transformer_util_1.getIdentifierText(decl.name);
            let members = '';
            const enumType = enum_transformer_1.getEnumType(typeChecker, decl);
            // Closure enums members must have a value of the correct type, but the actual value does not
            // matter in externs.
            const initializer = enumType === 'string' ? `''` : 1;
            for (const member of decl.members) {
                let memberName;
                switch (member.name.kind) {
                    case ts.SyntaxKind.Identifier:
                        memberName = transformer_util_1.getIdentifierText(member.name);
                        break;
                    case ts.SyntaxKind.StringLiteral:
                        const text = member.name.text;
                        if (type_translator_1.isValidClosurePropertyName(text))
                            memberName = text;
                        break;
                    default:
                        break;
                }
                if (!memberName) {
                    members += `  /* TODO: ${ts.SyntaxKind[member.name.kind]}: ${jsdoc_transformer_1.escapeForComment(member.name.getText())} */\n`;
                    continue;
                }
                members += `  ${memberName}: ${initializer},\n`;
            }
            emit(`\n/** @enum {${enumType}} */\n`);
            writeVariableStatement(name, namespace, `{\n${members}}`);
        }
        function writeTypeAlias(decl, namespace) {
            const typeStr = mtt.typeToClosure(decl, undefined);
            emit(`\n/** @typedef {${typeStr}} */\n`);
            writeVariableStatement(transformer_util_1.getIdentifierText(decl.name), namespace);
        }
        function writeType(decl, namespace) {
            const name = decl.name;
            if (!name) {
                transformer_util_1.reportDiagnostic(diagnostics, decl, 'anonymous type in externs');
                return;
            }
            const typeName = namespace.concat([name.getText()]).join('.');
            if (CLOSURE_EXTERNS_BLACKLIST.indexOf(typeName) >= 0)
                return;
            if (isFirstValueDeclaration(decl)) {
                // Emit the 'function' that is actually the declaration of the interface
                // itself.  If it's a class, this function also must include the type
                // annotations of the constructor.
                let paramNames = [];
                const jsdocTags = [];
                let wroteJsDoc = false;
                jsdoc_transformer_1.maybeAddHeritageClauses(jsdocTags, mtt, decl);
                jsdoc_transformer_1.maybeAddTemplateClause(jsdocTags, decl);
                if (decl.kind === ts.SyntaxKind.ClassDeclaration) {
                    // TODO: it appears you can just write 'class Foo { ...' in externs.
                    // This code instead tries to translate it to a function.
                    jsdocTags.push({ tagName: 'constructor' }, { tagName: 'struct' });
                    const ctors = decl
                        .members.filter((m) => m.kind === ts.SyntaxKind.Constructor);
                    if (ctors.length) {
                        const firstCtor = ctors[0];
                        if (ctors.length > 1) {
                            paramNames = emitFunctionType(ctors, jsdocTags);
                        }
                        else {
                            paramNames = emitFunctionType([firstCtor], jsdocTags);
                        }
                        wroteJsDoc = true;
                    }
                }
                else {
                    // Otherwise it's an interface; tag it as structurally typed.
                    jsdocTags.push({ tagName: 'record' }, { tagName: 'struct' });
                }
                if (!wroteJsDoc)
                    emit(jsdoc.toString(jsdocTags));
                writeFunction(name, paramNames, namespace);
            }
            // Process everything except (MethodSignature|MethodDeclaration|Constructor)
            const methods = new Map();
            for (const member of decl.members) {
                switch (member.kind) {
                    case ts.SyntaxKind.PropertySignature:
                    case ts.SyntaxKind.PropertyDeclaration:
                        const prop = member;
                        if (prop.name.kind === ts.SyntaxKind.Identifier) {
                            let type = mtt.typeToClosure(prop);
                            if (prop.questionToken && type === '?') {
                                // An optional 'any' type translates to '?|undefined' in Closure.
                                type = '?|undefined';
                            }
                            emit(jsdoc.toString([{ tagName: 'type', type }]));
                            if (transformer_util_1.hasModifierFlag(prop, ts.ModifierFlags.Static)) {
                                emit(`\n${typeName}.${prop.name.getText()};\n`);
                            }
                            else {
                                emit(`\n${typeName}.prototype.${prop.name.getText()};\n`);
                            }
                            continue;
                        }
                        // TODO: For now property names other than Identifiers are not handled; e.g.
                        //    interface Foo { "123bar": number }
                        break;
                    case ts.SyntaxKind.MethodSignature:
                    case ts.SyntaxKind.MethodDeclaration:
                        const method = member;
                        const isStatic = transformer_util_1.hasModifierFlag(method, ts.ModifierFlags.Static);
                        const methodSignature = `${method.name.getText()}$$$${isStatic ? 'static' : 'instance'}`;
                        if (methods.has(methodSignature)) {
                            methods.get(methodSignature).push(method);
                        }
                        else {
                            methods.set(methodSignature, [method]);
                        }
                        continue;
                    case ts.SyntaxKind.Constructor:
                        continue; // Handled above.
                    default:
                        // Members can include things like index signatures, for e.g.
                        //   interface Foo { [key: string]: number; }
                        // For now, just skip it.
                        break;
                }
                // If we get here, the member wasn't handled in the switch statement.
                let memberName = namespace;
                if (member.name) {
                    memberName = memberName.concat([member.name.getText()]);
                }
                emit(`\n/* TODO: ${ts.SyntaxKind[member.kind]}: ${memberName.join('.')} */\n`);
            }
            // Handle method declarations/signatures separately, since we need to deal with overloads.
            for (const methodVariants of Array.from(methods.values())) {
                const firstMethodVariant = methodVariants[0];
                let parameterNames;
                if (methodVariants.length > 1) {
                    parameterNames = emitFunctionType(methodVariants);
                }
                else {
                    parameterNames = emitFunctionType([firstMethodVariant]);
                }
                const methodNamespace = namespace.concat([name.getText()]);
                // If the method is static, don't add the prototype.
                if (!transformer_util_1.hasModifierFlag(firstMethodVariant, ts.ModifierFlags.Static)) {
                    methodNamespace.push('prototype');
                }
                writeFunction(firstMethodVariant.name, parameterNames, methodNamespace);
            }
        }
        function writeExportDeclaration(exportDeclaration, namespace) {
            if (!exportDeclaration.exportClause) {
                emit(`\n// TODO(tsickle): export * declaration in ${debugLocationStr(exportDeclaration, namespace)}\n`);
                return;
            }
            if (ts.isNamespaceExport(exportDeclaration.exportClause)) {
                // TODO(#1135): Support generating externs using this syntax.
                emit(`\n// TODO(tsickle): export * as declaration in ${debugLocationStr(exportDeclaration, namespace)}\n`);
                return;
            }
            for (const exportSpecifier of exportDeclaration.exportClause.elements) {
                // No need to do anything for properties exported under their original name.
                if (!exportSpecifier.propertyName)
                    continue;
                emit('/** @const */\n');
                writeVariableStatement(exportSpecifier.name.text, namespace, namespace.join('.') + '.' + exportSpecifier.propertyName.text);
            }
        }
        /**
         * Adds aliases for the symbols imported in the given declaration, so that their types get
         * printed as the fully qualified name, and not just as a reference to the local import alias.
         *
         * tsickle generates .js files that (at most) contain a `goog.provide`, but are not
         * `goog.module`s. These files cannot express an aliased import. However Closure Compiler allows
         * referencing types using fully qualified names in such files, so tsickle can resolve the
         * imported module URI and produce `path.to.module.Symbol` as an alias, and use that when
         * referencing the type.
         */
        function addImportAliases(decl) {
            let moduleUri;
            if (ts.isImportDeclaration(decl)) {
                moduleUri = decl.moduleSpecifier.text;
            }
            else if (ts.isExternalModuleReference(decl.moduleReference)) {
                // import foo = require('./bar');
                moduleUri = decl.moduleReference.expression.text;
            }
            else {
                // import foo = bar.baz.bam;
                // handled at call site.
                return;
            }
            if (ts.isImportEqualsDeclaration(decl)) {
                // import foo = require('./bar');
                addImportAlias(decl.name, moduleUri, undefined);
                return;
            }
            // Side effect import, like "import 'somepath';" declares no local aliases.
            if (!decl.importClause)
                return;
            if (decl.importClause.name) {
                // import name from ... -> map to .default on the module.name.
                addImportAlias(decl.importClause.name, moduleUri, 'default');
            }
            const namedBindings = decl.importClause.namedBindings;
            if (!namedBindings)
                return;
            if (ts.isNamespaceImport(namedBindings)) {
                // import * as name -> map directly to the module.name.
                addImportAlias(namedBindings.name, moduleUri, undefined);
            }
            if (ts.isNamedImports(namedBindings)) {
                // import {A as B}, map to module.name.A
                for (const namedBinding of namedBindings.elements) {
                    addImportAlias(namedBinding.name, moduleUri, namedBinding.name);
                }
            }
        }
        /**
         * Adds an import alias for the symbol defined at the given node. Creates an alias name based on
         * the given moduleName and (optionally) the name.
         */
        function addImportAlias(node, moduleUri, name) {
            let symbol = typeChecker.getSymbolAtLocation(node);
            if (!symbol) {
                transformer_util_1.reportDiagnostic(diagnostics, node, `named import has no symbol`);
                return;
            }
            if (symbol.flags & ts.SymbolFlags.Alias) {
                symbol = typeChecker.getAliasedSymbol(symbol);
            }
            const googNamespace = googmodule_1.extractGoogNamespaceImport(moduleUri);
            let aliasName;
            if (googNamespace) {
                aliasName = googNamespace;
            }
            else {
                // While type_translator does add the mangled prefix for ambient declarations, it only does so
                // for non-aliased (i.e. not imported) symbols. That's correct for its use in regular modules,
                // which will have a local symbol for the imported ambient symbol. However within an externs
                // file, there are no imports, so we need to make sure the alias already contains the correct
                // module name, which means the mangled module name in case of imports symbols.
                // This only applies to non-Closure ('goog:') imports.
                const isAmbientModuleDeclaration = symbol.declarations && symbol.declarations.some(d => transformer_util_1.isAmbient(d));
                const fullUri = googmodule_1.resolveModuleName(host, sourceFile.fileName, moduleUri);
                if (isAmbientModuleDeclaration) {
                    aliasName = annotator_host_1.moduleNameAsIdentifier(host, fullUri);
                }
                else {
                    aliasName = host.pathToModuleName(sourceFile.fileName, googmodule_1.resolveModuleName(host, sourceFile.fileName, fullUri));
                }
                if (typeof name === 'string') {
                    aliasName += '.' + name;
                }
                else if (name) {
                    aliasName += '.' + transformer_util_1.getIdentifierText(name);
                }
            }
            mtt.symbolsToAliasedNames.set(symbol, aliasName);
        }
        /**
         * Produces a compiler error that references the Node's kind. This is useful for the "else"
         * branch of code that is attempting to handle all possible input Node types, to ensure all cases
         * covered.
         */
        function errorUnimplementedKind(node, where) {
            transformer_util_1.reportDiagnostic(diagnostics, node, `${ts.SyntaxKind[node.kind]} not implemented in ${where}`);
        }
        /**
         * getNamespaceForLocalDeclaration returns the namespace that should be used for the given
         * declaration, deciding whether to namespace the symbol to the file or whether to create a
         * global name.
         *
         * The function covers these cases:
         * 1) a declaration in a .d.ts
         * 1a) where the .d.ts is an external module     --> namespace
         * 1b) where the .d.ts is not an external module --> global
         * 2) a declaration in a .ts file (all are treated as modules)
         * 2a) that is exported                          --> namespace
         * 2b) that is unexported                        --> global
         *
         * For 1), all symbols in .d.ts should generally be namespaced to the file to avoid collisions.
         * However .d.ts files that are not external modules do declare global names (1b).
         *
         * For 2), ambient declarations in .ts files must be namespaced, for the same collision reasons.
         * The exception is 2b), where in TypeScript, an unexported local "declare const x: string;"
         * creates a symbol that, when used locally, is emitted as just "x". That is, it behaves
         * like a variable declared in a 'declare global' block. Closure Compiler would fail the build if
         * there is no declaration for "x", so tsickle must generate a global external symbol, i.e.
         * without the namespace wrapper.
         */
        function getNamespaceForTopLevelDeclaration(declaration, namespace) {
            // Only use rootNamespace for top level symbols, any other namespacing (global names, nested
            // namespaces) is always kept.
            if (namespace.length !== 0)
                return namespace;
            // All names in a module (external) .d.ts file can only be accessed locally, so they always get
            // namespace prefixed.
            if (isDts && isExternalModule)
                return [rootNamespace];
            // Same for exported declarations in regular .ts files.
            if (transformer_util_1.hasModifierFlag(declaration, ts.ModifierFlags.Export))
                return [rootNamespace];
            // But local declarations in .ts files or .d.ts files (1b, 2b) are global, too.
            return [];
        }
        /**
         * Returns a string representation for the location: either the namespace, or, if empty, the
         * current source file name. This is intended to be included in the emit for warnings, so that
         * users can more easily find where a problematic definition is from.
         *
         * The code below does not use diagnostics to avoid breaking the build for harmless unhandled
         * cases.
         */
        function debugLocationStr(node, namespace) {
            // Use a regex to grab the filename without a path, to make the output stable
            // under bazel where sandboxes use different paths.
            return namespace.join('.') || node.getSourceFile().fileName.replace(/.*[/\\]/, '');
        }
        function visitor(node, namespace) {
            if (node.parent === sourceFile) {
                namespace = getNamespaceForTopLevelDeclaration(node, namespace);
            }
            switch (node.kind) {
                case ts.SyntaxKind.ModuleDeclaration:
                    const decl = node;
                    switch (decl.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            if (decl.flags & ts.NodeFlags.GlobalAugmentation) {
                                // E.g. "declare global { ... }".  Reset to the outer namespace.
                                namespace = [];
                            }
                            else {
                                // E.g. "declare namespace foo {"
                                const name = transformer_util_1.getIdentifierText(decl.name);
                                if (isFirstValueDeclaration(decl)) {
                                    emit('/** @const */\n');
                                    writeVariableStatement(name, namespace, '{}');
                                }
                                namespace = namespace.concat(name);
                            }
                            if (decl.body)
                                visitor(decl.body, namespace);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            // E.g. "declare module 'foo' {" (note the quotes).
                            // We still want to emit externs for this module, but Closure doesn't provide a
                            // mechanism for module-scoped externs. Instead, we emit in a mangled namespace.
                            // The mangled namespace (after resolving files) matches the emit for an original module
                            // file, so effectively this augments any existing module.
                            const importName = decl.name.text;
                            const importedModuleName = googmodule_1.resolveModuleName({ moduleResolutionHost, options }, sourceFile.fileName, importName);
                            const mangled = annotator_host_1.moduleNameAsIdentifier(host, importedModuleName);
                            emit(`// Derived from: declare module "${importName}"\n`);
                            namespace = [mangled];
                            // Declare "mangled$name" if it's not declared already elsewhere.
                            if (isFirstValueDeclaration(decl)) {
                                emit('/** @const */\n');
                                writeVariableStatement(mangled, [], '{}');
                            }
                            // Declare the contents inside the "mangled$name".
                            if (decl.body)
                                visitor(decl.body, [mangled]);
                            break;
                        default:
                            errorUnimplementedKind(decl.name, 'externs generation of namespace');
                            break;
                    }
                    break;
                case ts.SyntaxKind.ModuleBlock:
                    const block = node;
                    for (const stmt of block.statements) {
                        visitor(stmt, namespace);
                    }
                    break;
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    const importEquals = node;
                    const localName = transformer_util_1.getIdentifierText(importEquals.name);
                    if (importEquals.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) {
                        addImportAliases(importEquals);
                        break;
                    }
                    const qn = qualifiedNameToMangledIdentifier(importEquals.moduleReference);
                    // @const so that Closure Compiler understands this is an alias.
                    emit('/** @const */\n');
                    writeVariableStatement(localName, namespace, qn);
                    break;
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                    writeType(node, namespace);
                    break;
                case ts.SyntaxKind.FunctionDeclaration:
                    const fnDecl = node;
                    const name = fnDecl.name;
                    if (!name) {
                        transformer_util_1.reportDiagnostic(diagnostics, fnDecl, 'anonymous function in externs');
                        break;
                    }
                    // Gather up all overloads of this function.
                    const sym = typeChecker.getSymbolAtLocation(name);
                    const decls = sym.declarations.filter(ts.isFunctionDeclaration);
                    // Only emit the first declaration of each overloaded function.
                    if (fnDecl !== decls[0])
                        break;
                    const params = emitFunctionType(decls);
                    writeFunction(name, params, namespace);
                    break;
                case ts.SyntaxKind.VariableStatement:
                    for (const decl of node.declarationList.declarations) {
                        writeVariableDeclaration(decl, namespace);
                    }
                    break;
                case ts.SyntaxKind.EnumDeclaration:
                    writeEnum(node, namespace);
                    break;
                case ts.SyntaxKind.TypeAliasDeclaration:
                    writeTypeAlias(node, namespace);
                    break;
                case ts.SyntaxKind.ImportDeclaration:
                    addImportAliases(node);
                    break;
                case ts.SyntaxKind.NamespaceExportDeclaration:
                case ts.SyntaxKind.ExportAssignment:
                    // Handled on the file level.
                    break;
                case ts.SyntaxKind.ExportDeclaration:
                    const exportDeclaration = node;
                    writeExportDeclaration(exportDeclaration, namespace);
                    break;
                default:
                    emit(`\n// TODO(tsickle): ${ts.SyntaxKind[node.kind]} in ${debugLocationStr(node, namespace)}\n`);
                    break;
            }
        }
    }
    exports.generateExterns = generateExterns;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZXJucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHRlcm5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7OztJQUVIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F5REc7SUFFSCxpQ0FBaUM7SUFFakMsK0RBQXVFO0lBQ3ZFLG1FQUErQztJQUMvQyx1REFBMkU7SUFDM0UsMkNBQWlDO0lBQ2pDLHFFQUFzRztJQUN0RywrRUFBOEQ7SUFDOUQseUNBQStCO0lBQy9CLG1FQUFxSTtJQUNySSxpRUFBNkQ7SUFFN0Q7OztPQUdHO0lBQ0gsTUFBTSx5QkFBeUIsR0FBMEI7UUFDdkQsU0FBUztRQUNULFFBQVE7UUFDUixRQUFRO1FBQ1IsZ0VBQWdFO1FBQ2hFLHVFQUF1RTtRQUN2RSxrRUFBa0U7UUFDbEUscUVBQXFFO1FBQ3JFLG1FQUFtRTtRQUNuRSx3RUFBd0U7UUFDeEUsZ0NBQWdDO1FBQ2hDLGtCQUFrQjtRQUNsQixRQUFRO1FBQ1IsbUJBQW1CO0tBQ3BCLENBQUM7SUFHRjs7Ozs7Ozs7OztPQVVHO0lBQ0gsTUFBTSxjQUFjLEdBQUc7TUFDakIsRUFBRTs7OztDQUlQLENBQUM7SUFFRjs7Ozs7O09BTUc7SUFDSCxTQUFnQixtQkFBbUIsQ0FDL0IsT0FBcUMsRUFBRSxPQUFnQjtRQUN6RCxJQUFJLFVBQVUsR0FBRyxjQUFjLENBQUM7UUFDaEMsS0FBSyxNQUFNLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzNDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDbEMsbURBQW1ELENBQUM7WUFDOUUsVUFBVSxJQUFJLG1CQUFtQixPQUFPLEtBQUssQ0FBQztZ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O29CQUNqQyw2QkFBNkI7b0JBQzdCLE1BQU07Z0JBQ1IsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQjtvQkFDbEMsTUFBTSxpQkFBaUIsR0FBRyxJQUE0QixDQUFDO29CQUN2RCxzQkFBc0IsQ0FBQyxpQkFBaUIsRUFBRSxTQUFTLENBQUMsQ0FBQztvQkFDckQsTUFBTTtnQkFDUjtvQkFDRSxJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUNoRCxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUMzQyxNQUFNO2FBQ1Q7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQS9vQkQsMENBK29CQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4dGVybnMgY3JlYXRlcyBDbG9zdXJlIENvbXBpbGVyICNleHRlcm5zIGRlZmluaXRpb25zIGZyb20gdGhlXG4gKiBhbWJpZW50IGRlY2xhcmF0aW9ucyBpbiBhIFR5cGVTY3JpcHQgZmlsZS5cbiAqXG4gKiAoTm90ZSB0aGF0IHdlIGNhbm5vdCB3cml0ZSB0aGUgXCJAXCIgZm9ybSBvZiB0aGUgZXh0ZXJucyB0YWcsIGV2ZW4gaW4gY29tbWVudHMsXG4gKiBiZWNhdXNlIHRoZSBjb21waWxlciBncmVwcyBmb3IgaXQgaW4gc291cmNlIGZpbGVzKCEpLiAgU28gd2Ugd3JpdGUgI2V4dGVybnNcbiAqIGluc3RlYWQuKVxuICpcbiAqIEZvciBleGFtcGxlLCBhXG4gKiAgIGRlY2xhcmUgaW50ZXJmYWNlIEZvbyB7IGJhcjogc3RyaW5nOyB9XG4gKlxuICogV291bGQgZ2VuZXJhdGUgYVxuICogICAvLi4gI2V4dGVybnMgLi9cbiAqICAgLy4uIEByZWNvcmQgLi9cbiAqICAgdmFyIEZvbyA9IGZ1bmN0aW9uKCkge307XG4gKiAgIC8uLiBAdHlwZSB7c3RyaW5nfSAuL1xuICogICBGb28ucHJvdG90eXBlLmJhcjtcbiAqXG4gKiBUaGUgZ2VuZXJhdGVkIGV4dGVybnMgaW5kaWNhdGUgdG8gQ2xvc3VyZSBDb21waWxlciB0aGF0IHN5bWJvbHMgYXJlIGV4dGVybmFsXG4gKiB0byB0aGUgb3B0aW1pemF0aW9uIHByb2Nlc3MsIGkuZS4gdGhleSBhcmUgcHJvdmlkZWQgYnkgb3V0c2lkZSBjb2RlLiBUaGF0XG4gKiBtb3N0IGltcG9ydGFudGx5IG1lYW5zIHRoZXkgbXVzdCBub3QgYmUgcmVuYW1lZCBvciByZW1vdmVkLlxuICpcbiAqIEEgbWFqb3IgZGlmZmljdWx0eSBoZXJlIGlzIHRoYXQgVHlwZVNjcmlwdCBzdXBwb3J0cyBtb2R1bGUtc2NvcGVkIGV4dGVybmFsXG4gKiBzeW1ib2xzOyBgLmQudHNgIGZpbGVzIGNhbiBjb250YWluIGBleHBvcnRgcyBhbmQgYGltcG9ydGAgb3RoZXIgZmlsZXMuXG4gKiBDbG9zdXJlIENvbXBpbGVyIGRvZXMgbm90IGhhdmUgc3VjaCBhIGNvbmNlcHQsIHNvIHRzaWNrbGUgbXVzdCBlbXVsYXRlIHRoZVxuICogYmVoYXZpb3VyLiBJdCBkb2VzIHNvIGJ5IGZvbGxvd2luZyB0aGlzIHNjaGVtZTpcbiAqXG4gKiAxLiBub24tbW9kdWxlIC5kLnRzIHByb2R1Y2VzIGdsb2JhbCBzeW1ib2xzXG4gKiAyLiBtb2R1bGUgLmQudHMgcHJvZHVjZSBzeW1ib2xzIG5hbWVzcGFjZWQgdG8gdGhlIG1vZHVsZSwgYnkgY3JlYXRpbmcgYVxuICogICAgbWFuZ2xlZCBuYW1lIG1hdGNoaW5nIHRoZSBjdXJyZW50IGZpbGUncyBwYXRoLiB0c2lja2xlIGV4cGVjdHMgb3V0c2lkZVxuICogICAgY29kZSAoZS5nLiBidWlsZCBzeXN0ZW0gaW50ZWdyYXRpb24gb3IgbWFudWFsbHkgd3JpdHRlbiBjb2RlKSB0byBjb250YWluIGFcbiAqICAgIGdvb2cubW9kdWxlL3Byb3ZpZGUgdGhhdCByZWZlcmVuY2VzIHRoZSBtYW5nbGVkIHBhdGguXG4gKiAzLiBkZWNsYXJhdGlvbnMgaW4gYC50c2AgZmlsZXMgcHJvZHVjZSB0eXBlcyB0aGF0IGNhbiBiZSBzZXBhcmF0ZWx5IGVtaXR0ZWRcbiAqICAgIGluIGUuZy4gYW4gYGV4dGVybnMuanNgLCB1c2luZyBgZ2V0R2VuZXJhdGVkRXh0ZXJuc2AgYmVsb3cuXG4gKiAgICAxLiBub24tZXhwb3J0ZWQgc3ltYm9scyBwcm9kdWNlIGdsb2JhbCB0eXBlcywgYmVjYXVzZSB0aGF0J3Mgd2hhdCB1c2Vyc1xuICogICAgICAgZXhwZWN0IGFuZCBpdCBtYXRjaGVzIFR5cGVTY3JpcHRzIGVtaXQsIHdoaWNoIGp1c3QgcmVmZXJlbmNlcyBgRm9vYCBmb3JcbiAqICAgICAgIGEgbG9jYWxseSBkZWNsYXJlZCBzeW1ib2wgYEZvb2AgaW4gYSBtb2R1bGUuIEFyZ3VhYmx5IHRoZXNlIHNob3VsZCBiZVxuICogICAgICAgd3JhcHBlZCBpbiBgZGVjbGFyZSBnbG9iYWwgeyAuLi4gfWAuXG4gKiAgICAyLiBleHBvcnRlZCBzeW1ib2xzIGFyZSBzY29wZWQgdG8gdGhlIGAudHNgIGZpbGUgYnkgcHJlZml4aW5nIHRoZW0gd2l0aCBhXG4gKiAgICAgICBtYW5nbGVkIG5hbWUuIEV4cG9ydGVkIHR5cGVzIGFyZSByZS1leHBvcnRlZCBmcm9tIHRoZSBKYXZhU2NyaXB0XG4gKiAgICAgICBgZ29vZy5tb2R1bGVgLCBhbGxvd2luZyBkb3duc3RyZWFtIGNvZGUgdG8gcmVmZXJlbmNlIHRoZW0uIFRoaXMgaGFzIHRoZVxuICogICAgICAgc2FtZSBwcm9ibGVtIHJlZ2FyZGluZyBhbWJpZW50IHZhbHVlcyBhcyBhYm92ZSwgaXQgaXMgdW5jbGVhciB3aGVyZSB0aGVcbiAqICAgICAgIHZhbHVlIHN5bWJvbCB3b3VsZCBiZSBkZWZpbmVkLCBzbyBmb3IgdGhlIHRpbWUgYmVpbmcgdGhpcyBpc1xuICogICAgICAgdW5zdXBwb3J0ZWQuXG4gKlxuICogVGhlIGVmZmVjdCBvZiB0aGlzIGlzIHRoYXQ6XG4gKiAtIHN5bWJvbHMgaW4gYSBtb2R1bGUgKGkuZS4gbm90IGdsb2JhbHMpIGFyZSBnZW5lcmFsbHkgc2NvcGVkIHRvIHRoZSBsb2NhbFxuICogICBtb2R1bGUgdXNpbmcgYSBtYW5nbGVkIG5hbWUsIHByZXZlbnRpbmcgc3ltYm9sIGNvbGxpc2lvbnMgb24gdGhlIENsb3N1cmVcbiAqICAgc2lkZS5cbiAqIC0gaW1wb3J0aW5nIGNvZGUgY2FuIHVuY29uZGl0aW9uYWxseSByZWZlciB0byBhbmQgaW1wb3J0IGFueSBzeW1ib2wgZGVmaW5lZFxuICogICBpbiBhIG1vZHVsZSBgWGAgYXMgYHBhdGgudG8ubW9kdWxlLlhgLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGRlZmluaW5nXG4gKiAgIGxvY2F0aW9uIGlzIGEgYC5kLnRzYCBmaWxlIG9yIGEgYC50c2AgZmlsZSwgYW5kIHJlZ2FyZGxlc3Mgd2hldGhlciB0aGVcbiAqICAgc3ltYm9sIGlzIGFtYmllbnQgKGFzc3VtaW5nIHRoZXJlJ3MgYW4gYXBwcm9wcmlhdGUgc2hpbSkuXG4gKiAtIGlmIHRoZXJlIGlzIGEgc2hpbSBwcmVzZW50LCB0c2lja2xlIGF2b2lkcyBlbWl0dGluZyB0aGUgQ2xvc3VyZSBuYW1lc3BhY2VcbiAqICAgaXRzZWxmLCBleHBlY3RpbmcgdGhlIHNoaW0gdG8gcHJvdmlkZSB0aGUgbmFtZXNwYWNlIGFuZCBpbml0aWFsaXplIGl0IHRvIGFcbiAqICAgc3ltYm9sIHRoYXQgcHJvdmlkZXMgdGhlIHJpZ2h0IHZhbHVlIGF0IHJ1bnRpbWUgKGkuZS4gdGhlIGltcGxlbWVudGF0aW9uIG9mXG4gKiAgIHdoYXRldmVyIHRoaXJkIHBhcnR5IGxpYnJhcnkgdGhlIC5kLnRzIGRlc2NyaWJlcykuXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7QW5ub3RhdG9ySG9zdCwgbW9kdWxlTmFtZUFzSWRlbnRpZmllcn0gZnJvbSAnLi9hbm5vdGF0b3JfaG9zdCc7XG5pbXBvcnQge2dldEVudW1UeXBlfSBmcm9tICcuL2VudW1fdHJhbnNmb3JtZXInO1xuaW1wb3J0IHtleHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydCwgcmVzb2x2ZU1vZHVsZU5hbWV9IGZyb20gJy4vZ29vZ21vZHVsZSc7XG5pbXBvcnQgKiBhcyBqc2RvYyBmcm9tICcuL2pzZG9jJztcbmltcG9ydCB7ZXNjYXBlRm9yQ29tbWVudCwgbWF5YmVBZGRIZXJpdGFnZUNsYXVzZXMsIG1heWJlQWRkVGVtcGxhdGVDbGF1c2V9IGZyb20gJy4vanNkb2NfdHJhbnNmb3JtZXInO1xuaW1wb3J0IHtNb2R1bGVUeXBlVHJhbnNsYXRvcn0gZnJvbSAnLi9tb2R1bGVfdHlwZV90cmFuc2xhdG9yJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAnLi9wYXRoJztcbmltcG9ydCB7Z2V0RW50aXR5TmFtZVRleHQsIGdldElkZW50aWZpZXJUZXh0LCBoYXNNb2RpZmllckZsYWcsIGlzQW1iaWVudCwgaXNEdHNGaWxlTmFtZSwgcmVwb3J0RGlhZ25vc3RpY30gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCB7aXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWV9IGZyb20gJy4vdHlwZV90cmFuc2xhdG9yJztcblxuLyoqXG4gKiBTeW1ib2xzIHRoYXQgYXJlIGFscmVhZHkgZGVjbGFyZWQgYXMgZXh0ZXJucyBpbiBDbG9zdXJlLCB0aGF0IHNob3VsZFxuICogYmUgYXZvaWRlZCBieSB0c2lja2xlJ3MgXCJkZWNsYXJlIC4uLlwiID0+IGV4dGVybnMuanMgY29udmVyc2lvbi5cbiAqL1xuY29uc3QgQ0xPU1VSRV9FWFRFUk5TX0JMQUNLTElTVDogUmVhZG9ubHlBcnJheTxzdHJpbmc+ID0gW1xuICAnZXhwb3J0cycsXG4gICdnbG9iYWwnLFxuICAnbW9kdWxlJyxcbiAgLy8gRXJyb3JDb25zdHJ1Y3RvciBpcyB0aGUgaW50ZXJmYWNlIG9mIHRoZSBFcnJvciBvYmplY3QgaXRzZWxmLlxuICAvLyB0c2lja2xlIGRldGVjdHMgdGhhdCB0aGlzIGlzIHBhcnQgb2YgdGhlIFR5cGVTY3JpcHQgc3RhbmRhcmQgbGlicmFyeVxuICAvLyBhbmQgYXNzdW1lcyBpdCdzIHBhcnQgb2YgdGhlIENsb3N1cmUgc3RhbmRhcmQgbGlicmFyeSwgYnV0IHRoaXNcbiAgLy8gYXNzdW1wdGlvbiBpcyB3cm9uZyBmb3IgRXJyb3JDb25zdHJ1Y3Rvci4gIFRvIHByb3Blcmx5IGhhbmRsZSB0aGlzXG4gIC8vIHdlJ2Qgc29tZWhvdyBuZWVkIHRvIG1hcCBtZXRob2RzIGRlZmluZWQgb24gdGhlIEVycm9yQ29uc3RydWN0b3JcbiAgLy8gaW50ZXJmYWNlIGludG8gcHJvcGVydGllcyBvbiBDbG9zdXJlJ3MgRXJyb3Igb2JqZWN0LCBidXQgZm9yIG5vdyBpdCdzXG4gIC8vIHNpbXBsZXIgdG8ganVzdCBibGFja2xpc3QgaXQuXG4gICdFcnJvckNvbnN0cnVjdG9yJyxcbiAgJ1N5bWJvbCcsXG4gICdXb3JrZXJHbG9iYWxTY29wZScsXG5dO1xuXG5cbi8qKlxuICogVGhlIGhlYWRlciB0byBiZSB1c2VkIGluIGdlbmVyYXRlZCBleHRlcm5zLiAgVGhpcyBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIG91dHB1dCBvZlxuICogZ2VuZXJhdGVFeHRlcm5zKCkgYmVjYXVzZSBnZW5lcmF0ZUV4dGVybnMoKSB3b3JrcyBvbmUgZmlsZSBhdCBhIHRpbWUsIGFuZCB0eXBpY2FsbHkgeW91IGNyZWF0ZVxuICogb25lIGV4dGVybnMgZmlsZSBmcm9tIHRoZSBlbnRpcmUgY29tcGlsYXRpb24gdW5pdC5cbiAqXG4gKiBTdXBwcmVzc2lvbnM6XG4gKiAtIGR1cGxpY2F0ZTogYmVjYXVzZSBleHRlcm5zIG1pZ2h0IGR1cGxpY2F0ZSByZS1vcGVuZWQgZGVmaW5pdGlvbnMgZnJvbSBvdGhlciBKUyBmaWxlcy5cbiAqIC0gY2hlY2tUeXBlczogQ2xvc3VyZSdzIHR5cGUgc3lzdGVtIGRvZXMgbm90IG1hdGNoIFRTJy5cbiAqIC0gdW5kZWZpbmVkTmFtZXM6IGNvZGUgYmVsb3cgdHJpZXMgdG8gYmUgY2FyZWZ1bCBub3QgdG8gb3ZlcndyaXRlIHByZXZpb3VzbHkgZW1pdHRlZCBkZWZpbml0aW9ucyxcbiAqICAgYnV0IG9uIHRoZSBmbGlwIHNpZGUgbWlnaHQgYWNjaWRlbnRhbGx5IG1pc3MgZGVmaW5pdGlvbnMuXG4gKi9cbmNvbnN0IEVYVEVSTlNfSEVBREVSID0gYC8qKlxuICogQCR7Jyd9ZXh0ZXJuc1xuICogQHN1cHByZXNzIHtkdXBsaWNhdGUsY2hlY2tUeXBlc31cbiAqL1xuLy8gTk9URTogZ2VuZXJhdGVkIGJ5IHRzaWNrbGUsIGRvIG5vdCBlZGl0LlxuYDtcblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbGwgZ2VuZXJhdGVkIGV4dGVybnMgZGVmaW5pdGlvbnMgdG9nZXRoZXIgaW50byBhIHN0cmluZywgaW5jbHVkaW5nIGEgZmlsZSBjb21tZW50XG4gKiBoZWFkZXIuXG4gKlxuICogQHBhcmFtIHJvb3REaXIgUHJvamVjdCByb290LiAgRW1pdHRlZCBjb21tZW50cyB3aWxsIHJlZmVyZW5jZSBwYXRocyByZWxhdGl2ZSB0byB0aGlzIHJvb3QuXG4gKiAgICBUaGlzIHBhcmFtIGlzIGVmZmVjdGl2ZWx5IHJlcXVpcmVkLCBidXQgbWFkZSBvcHRpb25hbCBoZXJlIHVudGlsIEFuZ3VsYXIgaXMgZml4ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZW5lcmF0ZWRFeHRlcm5zKFxuICAgIGV4dGVybnM6IHtbZmlsZU5hbWU6IHN0cmluZ106IHN0cmluZ30sIHJvb3REaXI/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgYWxsRXh0ZXJucyA9IEVYVEVSTlNfSEVBREVSO1xuICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIE9iamVjdC5rZXlzKGV4dGVybnMpKSB7XG4gICAgY29uc3Qgc3JjUGF0aCA9IHJvb3REaXIgPyBwYXRoLnJlbGF0aXZlKHJvb3REaXIsIGZpbGVOYW1lKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRVJST1I6IGdldEdlbmVyYXRlZEV4dGVybnMgY2FsbGVkIHdpdGhvdXQgcm9vdERpcic7XG4gICAgYWxsRXh0ZXJucyArPSBgLy8gZXh0ZXJucyBmcm9tICR7c3JjUGF0aH06XFxuYDtcbiAgICBhbGxFeHRlcm5zICs9IGV4dGVybnNbZmlsZU5hbWVdO1xuICB9XG4gIHJldHVybiBhbGxFeHRlcm5zO1xufVxuXG4vKipcbiAqIGlzSW5HbG9iYWxBdWdtZW50YXRpb24gcmV0dXJucyB0cnVlIGlmIGRlY2xhcmF0aW9uIGlzIHRoZSBpbW1lZGlhdGUgY2hpbGQgb2YgYSAnZGVjbGFyZSBnbG9iYWwnXG4gKiBibG9jay5cbiAqL1xuZnVuY3Rpb24gaXNJbkdsb2JhbEF1Z21lbnRhdGlvbihkZWNsYXJhdGlvbjogdHMuRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgLy8gZGVjbGFyZSBnbG9iYWwgeyAuLi4gfSBjcmVhdGVzIGEgTW9kdWxlRGVjbGFyYXRpb24gY29udGFpbmluZyBhIE1vZHVsZUJsb2NrIGNvbnRhaW5pbmcgdGhlXG4gIC8vIGRlY2xhcmF0aW9uLCB3aXRoIHRoZSBNb2R1bGVEZWNsYXJhdGlvbiBoYXZpbmcgdGhlIEdsb2JhbEF1Z21lbnRhdGlvbiBmbGFnIHNldC5cbiAgaWYgKCFkZWNsYXJhdGlvbi5wYXJlbnQgfHwgIWRlY2xhcmF0aW9uLnBhcmVudC5wYXJlbnQpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIChkZWNsYXJhdGlvbi5wYXJlbnQucGFyZW50LmZsYWdzICYgdHMuTm9kZUZsYWdzLkdsb2JhbEF1Z21lbnRhdGlvbikgIT09IDA7XG59XG5cbi8qKlxuICogZ2VuZXJhdGVFeHRlcm5zIGdlbmVyYXRlcyBleHRlcm4gZGVmaW5pdGlvbnMgZm9yIGFsbCBhbWJpZW50IGRlY2xhcmF0aW9ucyBpbiB0aGUgZ2l2ZW4gc291cmNlXG4gKiBmaWxlLiBJdCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBDbG9zdXJlIEphdmFTY3JpcHQsIG5vdCBpbmNsdWRpbmcgdGhlIGluaXRpYWxcbiAqIGNvbW1lbnQgd2l0aCBcXEBmaWxlb3ZlcnZpZXcgYW5kICNleHRlcm5zIChzZWUgYWJvdmUgZm9yIHRoYXQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVFeHRlcm5zKFxuICAgIHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlciwgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSwgaG9zdDogQW5ub3RhdG9ySG9zdCxcbiAgICBtb2R1bGVSZXNvbHV0aW9uSG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3QsXG4gICAgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zKToge291dHB1dDogc3RyaW5nLCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdfSB7XG4gIGxldCBvdXRwdXQgPSAnJztcbiAgY29uc3QgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSA9IFtdO1xuICBjb25zdCBpc0R0cyA9IGlzRHRzRmlsZU5hbWUoc291cmNlRmlsZS5maWxlTmFtZSk7XG4gIGNvbnN0IGlzRXh0ZXJuYWxNb2R1bGUgPSB0cy5pc0V4dGVybmFsTW9kdWxlKHNvdXJjZUZpbGUpO1xuXG4gIGNvbnN0IG10dCA9XG4gICAgICBuZXcgTW9kdWxlVHlwZVRyYW5zbGF0b3Ioc291cmNlRmlsZSwgdHlwZUNoZWNrZXIsIGhvc3QsIGRpYWdub3N0aWNzLCAvKmlzRm9yRXh0ZXJucyovIHRydWUpO1xuXG4gIC8vIC5kLnRzIGZpbGVzIGRlY2xhcmUgc3ltYm9scy4gVGhlIGNvZGUgYmVsb3cgdHJhbnNsYXRlcyB0aGVzZSBpbnRvIGEgZm9ybSB1bmRlcnN0b29kIGJ5IENsb3N1cmVcbiAgLy8gQ29tcGlsZXIsIGNvbnZlcnRpbmcgdGhlIHR5cGUgc3ludGF4LCBidXQgYWxzbyBjb252ZXJ0aW5nIHN5bWJvbCBuYW1lcyBpbnRvIGEgZm9ybSBhY2Nlc3NpYmxlXG4gIC8vIHRvIENsb3N1cmUgQ29tcGlsZXIuXG5cbiAgLy8gTGlrZSByZWd1bGFyIC50cyBmaWxlcywgLmQudHMgY2FuIGJlIGVpdGhlciBzY3JpcHRzIG9yIG1vZHVsZXMuIFNjcmlwdHMgZGVjbGFyZSBzeW1ib2xzIGluIHRoZVxuICAvLyBnbG9iYWwgbmFtZXNwYWNlLCB3aGljaCBoYXMgdGhlIHNhbWUgc2VtYW50aWNzIGluIENsb3N1cmUgYW5kIFR5cGVTY3JpcHQsIHNvIHRoZSBjb2RlIGJlbG93XG4gIC8vIGVtaXRzIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZS5cblxuICAvLyBNb2R1bGVzIGhvd2V2ZXIgZGVjbGFyZSBzeW1ib2xzIHNjb3BlZCB0byB0aGUgbW9kdWxlIHRoYXQgY2FuIGJlIGV4cG9ydGVkLiBDbG9zdXJlIGhhcyBub1xuICAvLyBjb25jZXB0IG9mIGV4dGVybnMgdGhhdCBhcmUgbm9uLWdsb2JhbCwgc28gdHNpY2tsZSBuZWVkcyB0byBtYW5nbGUgdGhlIHN5bWJvbCBuYW1lcywgYm90aCBhdFxuICAvLyB0aGVpciBkZWNsYXJhdGlvbiBhbmQgYXQgdGhlaXIgdXNlIHNpdGUuXG5cbiAgLy8gVGhpcyBtYW5nbGluZyBoYXBwZW5zIGJ5IHdyYXBwaW5nIGFsbCBkZWNsYXJlZCBzeW1ib2xzIGluIGEgbmFtZXNwYWNlIGJhc2VkIG9uIHRoZSBmaWxlIG5hbWUuXG4gIC8vIFRoaXMgbmFtZXNwYWNlIGlzIHRoZW4gZXNzZW50aWFsbHkgdGhlIGV4cG9ydHMgb2JqZWN0IGZvciB0aGUgYW1iaWVudCBtb2R1bGUgKGV4dGVybnMgaW5cbiAgLy8gQ2xvc3VyZSB0ZXJtcykuIFRoaXMgbmFtZXNwYWNlIGlzIGNhbGxlZCBgbW9kdWxlTmFtZXNwYWNlYCBiZWxvdzpcbiAgbGV0IG1vZHVsZU5hbWVzcGFjZSA9ICcnO1xuICBpZiAoaXNFeHRlcm5hbE1vZHVsZSkge1xuICAgIG1vZHVsZU5hbWVzcGFjZSA9IG1vZHVsZU5hbWVBc0lkZW50aWZpZXIoaG9zdCwgc291cmNlRmlsZS5maWxlTmFtZSk7XG4gIH1cblxuICAvLyBTeW1ib2xzIGFyZSBnZW5lcmF0ZWQgc3RhcnRpbmcgaW4gcm9vdE5hbWVzcGFjZS4gRm9yIHNjcmlwdCAuZC50cyB3aXRoIGdsb2JhbCBzeW1ib2xzLCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcuIEZvciBtb3N0IG1vZHVsZSBgLmQudHNgIGZpbGVzLCB0aGlzIGlzIHRoZSBtYW5nbGVkIG5hbWVzcGFjZSBvYmplY3QuIFRoZVxuICAvLyByZW1haW5pbmcgc3BlY2lhbCBjYXNlIGFyZSBgLmQudHNgIGZpbGVzIGNvbnRhaW5pbmcgYW4gYGV4cG9ydCA9IHNvbWV0aGluZztgIHN0YXRlbWVudC4gSW5cbiAgLy8gdGhlc2UsIHRoZSBlZmZlY3RpdmUgZXhwb3J0cyBvYmplY3QsIGkuZS4gdGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBzeW1ib2xzIHRoYXQgaW1wb3J0aW5nIGNvZGVcbiAgLy8gcmVjZWl2ZXMsIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBtYWluIG1vZHVsZSBzY29wZS5cbiAgLy8gdHNpY2tsZSBoYW5kbGVzIHRoZSBgZXhwb3J0ID1gIGNhc2UgYnkgZ2VuZXJhdGluZyBzeW1ib2xzIGluIGEgZGlmZmVyZW50IG5hbWVzcGFjZSAoZXNjYXBlZFxuICAvLyB3aXRoIGEgYF9gKSBiZWxvdywgYW5kIHRoZW4gYXNzaWduaW5nIHdoYXRldmVyIGlzIGFjdHVhbGx5IGV4cG9ydGVkIGludG8gdGhlIGBtb2R1bGVOYW1lc3BhY2VgXG4gIC8vIGJlbG93LlxuICBsZXQgcm9vdE5hbWVzcGFjZSA9IG1vZHVsZU5hbWVzcGFjZTtcbiAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIGV4cG9ydCA9LCBhbmQgaWYgdGhlcmUgaXMgb25lLCB0aGVyZSBjYW5ub3QgYmUgYW55IG90aGVyIGV4cG9ydHMuXG4gIGNvbnN0IGV4cG9ydEFzc2lnbm1lbnQgPSBzb3VyY2VGaWxlLnN0YXRlbWVudHMuZmluZCh0cy5pc0V4cG9ydEFzc2lnbm1lbnQpO1xuICBjb25zdCBoYXNFeHBvcnRFcXVhbHMgPSBleHBvcnRBc3NpZ25tZW50ICYmIGV4cG9ydEFzc2lnbm1lbnQuaXNFeHBvcnRFcXVhbHM7XG4gIGlmIChoYXNFeHBvcnRFcXVhbHMpIHtcbiAgICAvLyBJZiBzbywgbW92ZSBhbGwgZ2VuZXJhdGVkIHN5bWJvbHMgaW50byBhIGRpZmZlcmVudCBzdWItbmFtZXNwYWNlLCBzbyB0aGF0IGxhdGVyIG9uIHdlIGNhblxuICAgIC8vIGNvbnRyb2wgd2hhdCBleGFjdGx5IGdvZXMgb24gdGhlIGFjdHVhbCBleHBvcnRlZCBuYW1lc3BhY2UuXG4gICAgcm9vdE5hbWVzcGFjZSA9IHJvb3ROYW1lc3BhY2UgKyAnXyc7XG4gIH1cblxuICBmb3IgKGNvbnN0IHN0bXQgb2Ygc291cmNlRmlsZS5zdGF0ZW1lbnRzKSB7XG4gICAgaWYgKCFpc0R0cyAmJiAhaGFzTW9kaWZpZXJGbGFnKHN0bXQgYXMgdHMuRGVjbGFyYXRpb25TdGF0ZW1lbnQsIHRzLk1vZGlmaWVyRmxhZ3MuQW1iaWVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2aXNpdG9yKHN0bXQsIFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgcXVhbGlmaWVkIG5hbWUgZnJvbSBhIC5kLnRzIGZpbGUgb3IgZGVjbGFyYXRpb24gY29udGV4dCBpbnRvIGEgbWFuZ2xlZCBpZGVudGlmaWVyLlxuICAgKiBFLmcuIGZvciBhIHF1YWxpZmllZCBuYW1lIGluIGBleHBvcnQgPSBzb21lTmFtZTtgIG9yIGBpbXBvcnQgPSBzb21lTmFtZTtgLlxuICAgKiBJZiBgc29tZU5hbWVgIGlzIGBkZWNsYXJlIGdsb2JhbCB7IG5hbWVzcGFjZSBzb21lTmFtZSB7Li4ufSB9YCwgdHNpY2tsZSBtdXN0IG5vdCBxdWFsaWZ5IGFjY2Vzc1xuICAgKiB0byBpdCB3aXRoIHRoZSBtYW5nbGVkIG1vZHVsZSBuYW1lc3BhY2UgYXMgaXQgaXMgZW1pdHRlZCBpbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZS4gU2ltaWxhcmx5LCBpZlxuICAgKiB0aGUgc3ltYm9sIGlzIGRlY2xhcmVkIGluIGEgbm9uLW1vZHVsZSBjb250ZXh0LCBpdCBtdXN0IG5vdCBiZSBtYW5nbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gcXVhbGlmaWVkTmFtZVRvTWFuZ2xlZElkZW50aWZpZXIobmFtZTogdHMuSWRlbnRpZmllcnx0cy5RdWFsaWZpZWROYW1lKSB7XG4gICAgY29uc3QgZW50aXR5TmFtZSA9IGdldEVudGl0eU5hbWVUZXh0KG5hbWUpO1xuICAgIGxldCBzeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5hbWUpO1xuICAgIGlmIChzeW1ib2wpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYW4gYWxpYXNlZCBuYW1lIChlLmcuIGZyb20gYW4gaW1wb3J0KSwgdXNlIHRoZSBhbGlhcyB0byByZWZlciB0byBpdC5cbiAgICAgIGlmIChzeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgICBzeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bWJvbCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlhcyA9IG10dC5zeW1ib2xzVG9BbGlhc2VkTmFtZXMuZ2V0KHN5bWJvbCk7XG4gICAgICBpZiAoYWxpYXMpIHJldHVybiBhbGlhcztcbiAgICAgIGNvbnN0IGlzR2xvYmFsU3ltYm9sID0gc3ltYm9sICYmIHN5bWJvbC5kZWNsYXJhdGlvbnMgJiYgc3ltYm9sLmRlY2xhcmF0aW9ucy5zb21lKGQgPT4ge1xuICAgICAgICBpZiAoaXNJbkdsb2JhbEF1Z21lbnRhdGlvbihkKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIElmIHRoZSBkZWNsYXJhdGlvbidzIHNvdXJjZSBmaWxlIGlzIG5vdCBhIG1vZHVsZSwgaXQgbXVzdCBiZSBnbG9iYWwuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgbW9kdWxlLCB0aGUgaWRlbnRpZmllciBtdXN0IGJlIGxvY2FsIHRvIHRoaXMgZmlsZSwgb3IgaGFuZGxlZCBhYm92ZSB2aWEgdGhlXG4gICAgICAgIC8vIGFsaWFzLlxuICAgICAgICByZXR1cm4gIXRzLmlzRXh0ZXJuYWxNb2R1bGUoZC5nZXRTb3VyY2VGaWxlKCkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXNHbG9iYWxTeW1ib2wpIHJldHVybiBlbnRpdHlOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdE5hbWVzcGFjZSArICcuJyArIGVudGl0eU5hbWU7XG4gIH1cblxuICBpZiAob3V0cHV0ICYmIGlzRXh0ZXJuYWxNb2R1bGUpIHtcbiAgICAvLyBJZiB0c2lja2xlIGdlbmVyYXRlZCBhbnkgZXh0ZXJucyBhbmQgdGhpcyBpcyBhbiBleHRlcm5hbCBtb2R1bGUsIHByZXBlbmQgdGhlIG5hbWVzcGFjZVxuICAgIC8vIGRlY2xhcmF0aW9uIGZvciBpdC5cbiAgICBvdXRwdXQgPSBgLyoqIEBjb25zdCAqL1xcbnZhciAke3Jvb3ROYW1lc3BhY2V9ID0ge307XFxuYCArIG91dHB1dDtcblxuICAgIGxldCBleHBvcnRlZE5hbWVzcGFjZSA9IHJvb3ROYW1lc3BhY2U7XG4gICAgaWYgKGV4cG9ydEFzc2lnbm1lbnQgJiYgaGFzRXhwb3J0RXF1YWxzKSB7XG4gICAgICBpZiAodHMuaXNJZGVudGlmaWVyKGV4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbikgfHxcbiAgICAgICAgICB0cy5pc1F1YWxpZmllZE5hbWUoZXhwb3J0QXNzaWdubWVudC5leHByZXNzaW9uKSkge1xuICAgICAgICAvLyBFLmcuIGV4cG9ydCA9IHNvbWVOYW1lO1xuICAgICAgICAvLyBJZiBzb21lTmFtZSBpcyBcImRlY2xhcmUgZ2xvYmFsIHsgbmFtZXNwYWNlIHNvbWVOYW1lIHsuLi59IH1cIiwgdHNpY2tsZSBtdXN0IG5vdCBxdWFsaWZ5XG4gICAgICAgIC8vIGFjY2VzcyB0byBpdCB3aXRoIG1vZHVsZSBuYW1lc3BhY2UgYXMgaXQgaXMgZW1pdHRlZCBpbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgZXhwb3J0ZWROYW1lc3BhY2UgPSBxdWFsaWZpZWROYW1lVG9NYW5nbGVkSWRlbnRpZmllcihleHBvcnRBc3NpZ25tZW50LmV4cHJlc3Npb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwb3J0RGlhZ25vc3RpYyhcbiAgICAgICAgICAgIGRpYWdub3N0aWNzLCBleHBvcnRBc3NpZ25tZW50LmV4cHJlc3Npb24sXG4gICAgICAgICAgICBgZXhwb3J0ID0gZXhwcmVzc2lvbiBtdXN0IGJlIGEgcXVhbGlmaWVkIG5hbWUsIGdvdCAke1xuICAgICAgICAgICAgICAgIHRzLlN5bnRheEtpbmRbZXhwb3J0QXNzaWdubWVudC5leHByZXNzaW9uLmtpbmRdfS5gKTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc2lnbiB0aGUgYWN0dWFsbHkgZXhwb3J0ZWQgbmFtZXNwYWNlIG9iamVjdCAod2hpY2ggbGl2ZXMgc29tZXdoZXJlIHVuZGVyIHJvb3ROYW1lc3BhY2UpXG4gICAgICAvLyBpbnRvIHRoZSBtb2R1bGUncyBuYW1lc3BhY2UuXG4gICAgICBlbWl0KGAvKipcXG4gKiBleHBvcnQgPSAke2V4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbi5nZXRUZXh0KCl9XFxuICogQGNvbnN0XFxuICovXFxuYCk7XG4gICAgICBlbWl0KGB2YXIgJHttb2R1bGVOYW1lc3BhY2V9ID0gJHtleHBvcnRlZE5hbWVzcGFjZX07XFxuYCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRHRzICYmIGhvc3QucHJvdmlkZUV4dGVybmFsTW9kdWxlRHRzTmFtZXNwYWNlKSB7XG4gICAgICAvLyBJbiBhIG5vbi1zaGltbWVkIG1vZHVsZSwgY3JlYXRlIGEgZ2xvYmFsIG5hbWVzcGFjZS4gVGhpcyBleGlzdHMgcHVyZWx5IGZvciBiYWNrd2FyZHNcbiAgICAgIC8vIGNvbXBhdGlibGl0eSwgaW4gdGhlIG1lZGl1bSB0ZXJtIGFsbCBjb2RlIHVzaW5nIHRzaWNrbGUgc2hvdWxkIGFsd2F5cyB1c2UgYGdvb2cubW9kdWxlYHMsXG4gICAgICAvLyBzbyBnbG9iYWwgbmFtZXMgc2hvdWxkIG5vdCBiZSBuZWNjZXNzYXJ5LlxuICAgICAgZm9yIChjb25zdCBuc0V4cG9ydCBvZiBzb3VyY2VGaWxlLnN0YXRlbWVudHMuZmlsdGVyKHRzLmlzTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24pKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZU5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChuc0V4cG9ydC5uYW1lKTtcbiAgICAgICAgZW1pdChgLy8gZXhwb3J0IGFzIG5hbWVzcGFjZSAke25hbWVzcGFjZU5hbWV9XFxuYCk7XG4gICAgICAgIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobmFtZXNwYWNlTmFtZSwgW10sIGV4cG9ydGVkTmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge291dHB1dCwgZGlhZ25vc3RpY3N9O1xuXG4gIGZ1bmN0aW9uIGVtaXQoc3RyOiBzdHJpbmcpIHtcbiAgICBvdXRwdXQgKz0gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIGlzRmlyc3REZWNsYXJhdGlvbiByZXR1cm5zIHRydWUgaWYgZGVjbCBpcyB0aGUgZmlyc3QgZGVjbGFyYXRpb25cbiAgICogb2YgaXRzIHN5bWJvbC4gIEUuZy4gaW1hZ2luZVxuICAgKiAgIGludGVyZmFjZSBGb28geyB4OiBudW1iZXI7IH1cbiAgICogICBpbnRlcmZhY2UgRm9vIHsgeTogbnVtYmVyOyB9XG4gICAqIHdlIG9ubHkgd2FudCB0byBlbWl0IHRoZSBcIlxcQHJlY29yZFwiIGZvciBGb28gb24gdGhlIGZpcnN0IG9uZS5cbiAgICpcbiAgICogVGhlIGV4Y2VwdGlvbiBhcmUgdmFyaWFibGUgZGVjbGFyYXRpb25zLCB3aGljaCAtIGluIGV4dGVybnMgLSBkbyBub3QgYXNzaWduIGEgdmFsdWU6XG4gICAqICAgLy4uIFxcQHR5cGUgey4uLn0gLi9cbiAgICogICB2YXIgc29tZVZhcmlhYmxlO1xuICAgKiAgIC8uLiBcXEB0eXBlIHsuLi59IC4vXG4gICAqICAgc29tZU5hbWVzcGFjZS5zb21lVmFyaWFibGU7XG4gICAqIElmIGEgbGF0ZXIgZGVjbGFyYXRpb24gd2FudHMgdG8gYWRkIGFkZGl0aW9uYWwgcHJvcGVydGllcyBvbiBzb21lVmFyaWFibGUsIHRzaWNrbGUgbXVzdCBzdGlsbFxuICAgKiBlbWl0IGFuIGFzc2lnbm1lbnQgaW50byB0aGUgb2JqZWN0LCBhcyBpdCdzIG90aGVyd2lzZSBhYnNlbnQuXG4gICAqL1xuICBmdW5jdGlvbiBpc0ZpcnN0VmFsdWVEZWNsYXJhdGlvbihkZWNsOiB0cy5EZWNsYXJhdGlvblN0YXRlbWVudCk6IGJvb2xlYW4ge1xuICAgIGlmICghZGVjbC5uYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBzeW0gPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKGRlY2wubmFtZSkhO1xuICAgIGlmICghc3ltLmRlY2xhcmF0aW9ucyB8fCBzeW0uZGVjbGFyYXRpb25zLmxlbmd0aCA8IDIpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGVhcmxpZXJEZWNscyA9IHN5bS5kZWNsYXJhdGlvbnMuc2xpY2UoMCwgc3ltLmRlY2xhcmF0aW9ucy5pbmRleE9mKGRlY2wpKTtcbiAgICAvLyBFaXRoZXIgdGhlcmUgYXJlIG5vIGVhcmxpZXIgZGVjbGFyYXRpb25zLCBvciBhbGwgb2YgdGhlbSBhcmUgdmFyaWFibGVzIChzZWUgYWJvdmUpLiB0c2lja2xlXG4gICAgLy8gZW1pdHMgYSB2YWx1ZSBmb3IgYWxsIG90aGVyIGRlY2xhcmF0aW9uIGtpbmRzIChmdW5jdGlvbiBmb3IgZnVuY3Rpb25zLCBjbGFzc2VzLCBpbnRlcmZhY2VzLFxuICAgIC8vIHt9IG9iamVjdCBmb3IgbmFtZXNwYWNlcykuXG4gICAgcmV0dXJuIGVhcmxpZXJEZWNscy5sZW5ndGggPT09IDAgfHwgZWFybGllckRlY2xzLmV2ZXJ5KHRzLmlzVmFyaWFibGVEZWNsYXJhdGlvbik7XG4gIH1cblxuICAvKiogV3JpdGVzIHRoZSBhY3R1YWwgdmFyaWFibGUgc3RhdGVtZW50IG9mIGEgQ2xvc3VyZSB2YXJpYWJsZSBkZWNsYXJhdGlvbi4gKi9cbiAgZnVuY3Rpb24gd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lOiBzdHJpbmcsIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCB2YWx1ZT86IHN0cmluZykge1xuICAgIGNvbnN0IHF1YWxpZmllZE5hbWUgPSBuYW1lc3BhY2UuY29uY2F0KFtuYW1lXSkuam9pbignLicpO1xuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID09PSAwKSBlbWl0KGB2YXIgYCk7XG4gICAgZW1pdChxdWFsaWZpZWROYW1lKTtcbiAgICBpZiAodmFsdWUpIGVtaXQoYCA9ICR7dmFsdWV9YCk7XG4gICAgZW1pdCgnO1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhIENsb3N1cmUgdmFyaWFibGUgZGVjbGFyYXRpb24sIGkuZS4gdGhlIHZhcmlhYmxlIHN0YXRlbWVudCB3aXRoIGEgbGVhZGluZyBKU0RvY1xuICAgKiBjb21tZW50IG1ha2luZyBpdCBhIGRlY2xhcmF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gd3JpdGVWYXJpYWJsZURlY2xhcmF0aW9uKFxuICAgICAgZGVjbDogdHMuVmFyaWFibGVEZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICBpZiAoZGVjbC5uYW1lLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgY29uc3QgbmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGRlY2wubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICAgIGlmIChDTE9TVVJFX0VYVEVSTlNfQkxBQ0tMSVNULmluZGV4T2YobmFtZSkgPj0gMCkgcmV0dXJuO1xuICAgICAgZW1pdChqc2RvYy50b1N0cmluZyhbe3RhZ05hbWU6ICd0eXBlJywgdHlwZTogbXR0LnR5cGVUb0Nsb3N1cmUoZGVjbCl9XSkpO1xuICAgICAgZW1pdCgnXFxuJyk7XG4gICAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KG5hbWUsIG5hbWVzcGFjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yVW5pbXBsZW1lbnRlZEtpbmQoZGVjbC5uYW1lLCAnZXh0ZXJucyBmb3IgdmFyaWFibGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYSBKU0RvYyBkZWNsYXJhdGlvbiB0aGF0IG1lcmdlcyB0aGUgc2lnbmF0dXJlcyBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gZGVjbGFyYXRpb24gKGZvclxuICAgKiBvdmVybG9hZHMpLCBhbmQgcmV0dXJucyB0aGUgcGFyYW1ldGVyIG5hbWVzIGNob3Nlbi5cbiAgICovXG4gIGZ1bmN0aW9uIGVtaXRGdW5jdGlvblR5cGUoZGVjbHM6IHRzLkZ1bmN0aW9uTGlrZURlY2xhcmF0aW9uW10sIGV4dHJhVGFnczoganNkb2MuVGFnW10gPSBbXSkge1xuICAgIGNvbnN0IHt0YWdzLCBwYXJhbWV0ZXJOYW1lc30gPSBtdHQuZ2V0RnVuY3Rpb25UeXBlSlNEb2MoZGVjbHMsIGV4dHJhVGFncyk7XG4gICAgZW1pdCgnXFxuJyk7XG4gICAgZW1pdChqc2RvYy50b1N0cmluZyh0YWdzKSk7XG4gICAgcmV0dXJuIHBhcmFtZXRlck5hbWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVGdW5jdGlvbihuYW1lOiB0cy5Ob2RlLCBwYXJhbXM6IHN0cmluZ1tdLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuICAgIGNvbnN0IHBhcmFtc1N0ciA9IHBhcmFtcy5qb2luKCcsICcpO1xuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGZxbiA9IG5hbWVzcGFjZS5qb2luKCcuJyk7XG4gICAgICBpZiAobmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgZnFuICs9ICcuJzsgIC8vIGNvbXB1dGVkIG5hbWVzIGluY2x1ZGUgWyBdIGluIHRoZWlyIGdldFRleHQoKSByZXByZXNlbnRhdGlvbi5cbiAgICAgIH1cbiAgICAgIGZxbiArPSBuYW1lLmdldFRleHQoKTtcbiAgICAgIGVtaXQoYCR7ZnFufSA9IGZ1bmN0aW9uKCR7cGFyYW1zU3RyfSkge307XFxuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuYW1lLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgICByZXBvcnREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBuYW1lLCAnTm9uLW5hbWVzcGFjZWQgY29tcHV0ZWQgbmFtZSBpbiBleHRlcm5zJyk7XG4gICAgICB9XG4gICAgICBlbWl0KGBmdW5jdGlvbiAke25hbWUuZ2V0VGV4dCgpfSgke3BhcmFtc1N0cn0pIHt9XFxuYCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVFbnVtKGRlY2w6IHRzLkVudW1EZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICAvLyBFLmcuIC8qKiBAZW51bSB7bnVtYmVyfSAqLyB2YXIgQ09VTlRSWSA9IHtVUzogMSwgQ0E6IDF9O1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUpO1xuICAgIGxldCBtZW1iZXJzID0gJyc7XG4gICAgY29uc3QgZW51bVR5cGUgPSBnZXRFbnVtVHlwZSh0eXBlQ2hlY2tlciwgZGVjbCk7XG4gICAgLy8gQ2xvc3VyZSBlbnVtcyBtZW1iZXJzIG11c3QgaGF2ZSBhIHZhbHVlIG9mIHRoZSBjb3JyZWN0IHR5cGUsIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIGRvZXMgbm90XG4gICAgLy8gbWF0dGVyIGluIGV4dGVybnMuXG4gICAgY29uc3QgaW5pdGlhbGl6ZXIgPSBlbnVtVHlwZSA9PT0gJ3N0cmluZycgPyBgJydgIDogMTtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBkZWNsLm1lbWJlcnMpIHtcbiAgICAgIGxldCBtZW1iZXJOYW1lOiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgICAgc3dpdGNoIChtZW1iZXIubmFtZS5raW5kKSB7XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JZGVudGlmaWVyOlxuICAgICAgICAgIG1lbWJlck5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChtZW1iZXIubmFtZSBhcyB0cy5JZGVudGlmaWVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgICAgY29uc3QgdGV4dCA9IChtZW1iZXIubmFtZSBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgICAgICAgIGlmIChpc1ZhbGlkQ2xvc3VyZVByb3BlcnR5TmFtZSh0ZXh0KSkgbWVtYmVyTmFtZSA9IHRleHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIW1lbWJlck5hbWUpIHtcbiAgICAgICAgbWVtYmVycyArPSBgICAvKiBUT0RPOiAke3RzLlN5bnRheEtpbmRbbWVtYmVyLm5hbWUua2luZF19OiAke1xuICAgICAgICAgICAgZXNjYXBlRm9yQ29tbWVudChtZW1iZXIubmFtZS5nZXRUZXh0KCkpfSAqL1xcbmA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWVtYmVycyArPSBgICAke21lbWJlck5hbWV9OiAke2luaXRpYWxpemVyfSxcXG5gO1xuICAgIH1cblxuICAgIGVtaXQoYFxcbi8qKiBAZW51bSB7JHtlbnVtVHlwZX19ICovXFxuYCk7XG4gICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lLCBuYW1lc3BhY2UsIGB7XFxuJHttZW1iZXJzfX1gKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlVHlwZUFsaWFzKGRlY2w6IHRzLlR5cGVBbGlhc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuICAgIGNvbnN0IHR5cGVTdHIgPSBtdHQudHlwZVRvQ2xvc3VyZShkZWNsLCB1bmRlZmluZWQpO1xuICAgIGVtaXQoYFxcbi8qKiBAdHlwZWRlZiB7JHt0eXBlU3RyfX0gKi9cXG5gKTtcbiAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KGdldElkZW50aWZpZXJUZXh0KGRlY2wubmFtZSksIG5hbWVzcGFjZSk7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZVR5cGUoXG4gICAgICBkZWNsOiB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbnx0cy5DbGFzc0RlY2xhcmF0aW9uLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuICAgIGNvbnN0IG5hbWUgPSBkZWNsLm5hbWU7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXBvcnREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBkZWNsLCAnYW5vbnltb3VzIHR5cGUgaW4gZXh0ZXJucycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlTmFtZSA9IG5hbWVzcGFjZS5jb25jYXQoW25hbWUuZ2V0VGV4dCgpXSkuam9pbignLicpO1xuICAgIGlmIChDTE9TVVJFX0VYVEVSTlNfQkxBQ0tMSVNULmluZGV4T2YodHlwZU5hbWUpID49IDApIHJldHVybjtcblxuICAgIGlmIChpc0ZpcnN0VmFsdWVEZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgLy8gRW1pdCB0aGUgJ2Z1bmN0aW9uJyB0aGF0IGlzIGFjdHVhbGx5IHRoZSBkZWNsYXJhdGlvbiBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICAvLyBpdHNlbGYuICBJZiBpdCdzIGEgY2xhc3MsIHRoaXMgZnVuY3Rpb24gYWxzbyBtdXN0IGluY2x1ZGUgdGhlIHR5cGVcbiAgICAgIC8vIGFubm90YXRpb25zIG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIGxldCBwYXJhbU5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgY29uc3QganNkb2NUYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgICAgbGV0IHdyb3RlSnNEb2MgPSBmYWxzZTtcbiAgICAgIG1heWJlQWRkSGVyaXRhZ2VDbGF1c2VzKGpzZG9jVGFncywgbXR0LCBkZWNsKTtcbiAgICAgIG1heWJlQWRkVGVtcGxhdGVDbGF1c2UoanNkb2NUYWdzLCBkZWNsKTtcbiAgICAgIGlmIChkZWNsLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbikge1xuICAgICAgICAvLyBUT0RPOiBpdCBhcHBlYXJzIHlvdSBjYW4ganVzdCB3cml0ZSAnY2xhc3MgRm9vIHsgLi4uJyBpbiBleHRlcm5zLlxuICAgICAgICAvLyBUaGlzIGNvZGUgaW5zdGVhZCB0cmllcyB0byB0cmFuc2xhdGUgaXQgdG8gYSBmdW5jdGlvbi5cbiAgICAgICAganNkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdjb25zdHJ1Y3Rvcid9LCB7dGFnTmFtZTogJ3N0cnVjdCd9KTtcbiAgICAgICAgY29uc3QgY3RvcnMgPSAoZGVjbCBhcyB0cy5DbGFzc0RlY2xhcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAubWVtYmVycy5maWx0ZXIoKG0pID0+IG0ua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmIChjdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdEN0b3I6IHRzLkNvbnN0cnVjdG9yRGVjbGFyYXRpb24gPSBjdG9yc1swXSBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uO1xuICAgICAgICAgIGlmIChjdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwYXJhbU5hbWVzID0gZW1pdEZ1bmN0aW9uVHlwZShjdG9ycyBhcyB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uW10sIGpzZG9jVGFncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtTmFtZXMgPSBlbWl0RnVuY3Rpb25UeXBlKFtmaXJzdEN0b3JdLCBqc2RvY1RhZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3cm90ZUpzRG9jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0J3MgYW4gaW50ZXJmYWNlOyB0YWcgaXQgYXMgc3RydWN0dXJhbGx5IHR5cGVkLlxuICAgICAgICBqc2RvY1RhZ3MucHVzaCh7dGFnTmFtZTogJ3JlY29yZCd9LCB7dGFnTmFtZTogJ3N0cnVjdCd9KTtcbiAgICAgIH1cbiAgICAgIGlmICghd3JvdGVKc0RvYykgZW1pdChqc2RvYy50b1N0cmluZyhqc2RvY1RhZ3MpKTtcbiAgICAgIHdyaXRlRnVuY3Rpb24obmFtZSwgcGFyYW1OYW1lcywgbmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGV2ZXJ5dGhpbmcgZXhjZXB0IChNZXRob2RTaWduYXR1cmV8TWV0aG9kRGVjbGFyYXRpb258Q29uc3RydWN0b3IpXG4gICAgY29uc3QgbWV0aG9kcyA9IG5ldyBNYXA8c3RyaW5nLCB0cy5NZXRob2REZWNsYXJhdGlvbltdPigpO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlY2wubWVtYmVycykge1xuICAgICAgc3dpdGNoIChtZW1iZXIua2luZCkge1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlTaWduYXR1cmU6XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Qcm9wZXJ0eURlY2xhcmF0aW9uOlxuICAgICAgICAgIGNvbnN0IHByb3AgPSBtZW1iZXIgYXMgdHMuUHJvcGVydHlTaWduYXR1cmU7XG4gICAgICAgICAgaWYgKHByb3AubmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gbXR0LnR5cGVUb0Nsb3N1cmUocHJvcCk7XG4gICAgICAgICAgICBpZiAocHJvcC5xdWVzdGlvblRva2VuICYmIHR5cGUgPT09ICc/Jykge1xuICAgICAgICAgICAgICAvLyBBbiBvcHRpb25hbCAnYW55JyB0eXBlIHRyYW5zbGF0ZXMgdG8gJz98dW5kZWZpbmVkJyBpbiBDbG9zdXJlLlxuICAgICAgICAgICAgICB0eXBlID0gJz98dW5kZWZpbmVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXQoanNkb2MudG9TdHJpbmcoW3t0YWdOYW1lOiAndHlwZScsIHR5cGV9XSkpO1xuICAgICAgICAgICAgaWYgKGhhc01vZGlmaWVyRmxhZyhwcm9wLCB0cy5Nb2RpZmllckZsYWdzLlN0YXRpYykpIHtcbiAgICAgICAgICAgICAgZW1pdChgXFxuJHt0eXBlTmFtZX0uJHtwcm9wLm5hbWUuZ2V0VGV4dCgpfTtcXG5gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVtaXQoYFxcbiR7dHlwZU5hbWV9LnByb3RvdHlwZS4ke3Byb3AubmFtZS5nZXRUZXh0KCl9O1xcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE86IEZvciBub3cgcHJvcGVydHkgbmFtZXMgb3RoZXIgdGhhbiBJZGVudGlmaWVycyBhcmUgbm90IGhhbmRsZWQ7IGUuZy5cbiAgICAgICAgICAvLyAgICBpbnRlcmZhY2UgRm9vIHsgXCIxMjNiYXJcIjogbnVtYmVyIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZFNpZ25hdHVyZTpcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1ldGhvZERlY2xhcmF0aW9uOlxuICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IG1lbWJlciBhcyB0cy5NZXRob2REZWNsYXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBpc1N0YXRpYyA9IGhhc01vZGlmaWVyRmxhZyhtZXRob2QsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKTtcbiAgICAgICAgICBjb25zdCBtZXRob2RTaWduYXR1cmUgPSBgJHttZXRob2QubmFtZS5nZXRUZXh0KCl9JCQkJHtpc1N0YXRpYyA/ICdzdGF0aWMnIDogJ2luc3RhbmNlJ31gO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZHMuaGFzKG1ldGhvZFNpZ25hdHVyZSkpIHtcbiAgICAgICAgICAgIG1ldGhvZHMuZ2V0KG1ldGhvZFNpZ25hdHVyZSkhLnB1c2gobWV0aG9kKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kcy5zZXQobWV0aG9kU2lnbmF0dXJlLCBbbWV0aG9kXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgICAgY29udGludWU7ICAvLyBIYW5kbGVkIGFib3ZlLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIE1lbWJlcnMgY2FuIGluY2x1ZGUgdGhpbmdzIGxpa2UgaW5kZXggc2lnbmF0dXJlcywgZm9yIGUuZy5cbiAgICAgICAgICAvLyAgIGludGVyZmFjZSBGb28geyBba2V5OiBzdHJpbmddOiBudW1iZXI7IH1cbiAgICAgICAgICAvLyBGb3Igbm93LCBqdXN0IHNraXAgaXQuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgdGhlIG1lbWJlciB3YXNuJ3QgaGFuZGxlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudC5cbiAgICAgIGxldCBtZW1iZXJOYW1lID0gbmFtZXNwYWNlO1xuICAgICAgaWYgKG1lbWJlci5uYW1lKSB7XG4gICAgICAgIG1lbWJlck5hbWUgPSBtZW1iZXJOYW1lLmNvbmNhdChbbWVtYmVyLm5hbWUuZ2V0VGV4dCgpXSk7XG4gICAgICB9XG4gICAgICBlbWl0KGBcXG4vKiBUT0RPOiAke3RzLlN5bnRheEtpbmRbbWVtYmVyLmtpbmRdfTogJHttZW1iZXJOYW1lLmpvaW4oJy4nKX0gKi9cXG5gKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbWV0aG9kIGRlY2xhcmF0aW9ucy9zaWduYXR1cmVzIHNlcGFyYXRlbHksIHNpbmNlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIG92ZXJsb2Fkcy5cbiAgICBmb3IgKGNvbnN0IG1ldGhvZFZhcmlhbnRzIG9mIEFycmF5LmZyb20obWV0aG9kcy52YWx1ZXMoKSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0TWV0aG9kVmFyaWFudCA9IG1ldGhvZFZhcmlhbnRzWzBdO1xuICAgICAgbGV0IHBhcmFtZXRlck5hbWVzOiBzdHJpbmdbXTtcbiAgICAgIGlmIChtZXRob2RWYXJpYW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHBhcmFtZXRlck5hbWVzID0gZW1pdEZ1bmN0aW9uVHlwZShtZXRob2RWYXJpYW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbWV0ZXJOYW1lcyA9IGVtaXRGdW5jdGlvblR5cGUoW2ZpcnN0TWV0aG9kVmFyaWFudF0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWV0aG9kTmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZS5nZXRUZXh0KCldKTtcbiAgICAgIC8vIElmIHRoZSBtZXRob2QgaXMgc3RhdGljLCBkb24ndCBhZGQgdGhlIHByb3RvdHlwZS5cbiAgICAgIGlmICghaGFzTW9kaWZpZXJGbGFnKGZpcnN0TWV0aG9kVmFyaWFudCwgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpKSB7XG4gICAgICAgIG1ldGhvZE5hbWVzcGFjZS5wdXNoKCdwcm90b3R5cGUnKTtcbiAgICAgIH1cbiAgICAgIHdyaXRlRnVuY3Rpb24oZmlyc3RNZXRob2RWYXJpYW50Lm5hbWUsIHBhcmFtZXRlck5hbWVzLCBtZXRob2ROYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlRXhwb3J0RGVjbGFyYXRpb24oXG4gICAgICBleHBvcnREZWNsYXJhdGlvbjogdHMuRXhwb3J0RGVjbGFyYXRpb24sIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgaWYgKCFleHBvcnREZWNsYXJhdGlvbi5leHBvcnRDbGF1c2UpIHtcbiAgICAgIGVtaXQoYFxcbi8vIFRPRE8odHNpY2tsZSk6IGV4cG9ydCAqIGRlY2xhcmF0aW9uIGluICR7XG4gICAgICAgICAgZGVidWdMb2NhdGlvblN0cihleHBvcnREZWNsYXJhdGlvbiwgbmFtZXNwYWNlKX1cXG5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRzLmlzTmFtZXNwYWNlRXhwb3J0KGV4cG9ydERlY2xhcmF0aW9uLmV4cG9ydENsYXVzZSkpIHtcbiAgICAgIC8vIFRPRE8oIzExMzUpOiBTdXBwb3J0IGdlbmVyYXRpbmcgZXh0ZXJucyB1c2luZyB0aGlzIHN5bnRheC5cbiAgICAgIGVtaXQoYFxcbi8vIFRPRE8odHNpY2tsZSk6IGV4cG9ydCAqIGFzIGRlY2xhcmF0aW9uIGluICR7XG4gICAgICAgICAgZGVidWdMb2NhdGlvblN0cihleHBvcnREZWNsYXJhdGlvbiwgbmFtZXNwYWNlKX1cXG5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBleHBvcnRTcGVjaWZpZXIgb2YgZXhwb3J0RGVjbGFyYXRpb24uZXhwb3J0Q2xhdXNlLmVsZW1lbnRzKSB7XG4gICAgICAvLyBObyBuZWVkIHRvIGRvIGFueXRoaW5nIGZvciBwcm9wZXJ0aWVzIGV4cG9ydGVkIHVuZGVyIHRoZWlyIG9yaWdpbmFsIG5hbWUuXG4gICAgICBpZiAoIWV4cG9ydFNwZWNpZmllci5wcm9wZXJ0eU5hbWUpIGNvbnRpbnVlO1xuICAgICAgZW1pdCgnLyoqIEBjb25zdCAqL1xcbicpO1xuICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChcbiAgICAgICAgICBleHBvcnRTcGVjaWZpZXIubmFtZS50ZXh0LCBuYW1lc3BhY2UsXG4gICAgICAgICAgbmFtZXNwYWNlLmpvaW4oJy4nKSArICcuJyArIGV4cG9ydFNwZWNpZmllci5wcm9wZXJ0eU5hbWUudGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYWxpYXNlcyBmb3IgdGhlIHN5bWJvbHMgaW1wb3J0ZWQgaW4gdGhlIGdpdmVuIGRlY2xhcmF0aW9uLCBzbyB0aGF0IHRoZWlyIHR5cGVzIGdldFxuICAgKiBwcmludGVkIGFzIHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSwgYW5kIG5vdCBqdXN0IGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBsb2NhbCBpbXBvcnQgYWxpYXMuXG4gICAqXG4gICAqIHRzaWNrbGUgZ2VuZXJhdGVzIC5qcyBmaWxlcyB0aGF0IChhdCBtb3N0KSBjb250YWluIGEgYGdvb2cucHJvdmlkZWAsIGJ1dCBhcmUgbm90XG4gICAqIGBnb29nLm1vZHVsZWBzLiBUaGVzZSBmaWxlcyBjYW5ub3QgZXhwcmVzcyBhbiBhbGlhc2VkIGltcG9ydC4gSG93ZXZlciBDbG9zdXJlIENvbXBpbGVyIGFsbG93c1xuICAgKiByZWZlcmVuY2luZyB0eXBlcyB1c2luZyBmdWxseSBxdWFsaWZpZWQgbmFtZXMgaW4gc3VjaCBmaWxlcywgc28gdHNpY2tsZSBjYW4gcmVzb2x2ZSB0aGVcbiAgICogaW1wb3J0ZWQgbW9kdWxlIFVSSSBhbmQgcHJvZHVjZSBgcGF0aC50by5tb2R1bGUuU3ltYm9sYCBhcyBhbiBhbGlhcywgYW5kIHVzZSB0aGF0IHdoZW5cbiAgICogcmVmZXJlbmNpbmcgdGhlIHR5cGUuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRJbXBvcnRBbGlhc2VzKGRlY2w6IHRzLkltcG9ydERlY2xhcmF0aW9ufHRzLkltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKSB7XG4gICAgbGV0IG1vZHVsZVVyaTogc3RyaW5nO1xuICAgIGlmICh0cy5pc0ltcG9ydERlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICBtb2R1bGVVcmkgPSAoZGVjbC5tb2R1bGVTcGVjaWZpZXIgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICB9IGVsc2UgaWYgKHRzLmlzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoZGVjbC5tb2R1bGVSZWZlcmVuY2UpKSB7XG4gICAgICAvLyBpbXBvcnQgZm9vID0gcmVxdWlyZSgnLi9iYXInKTtcbiAgICAgIG1vZHVsZVVyaSA9IChkZWNsLm1vZHVsZVJlZmVyZW5jZS5leHByZXNzaW9uIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGltcG9ydCBmb28gPSBiYXIuYmF6LmJhbTtcbiAgICAgIC8vIGhhbmRsZWQgYXQgY2FsbCBzaXRlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0cy5pc0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKGRlY2wpKSB7XG4gICAgICAvLyBpbXBvcnQgZm9vID0gcmVxdWlyZSgnLi9iYXInKTtcbiAgICAgIGFkZEltcG9ydEFsaWFzKGRlY2wubmFtZSwgbW9kdWxlVXJpLCB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydCwgbGlrZSBcImltcG9ydCAnc29tZXBhdGgnO1wiIGRlY2xhcmVzIG5vIGxvY2FsIGFsaWFzZXMuXG4gICAgaWYgKCFkZWNsLmltcG9ydENsYXVzZSkgcmV0dXJuO1xuXG4gICAgaWYgKGRlY2wuaW1wb3J0Q2xhdXNlLm5hbWUpIHtcbiAgICAgIC8vIGltcG9ydCBuYW1lIGZyb20gLi4uIC0+IG1hcCB0byAuZGVmYXVsdCBvbiB0aGUgbW9kdWxlLm5hbWUuXG4gICAgICBhZGRJbXBvcnRBbGlhcyhkZWNsLmltcG9ydENsYXVzZS5uYW1lLCBtb2R1bGVVcmksICdkZWZhdWx0Jyk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWVkQmluZGluZ3MgPSBkZWNsLmltcG9ydENsYXVzZS5uYW1lZEJpbmRpbmdzO1xuICAgIGlmICghbmFtZWRCaW5kaW5ncykgcmV0dXJuO1xuXG4gICAgaWYgKHRzLmlzTmFtZXNwYWNlSW1wb3J0KG5hbWVkQmluZGluZ3MpKSB7XG4gICAgICAvLyBpbXBvcnQgKiBhcyBuYW1lIC0+IG1hcCBkaXJlY3RseSB0byB0aGUgbW9kdWxlLm5hbWUuXG4gICAgICBhZGRJbXBvcnRBbGlhcyhuYW1lZEJpbmRpbmdzLm5hbWUsIG1vZHVsZVVyaSwgdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBpZiAodHMuaXNOYW1lZEltcG9ydHMobmFtZWRCaW5kaW5ncykpIHtcbiAgICAgIC8vIGltcG9ydCB7QSBhcyBCfSwgbWFwIHRvIG1vZHVsZS5uYW1lLkFcbiAgICAgIGZvciAoY29uc3QgbmFtZWRCaW5kaW5nIG9mIG5hbWVkQmluZGluZ3MuZWxlbWVudHMpIHtcbiAgICAgICAgYWRkSW1wb3J0QWxpYXMobmFtZWRCaW5kaW5nLm5hbWUsIG1vZHVsZVVyaSwgbmFtZWRCaW5kaW5nLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGltcG9ydCBhbGlhcyBmb3IgdGhlIHN5bWJvbCBkZWZpbmVkIGF0IHRoZSBnaXZlbiBub2RlLiBDcmVhdGVzIGFuIGFsaWFzIG5hbWUgYmFzZWQgb25cbiAgICogdGhlIGdpdmVuIG1vZHVsZU5hbWUgYW5kIChvcHRpb25hbGx5KSB0aGUgbmFtZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEltcG9ydEFsaWFzKG5vZGU6IHRzLk5vZGUsIG1vZHVsZVVyaTogc3RyaW5nLCBuYW1lOiB0cy5JZGVudGlmaWVyfHN0cmluZ3x1bmRlZmluZWQpIHtcbiAgICBsZXQgc3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihub2RlKTtcbiAgICBpZiAoIXN5bWJvbCkge1xuICAgICAgcmVwb3J0RGlhZ25vc3RpYyhkaWFnbm9zdGljcywgbm9kZSwgYG5hbWVkIGltcG9ydCBoYXMgbm8gc3ltYm9sYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgc3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW1ib2wpO1xuICAgIH1cblxuICAgIGNvbnN0IGdvb2dOYW1lc3BhY2UgPSBleHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydChtb2R1bGVVcmkpO1xuICAgIGxldCBhbGlhc05hbWU6IHN0cmluZztcbiAgICBpZiAoZ29vZ05hbWVzcGFjZSkge1xuICAgICAgYWxpYXNOYW1lID0gZ29vZ05hbWVzcGFjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2hpbGUgdHlwZV90cmFuc2xhdG9yIGRvZXMgYWRkIHRoZSBtYW5nbGVkIHByZWZpeCBmb3IgYW1iaWVudCBkZWNsYXJhdGlvbnMsIGl0IG9ubHkgZG9lcyBzb1xuICAgICAgLy8gZm9yIG5vbi1hbGlhc2VkIChpLmUuIG5vdCBpbXBvcnRlZCkgc3ltYm9scy4gVGhhdCdzIGNvcnJlY3QgZm9yIGl0cyB1c2UgaW4gcmVndWxhciBtb2R1bGVzLFxuICAgICAgLy8gd2hpY2ggd2lsbCBoYXZlIGEgbG9jYWwgc3ltYm9sIGZvciB0aGUgaW1wb3J0ZWQgYW1iaWVudCBzeW1ib2wuIEhvd2V2ZXIgd2l0aGluIGFuIGV4dGVybnNcbiAgICAgIC8vIGZpbGUsIHRoZXJlIGFyZSBubyBpbXBvcnRzLCBzbyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgYWxpYXMgYWxyZWFkeSBjb250YWlucyB0aGUgY29ycmVjdFxuICAgICAgLy8gbW9kdWxlIG5hbWUsIHdoaWNoIG1lYW5zIHRoZSBtYW5nbGVkIG1vZHVsZSBuYW1lIGluIGNhc2Ugb2YgaW1wb3J0cyBzeW1ib2xzLlxuICAgICAgLy8gVGhpcyBvbmx5IGFwcGxpZXMgdG8gbm9uLUNsb3N1cmUgKCdnb29nOicpIGltcG9ydHMuXG4gICAgICBjb25zdCBpc0FtYmllbnRNb2R1bGVEZWNsYXJhdGlvbiA9XG4gICAgICAgICAgc3ltYm9sLmRlY2xhcmF0aW9ucyAmJiBzeW1ib2wuZGVjbGFyYXRpb25zLnNvbWUoZCA9PiBpc0FtYmllbnQoZCkpO1xuICAgICAgY29uc3QgZnVsbFVyaSA9IHJlc29sdmVNb2R1bGVOYW1lKGhvc3QsIHNvdXJjZUZpbGUuZmlsZU5hbWUsIG1vZHVsZVVyaSk7XG4gICAgICBpZiAoaXNBbWJpZW50TW9kdWxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgYWxpYXNOYW1lID0gbW9kdWxlTmFtZUFzSWRlbnRpZmllcihob3N0LCBmdWxsVXJpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWFzTmFtZSA9IGhvc3QucGF0aFRvTW9kdWxlTmFtZShcbiAgICAgICAgICAgIHNvdXJjZUZpbGUuZmlsZU5hbWUsIHJlc29sdmVNb2R1bGVOYW1lKGhvc3QsIHNvdXJjZUZpbGUuZmlsZU5hbWUsIGZ1bGxVcmkpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWxpYXNOYW1lICs9ICcuJyArIG5hbWU7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgYWxpYXNOYW1lICs9ICcuJyArIGdldElkZW50aWZpZXJUZXh0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG10dC5zeW1ib2xzVG9BbGlhc2VkTmFtZXMuc2V0KHN5bWJvbCwgYWxpYXNOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGNvbXBpbGVyIGVycm9yIHRoYXQgcmVmZXJlbmNlcyB0aGUgTm9kZSdzIGtpbmQuIFRoaXMgaXMgdXNlZnVsIGZvciB0aGUgXCJlbHNlXCJcbiAgICogYnJhbmNoIG9mIGNvZGUgdGhhdCBpcyBhdHRlbXB0aW5nIHRvIGhhbmRsZSBhbGwgcG9zc2libGUgaW5wdXQgTm9kZSB0eXBlcywgdG8gZW5zdXJlIGFsbCBjYXNlc1xuICAgKiBjb3ZlcmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gZXJyb3JVbmltcGxlbWVudGVkS2luZChub2RlOiB0cy5Ob2RlLCB3aGVyZTogc3RyaW5nKSB7XG4gICAgcmVwb3J0RGlhZ25vc3RpYyhkaWFnbm9zdGljcywgbm9kZSwgYCR7dHMuU3ludGF4S2luZFtub2RlLmtpbmRdfSBub3QgaW1wbGVtZW50ZWQgaW4gJHt3aGVyZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXROYW1lc3BhY2VGb3JMb2NhbERlY2xhcmF0aW9uIHJldHVybnMgdGhlIG5hbWVzcGFjZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgZ2l2ZW5cbiAgICogZGVjbGFyYXRpb24sIGRlY2lkaW5nIHdoZXRoZXIgdG8gbmFtZXNwYWNlIHRoZSBzeW1ib2wgdG8gdGhlIGZpbGUgb3Igd2hldGhlciB0byBjcmVhdGUgYVxuICAgKiBnbG9iYWwgbmFtZS5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIGNvdmVycyB0aGVzZSBjYXNlczpcbiAgICogMSkgYSBkZWNsYXJhdGlvbiBpbiBhIC5kLnRzXG4gICAqIDFhKSB3aGVyZSB0aGUgLmQudHMgaXMgYW4gZXh0ZXJuYWwgbW9kdWxlICAgICAtLT4gbmFtZXNwYWNlXG4gICAqIDFiKSB3aGVyZSB0aGUgLmQudHMgaXMgbm90IGFuIGV4dGVybmFsIG1vZHVsZSAtLT4gZ2xvYmFsXG4gICAqIDIpIGEgZGVjbGFyYXRpb24gaW4gYSAudHMgZmlsZSAoYWxsIGFyZSB0cmVhdGVkIGFzIG1vZHVsZXMpXG4gICAqIDJhKSB0aGF0IGlzIGV4cG9ydGVkICAgICAgICAgICAgICAgICAgICAgICAgICAtLT4gbmFtZXNwYWNlXG4gICAqIDJiKSB0aGF0IGlzIHVuZXhwb3J0ZWQgICAgICAgICAgICAgICAgICAgICAgICAtLT4gZ2xvYmFsXG4gICAqXG4gICAqIEZvciAxKSwgYWxsIHN5bWJvbHMgaW4gLmQudHMgc2hvdWxkIGdlbmVyYWxseSBiZSBuYW1lc3BhY2VkIHRvIHRoZSBmaWxlIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gICAqIEhvd2V2ZXIgLmQudHMgZmlsZXMgdGhhdCBhcmUgbm90IGV4dGVybmFsIG1vZHVsZXMgZG8gZGVjbGFyZSBnbG9iYWwgbmFtZXMgKDFiKS5cbiAgICpcbiAgICogRm9yIDIpLCBhbWJpZW50IGRlY2xhcmF0aW9ucyBpbiAudHMgZmlsZXMgbXVzdCBiZSBuYW1lc3BhY2VkLCBmb3IgdGhlIHNhbWUgY29sbGlzaW9uIHJlYXNvbnMuXG4gICAqIFRoZSBleGNlcHRpb24gaXMgMmIpLCB3aGVyZSBpbiBUeXBlU2NyaXB0LCBhbiB1bmV4cG9ydGVkIGxvY2FsIFwiZGVjbGFyZSBjb25zdCB4OiBzdHJpbmc7XCJcbiAgICogY3JlYXRlcyBhIHN5bWJvbCB0aGF0LCB3aGVuIHVzZWQgbG9jYWxseSwgaXMgZW1pdHRlZCBhcyBqdXN0IFwieFwiLiBUaGF0IGlzLCBpdCBiZWhhdmVzXG4gICAqIGxpa2UgYSB2YXJpYWJsZSBkZWNsYXJlZCBpbiBhICdkZWNsYXJlIGdsb2JhbCcgYmxvY2suIENsb3N1cmUgQ29tcGlsZXIgd291bGQgZmFpbCB0aGUgYnVpbGQgaWZcbiAgICogdGhlcmUgaXMgbm8gZGVjbGFyYXRpb24gZm9yIFwieFwiLCBzbyB0c2lja2xlIG11c3QgZ2VuZXJhdGUgYSBnbG9iYWwgZXh0ZXJuYWwgc3ltYm9sLCBpLmUuXG4gICAqIHdpdGhvdXQgdGhlIG5hbWVzcGFjZSB3cmFwcGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TmFtZXNwYWNlRm9yVG9wTGV2ZWxEZWNsYXJhdGlvbihcbiAgICAgIGRlY2xhcmF0aW9uOiB0cy5EZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIC8vIE9ubHkgdXNlIHJvb3ROYW1lc3BhY2UgZm9yIHRvcCBsZXZlbCBzeW1ib2xzLCBhbnkgb3RoZXIgbmFtZXNwYWNpbmcgKGdsb2JhbCBuYW1lcywgbmVzdGVkXG4gICAgLy8gbmFtZXNwYWNlcykgaXMgYWx3YXlzIGtlcHQuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDApIHJldHVybiBuYW1lc3BhY2U7XG4gICAgLy8gQWxsIG5hbWVzIGluIGEgbW9kdWxlIChleHRlcm5hbCkgLmQudHMgZmlsZSBjYW4gb25seSBiZSBhY2Nlc3NlZCBsb2NhbGx5LCBzbyB0aGV5IGFsd2F5cyBnZXRcbiAgICAvLyBuYW1lc3BhY2UgcHJlZml4ZWQuXG4gICAgaWYgKGlzRHRzICYmIGlzRXh0ZXJuYWxNb2R1bGUpIHJldHVybiBbcm9vdE5hbWVzcGFjZV07XG4gICAgLy8gU2FtZSBmb3IgZXhwb3J0ZWQgZGVjbGFyYXRpb25zIGluIHJlZ3VsYXIgLnRzIGZpbGVzLlxuICAgIGlmIChoYXNNb2RpZmllckZsYWcoZGVjbGFyYXRpb24sIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0KSkgcmV0dXJuIFtyb290TmFtZXNwYWNlXTtcbiAgICAvLyBCdXQgbG9jYWwgZGVjbGFyYXRpb25zIGluIC50cyBmaWxlcyBvciAuZC50cyBmaWxlcyAoMWIsIDJiKSBhcmUgZ2xvYmFsLCB0b28uXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBsb2NhdGlvbjogZWl0aGVyIHRoZSBuYW1lc3BhY2UsIG9yLCBpZiBlbXB0eSwgdGhlXG4gICAqIGN1cnJlbnQgc291cmNlIGZpbGUgbmFtZS4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgZW1pdCBmb3Igd2FybmluZ3MsIHNvIHRoYXRcbiAgICogdXNlcnMgY2FuIG1vcmUgZWFzaWx5IGZpbmQgd2hlcmUgYSBwcm9ibGVtYXRpYyBkZWZpbml0aW9uIGlzIGZyb20uXG4gICAqXG4gICAqIFRoZSBjb2RlIGJlbG93IGRvZXMgbm90IHVzZSBkaWFnbm9zdGljcyB0byBhdm9pZCBicmVha2luZyB0aGUgYnVpbGQgZm9yIGhhcm1sZXNzIHVuaGFuZGxlZFxuICAgKiBjYXNlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGRlYnVnTG9jYXRpb25TdHIobm9kZTogdHMuTm9kZSwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICAvLyBVc2UgYSByZWdleCB0byBncmFiIHRoZSBmaWxlbmFtZSB3aXRob3V0IGEgcGF0aCwgdG8gbWFrZSB0aGUgb3V0cHV0IHN0YWJsZVxuICAgIC8vIHVuZGVyIGJhemVsIHdoZXJlIHNhbmRib3hlcyB1c2UgZGlmZmVyZW50IHBhdGhzLlxuICAgIHJldHVybiBuYW1lc3BhY2Uuam9pbignLicpIHx8IG5vZGUuZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lLnJlcGxhY2UoLy4qWy9cXFxcXS8sICcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2l0b3Iobm9kZTogdHMuTm9kZSwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICBpZiAobm9kZS5wYXJlbnQgPT09IHNvdXJjZUZpbGUpIHtcbiAgICAgIG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZUZvclRvcExldmVsRGVjbGFyYXRpb24obm9kZSBhcyB0cy5EZWNsYXJhdGlvblN0YXRlbWVudCwgbmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5vZGUua2luZCkge1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk1vZHVsZURlY2xhcmF0aW9uOlxuICAgICAgICBjb25zdCBkZWNsID0gbm9kZSBhcyB0cy5Nb2R1bGVEZWNsYXJhdGlvbjtcbiAgICAgICAgc3dpdGNoIChkZWNsLm5hbWUua2luZCkge1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JZGVudGlmaWVyOlxuICAgICAgICAgICAgaWYgKGRlY2wuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuR2xvYmFsQXVnbWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIEUuZy4gXCJkZWNsYXJlIGdsb2JhbCB7IC4uLiB9XCIuICBSZXNldCB0byB0aGUgb3V0ZXIgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEUuZy4gXCJkZWNsYXJlIG5hbWVzcGFjZSBmb28ge1wiXG4gICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgIGlmIChpc0ZpcnN0VmFsdWVEZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgICAgICAgICAgIGVtaXQoJy8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICAgICAgICAgICAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KG5hbWUsIG5hbWVzcGFjZSwgJ3t9Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNsLmJvZHkpIHZpc2l0b3IoZGVjbC5ib2R5LCBuYW1lc3BhY2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBtb2R1bGUgJ2Zvbycge1wiIChub3RlIHRoZSBxdW90ZXMpLlxuICAgICAgICAgICAgLy8gV2Ugc3RpbGwgd2FudCB0byBlbWl0IGV4dGVybnMgZm9yIHRoaXMgbW9kdWxlLCBidXQgQ2xvc3VyZSBkb2Vzbid0IHByb3ZpZGUgYVxuICAgICAgICAgICAgLy8gbWVjaGFuaXNtIGZvciBtb2R1bGUtc2NvcGVkIGV4dGVybnMuIEluc3RlYWQsIHdlIGVtaXQgaW4gYSBtYW5nbGVkIG5hbWVzcGFjZS5cbiAgICAgICAgICAgIC8vIFRoZSBtYW5nbGVkIG5hbWVzcGFjZSAoYWZ0ZXIgcmVzb2x2aW5nIGZpbGVzKSBtYXRjaGVzIHRoZSBlbWl0IGZvciBhbiBvcmlnaW5hbCBtb2R1bGVcbiAgICAgICAgICAgIC8vIGZpbGUsIHNvIGVmZmVjdGl2ZWx5IHRoaXMgYXVnbWVudHMgYW55IGV4aXN0aW5nIG1vZHVsZS5cblxuICAgICAgICAgICAgY29uc3QgaW1wb3J0TmFtZSA9IChkZWNsLm5hbWUgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkTW9kdWxlTmFtZSA9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZU1vZHVsZU5hbWUoe21vZHVsZVJlc29sdXRpb25Ib3N0LCBvcHRpb25zfSwgc291cmNlRmlsZS5maWxlTmFtZSwgaW1wb3J0TmFtZSk7XG4gICAgICAgICAgICBjb25zdCBtYW5nbGVkID0gbW9kdWxlTmFtZUFzSWRlbnRpZmllcihob3N0LCBpbXBvcnRlZE1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgZW1pdChgLy8gRGVyaXZlZCBmcm9tOiBkZWNsYXJlIG1vZHVsZSBcIiR7aW1wb3J0TmFtZX1cIlxcbmApO1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gW21hbmdsZWRdO1xuXG4gICAgICAgICAgICAvLyBEZWNsYXJlIFwibWFuZ2xlZCRuYW1lXCIgaWYgaXQncyBub3QgZGVjbGFyZWQgYWxyZWFkeSBlbHNld2hlcmUuXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFZhbHVlRGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgICAgICAgICAgZW1pdCgnLyoqIEBjb25zdCAqL1xcbicpO1xuICAgICAgICAgICAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KG1hbmdsZWQsIFtdLCAne30nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY2xhcmUgdGhlIGNvbnRlbnRzIGluc2lkZSB0aGUgXCJtYW5nbGVkJG5hbWVcIi5cbiAgICAgICAgICAgIGlmIChkZWNsLmJvZHkpIHZpc2l0b3IoZGVjbC5ib2R5LCBbbWFuZ2xlZF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yVW5pbXBsZW1lbnRlZEtpbmQoZGVjbC5uYW1lLCAnZXh0ZXJucyBnZW5lcmF0aW9uIG9mIG5hbWVzcGFjZScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuTW9kdWxlQmxvY2s6XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZSBhcyB0cy5Nb2R1bGVCbG9jaztcbiAgICAgICAgZm9yIChjb25zdCBzdG10IG9mIGJsb2NrLnN0YXRlbWVudHMpIHtcbiAgICAgICAgICB2aXNpdG9yKHN0bXQsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW1wb3J0RXF1YWxzRGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGltcG9ydEVxdWFscyA9IG5vZGUgYXMgdHMuSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG4gICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGdldElkZW50aWZpZXJUZXh0KGltcG9ydEVxdWFscy5uYW1lKTtcbiAgICAgICAgaWYgKGltcG9ydEVxdWFscy5tb2R1bGVSZWZlcmVuY2Uua2luZCA9PT0gdHMuU3ludGF4S2luZC5FeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSkge1xuICAgICAgICAgIGFkZEltcG9ydEFsaWFzZXMoaW1wb3J0RXF1YWxzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxbiA9IHF1YWxpZmllZE5hbWVUb01hbmdsZWRJZGVudGlmaWVyKGltcG9ydEVxdWFscy5tb2R1bGVSZWZlcmVuY2UpO1xuICAgICAgICAvLyBAY29uc3Qgc28gdGhhdCBDbG9zdXJlIENvbXBpbGVyIHVuZGVyc3RhbmRzIHRoaXMgaXMgYW4gYWxpYXMuXG4gICAgICAgIGVtaXQoJy8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChsb2NhbE5hbWUsIG5hbWVzcGFjZSwgcW4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5DbGFzc0RlY2xhcmF0aW9uOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uOlxuICAgICAgICB3cml0ZVR5cGUobm9kZSBhcyB0cy5JbnRlcmZhY2VEZWNsYXJhdGlvbiB8IHRzLkNsYXNzRGVjbGFyYXRpb24sIG5hbWVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgIGNvbnN0IGZuRGVjbCA9IG5vZGUgYXMgdHMuRnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZuRGVjbC5uYW1lO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICByZXBvcnREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBmbkRlY2wsICdhbm9ueW1vdXMgZnVuY3Rpb24gaW4gZXh0ZXJucycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdhdGhlciB1cCBhbGwgb3ZlcmxvYWRzIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgIGNvbnN0IHN5bSA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obmFtZSkhO1xuICAgICAgICBjb25zdCBkZWNscyA9IHN5bS5kZWNsYXJhdGlvbnMhLmZpbHRlcih0cy5pc0Z1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgICAgICAvLyBPbmx5IGVtaXQgdGhlIGZpcnN0IGRlY2xhcmF0aW9uIG9mIGVhY2ggb3ZlcmxvYWRlZCBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGZuRGVjbCAhPT0gZGVjbHNbMF0pIGJyZWFrO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBlbWl0RnVuY3Rpb25UeXBlKGRlY2xzKTtcbiAgICAgICAgd3JpdGVGdW5jdGlvbihuYW1lLCBwYXJhbXMsIG5hbWVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlU3RhdGVtZW50OlxuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgKG5vZGUgYXMgdHMuVmFyaWFibGVTdGF0ZW1lbnQpLmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICB3cml0ZVZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbCwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5FbnVtRGVjbGFyYXRpb246XG4gICAgICAgIHdyaXRlRW51bShub2RlIGFzIHRzLkVudW1EZWNsYXJhdGlvbiwgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVHlwZUFsaWFzRGVjbGFyYXRpb246XG4gICAgICAgIHdyaXRlVHlwZUFsaWFzKG5vZGUgYXMgdHMuVHlwZUFsaWFzRGVjbGFyYXRpb24sIG5hbWVzcGFjZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkltcG9ydERlY2xhcmF0aW9uOlxuICAgICAgICBhZGRJbXBvcnRBbGlhc2VzKG5vZGUgYXMgdHMuSW1wb3J0RGVjbGFyYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5OYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjpcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5FeHBvcnRBc3NpZ25tZW50OlxuICAgICAgICAvLyBIYW5kbGVkIG9uIHRoZSBmaWxlIGxldmVsLlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5FeHBvcnREZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgZXhwb3J0RGVjbGFyYXRpb24gPSBub2RlIGFzIHRzLkV4cG9ydERlY2xhcmF0aW9uO1xuICAgICAgICB3cml0ZUV4cG9ydERlY2xhcmF0aW9uKGV4cG9ydERlY2xhcmF0aW9uLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVtaXQoYFxcbi8vIFRPRE8odHNpY2tsZSk6ICR7dHMuU3ludGF4S2luZFtub2RlLmtpbmRdfSBpbiAke1xuICAgICAgICAgICAgZGVidWdMb2NhdGlvblN0cihub2RlLCBuYW1lc3BhY2UpfVxcbmApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbiJdfQ==