/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/type_translator", ["require", "exports", "typescript", "tsickle/src/annotator_host", "tsickle/src/path", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBlacklisted = exports.TypeTranslator = exports.symbolToDebugString = exports.typeToDebugString = exports.typeValueConflictHandled = exports.isBuiltinLibDTS = exports.isValidClosurePropertyName = void 0;
    const ts = require("typescript");
    const annotator_host_1 = require("tsickle/src/annotator_host");
    const path = require("tsickle/src/path");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    /**
     * TypeScript allows you to write identifiers quoted, like:
     *   interface Foo {
     *     'bar': string;
     *     'complex name': string;
     *   }
     *   Foo.bar;  // ok
     *   Foo['bar']  // ok
     *   Foo['complex name']  // ok
     *
     * In Closure-land, we want identify that the legal name 'bar' can become an
     * ordinary field, but we need to skip strings like 'complex name'.
     */
    function isValidClosurePropertyName(name) {
        // In local experimentation, it appears that reserved words like 'var' and
        // 'if' are legal JS and still accepted by Closure.
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
    }
    exports.isValidClosurePropertyName = isValidClosurePropertyName;
    /**
     * Determines if fileName refers to a builtin lib.d.ts file.
     * This is a terrible hack but it mirrors a similar thing done in Clutz.
     */
    function isBuiltinLibDTS(fileName) {
        return fileName.match(/\blib\.(?:[^/]+\.)?d\.ts$/) != null;
    }
    exports.isBuiltinLibDTS = isBuiltinLibDTS;
    /**
     * Returns true if the source file is generated by Clutz, i.e. has the magic
     * Clutz header.
     */
    function isClutzDts(sourceFile) {
        return sourceFile.text.startsWith('//!! generated by clutz.');
    }
    /**
     * typeValueConflictHandled returns true for symbols whose type/value conflict is handled outside of
     * tsickle.
     *
     * This covers two cases:
     *
     * - symbols provided by Clutz. Given that Closure has a merged type/value namespace, apparent
     *   type/value conflicts on the TypeScript level are actually fine.
     * - builtin lib*.d.ts symbols, such as "Array", which are considered Closure-compatible. Note that
     *   we don't actually enforce that the types are actually compatible, but mostly just hope that
     *   they are due to being derived from the same HTML specs.
     */
    function typeValueConflictHandled(symbol) {
        // TODO(#1072): if the symbol comes from a tsickle-transpiled file, either .ts or .d.ts with
        // externs generation? then maybe we can emit it with name mangling.
        return symbol.declarations != null &&
            symbol.declarations.some(n => isBuiltinLibDTS(n.getSourceFile().fileName) || isClutzDts(n.getSourceFile()));
    }
    exports.typeValueConflictHandled = typeValueConflictHandled;
    function typeToDebugString(type) {
        let debugString = `flags:0x${type.flags.toString(16)}`;
        if (type.aliasSymbol) {
            debugString += ` alias:${symbolToDebugString(type.aliasSymbol)}`;
        }
        if (type.aliasTypeArguments) {
            debugString += ` aliasArgs:<${type.aliasTypeArguments.map(typeToDebugString).join(',')}>`;
        }
        // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
        const basicTypes = [
            ts.TypeFlags.Any, ts.TypeFlags.String, ts.TypeFlags.Number,
            ts.TypeFlags.Boolean, ts.TypeFlags.Enum, ts.TypeFlags.StringLiteral,
            ts.TypeFlags.NumberLiteral, ts.TypeFlags.BooleanLiteral, ts.TypeFlags.EnumLiteral,
            ts.TypeFlags.BigIntLiteral, ts.TypeFlags.ESSymbol, ts.TypeFlags.UniqueESSymbol,
            ts.TypeFlags.Void, ts.TypeFlags.Undefined, ts.TypeFlags.Null,
            ts.TypeFlags.Never, ts.TypeFlags.TypeParameter, ts.TypeFlags.Object,
            ts.TypeFlags.Union, ts.TypeFlags.Intersection, ts.TypeFlags.Index,
            ts.TypeFlags.IndexedAccess, ts.TypeFlags.Conditional, ts.TypeFlags.Substitution,
        ];
        for (const flag of basicTypes) {
            if ((type.flags & flag) !== 0) {
                debugString += ` ${ts.TypeFlags[flag]}`;
            }
        }
        if (type.flags === ts.TypeFlags.Object) {
            const objType = type;
            debugString += ` objectFlags:0x${objType.objectFlags}`;
            // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
            const objectFlags = [
                ts.ObjectFlags.Class,
                ts.ObjectFlags.Interface,
                ts.ObjectFlags.Reference,
                ts.ObjectFlags.Tuple,
                ts.ObjectFlags.Anonymous,
                ts.ObjectFlags.Mapped,
                ts.ObjectFlags.Instantiated,
                ts.ObjectFlags.ObjectLiteral,
                ts.ObjectFlags.EvolvingArray,
                ts.ObjectFlags.ObjectLiteralPatternWithComputedProperties,
            ];
            for (const flag of objectFlags) {
                if ((objType.objectFlags & flag) !== 0) {
                    debugString += ` object:${ts.ObjectFlags[flag]}`;
                }
            }
        }
        if (type.symbol && type.symbol.name !== '__type') {
            debugString += ` symbol.name:${JSON.stringify(type.symbol.name)}`;
        }
        if (type.pattern) {
            debugString += ` destructuring:true`;
        }
        return `{type ${debugString}}`;
    }
    exports.typeToDebugString = typeToDebugString;
    function symbolToDebugString(sym) {
        let debugString = `${JSON.stringify(sym.name)} flags:0x${sym.flags.toString(16)}`;
        // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
        const symbolFlags = [
            ts.SymbolFlags.FunctionScopedVariable,
            ts.SymbolFlags.BlockScopedVariable,
            ts.SymbolFlags.Property,
            ts.SymbolFlags.EnumMember,
            ts.SymbolFlags.Function,
            ts.SymbolFlags.Class,
            ts.SymbolFlags.Interface,
            ts.SymbolFlags.ConstEnum,
            ts.SymbolFlags.RegularEnum,
            ts.SymbolFlags.ValueModule,
            ts.SymbolFlags.NamespaceModule,
            ts.SymbolFlags.TypeLiteral,
            ts.SymbolFlags.ObjectLiteral,
            ts.SymbolFlags.Method,
            ts.SymbolFlags.Constructor,
            ts.SymbolFlags.GetAccessor,
            ts.SymbolFlags.SetAccessor,
            ts.SymbolFlags.Signature,
            ts.SymbolFlags.TypeParameter,
            ts.SymbolFlags.TypeAlias,
            ts.SymbolFlags.ExportValue,
            ts.SymbolFlags.Alias,
            ts.SymbolFlags.Prototype,
            ts.SymbolFlags.ExportStar,
            ts.SymbolFlags.Optional,
            ts.SymbolFlags.Transient,
        ];
        for (const flag of symbolFlags) {
            if ((sym.flags & flag) !== 0) {
                debugString += ` ${ts.SymbolFlags[flag]}`;
            }
        }
        return debugString;
    }
    exports.symbolToDebugString = symbolToDebugString;
    /**
     * Searches for an ambient module declaration in the ancestors of declarations, depth first, and
     * returns the first or null if none found.
     */
    function getContainingAmbientModuleDeclaration(declarations) {
        for (const declaration of declarations) {
            let parent = declaration.parent;
            while (parent) {
                if (ts.isModuleDeclaration(parent) && ts.isStringLiteral(parent.name)) {
                    return parent;
                }
                parent = parent.parent;
            }
        }
        return null;
    }
    /** Returns true if any of declarations is a top level declaration in an external module. */
    function isTopLevelExternal(declarations) {
        for (const declaration of declarations) {
            if (declaration.parent === undefined)
                continue;
            if (ts.isSourceFile(declaration.parent) && ts.isExternalModule(declaration.parent))
                return true;
        }
        return false;
    }
    /**
     * Returns true if a and b are (or were originally before transformation) nodes of the same source
     * file.
     */
    function isDeclaredInSameFile(a, b) {
        return ts.getOriginalNode(a).getSourceFile() === ts.getOriginalNode(b).getSourceFile();
    }
    /**
     * TypeTranslator translates TypeScript types to Closure types. It keeps state per type, so each
     * translation operation has to create a new instance.
     */
    class TypeTranslator {
        /**
         * @param node is the source AST ts.Node the type comes from.  This is used
         *     in some cases (e.g. anonymous types) for looking up field names.
         * @param pathBlackList is a set of paths that should never get typed;
         *     any reference to symbols defined in these paths should by typed
         *     as {?}.
         * @param symbolsToAliasedNames a mapping from symbols (`Foo`) to a name in scope they should be
         *     emitted as (e.g. `tsickle_reqType_1.Foo`). Can be augmented during type translation, e.g.
         *     to blacklist a symbol.
         */
        constructor(host, typeChecker, node, pathBlackList, symbolsToAliasedNames, symbolToNameCache, ensureSymbolDeclared = () => { }) {
            this.host = host;
            this.typeChecker = typeChecker;
            this.node = node;
            this.pathBlackList = pathBlackList;
            this.symbolsToAliasedNames = symbolsToAliasedNames;
            this.symbolToNameCache = symbolToNameCache;
            this.ensureSymbolDeclared = ensureSymbolDeclared;
            /**
             * A list of type literals we've encountered while emitting; used to avoid getting stuck in
             * recursive types.
             */
            this.seenAnonymousTypes = new Set();
            /**
             * Whether to write types suitable for an #externs file. Externs types must not refer to
             * non-externs types (i.e. non ambient types) and need to use fully qualified names.
             */
            this.isForExterns = false;
            // Normalize paths to not break checks on Windows.
            this.pathBlackList =
                new Set(Array.from(this.pathBlackList.values()).map(p => path.normalize(p)));
        }
        /**
         * Converts a ts.Symbol to a string, applying aliases and ensuring symbols are imported.
         * @return a string representation of the symbol as a valid Closure type name, or `undefined` if
         *     the type cannot be expressed (e.g. for anonymous types).
         */
        symbolToString(sym) {
            // symbolToEntityName can be relatively expensive (40 ms calls with symbols in large namespaces
            // with many declarations, i.e. Clutz). symbolToString is idempotent per symbol and file, thus
            // we cache the entire operation to avoid the hit.
            const cachedName = this.symbolToNameCache.get(sym);
            if (cachedName)
                return cachedName;
            // TypeScript resolves e.g. union types to their members, which can include symbols not declared
            // in the current scope. Ensure that all symbols found this way are actually declared.
            // This must happen before the alias check below, it might introduce a new alias for the symbol.
            if (!this.isForExterns && (sym.flags & ts.SymbolFlags.TypeParameter) === 0) {
                this.ensureSymbolDeclared(sym);
            }
            const name = this.typeChecker.symbolToEntityName(sym, ts.SymbolFlags.Type, this.node, ts.NodeBuilderFlags.UseFullyQualifiedType);
            // name might be undefined, e.g. for anonymous classes.
            if (!name)
                return undefined;
            let str = '';
            /** Recursively visits components of entity name and writes them to `str` above. */
            const writeEntityWithSymbols = (name) => {
                let identifier;
                if (ts.isQualifiedName(name)) {
                    writeEntityWithSymbols(name.left);
                    str += '.';
                    identifier = name.right;
                }
                else {
                    identifier = name;
                }
                let symbol = identifier.symbol;
                // When writing a symbol, check if there is an alias for it in the current scope that should
                // take precedence, e.g. from a goog.requireType.
                if (symbol.flags & ts.SymbolFlags.Alias) {
                    symbol = this.typeChecker.getAliasedSymbol(symbol);
                }
                const alias = this.symbolsToAliasedNames.get(symbol);
                if (alias) {
                    // If so, discard the entire current text and only use the alias - otherwise if a symbol has
                    // a local alias but appears in a dotted type path (e.g. when it's imported using import *
                    // as foo), str would contain both the prefx *and* the full alias (foo.alias.name).
                    str = alias;
                    return;
                }
                let text = transformer_util_1.getIdentifierText(identifier);
                if (str.length === 0) {
                    const mangledPrefix = this.maybeGetMangledNamePrefix(symbol);
                    text = mangledPrefix + text;
                }
                str += text;
            };
            writeEntityWithSymbols(name);
            str = this.stripClutzNamespace(str);
            this.symbolToNameCache.set(sym, str);
            return str;
        }
        /**
         * Returns the mangled name prefix for symbol, or an empty string if not applicable.
         *
         * Type names are emitted with a mangled prefix if they are top level symbols declared in an
         * external module (.d.ts or .ts), and are ambient declarations ("declare ..."). This is because
         * their declarations get moved to externs files (to make external names visible to Closure and
         * prevent renaming), which only use global names. This means the names must be mangled to prevent
         * collisions and allow referencing them uniquely.
         *
         * This method also handles the special case of symbols declared in an ambient external module
         * context.
         *
         * Symbols declared in a global block, e.g. "declare global { type X; }", are handled implicitly:
         * when referenced, they are written as just "X", which is not a top level declaration, so the
         * code below ignores them.
         */
        maybeGetMangledNamePrefix(symbol) {
            if (!symbol.declarations)
                return '';
            const declarations = symbol.declarations;
            let ambientModuleDeclaration = null;
            // If the symbol is neither a top level declaration in an external module nor in an ambient
            // block, tsickle should not emit a prefix: it's either not an external symbol, or it's an
            // external symbol nested in a module, so it will need to be qualified, and the mangling prefix
            // goes on the qualifier.
            if (!isTopLevelExternal(declarations)) {
                ambientModuleDeclaration = getContainingAmbientModuleDeclaration(declarations);
                if (!ambientModuleDeclaration)
                    return '';
            }
            // At this point, the declaration is from an external module (possibly ambient).
            // These declarations must be prefixed if either:
            // (a) tsickle is emitting an externs file, so all symbols are qualified within it
            // (b) or the declaration must be an exported ambient declaration from the local file.
            // Ambient external declarations from other files are imported, so there's a local alias for the
            // module and no mangling is needed.
            if (!this.isForExterns &&
                !declarations.every(d => isDeclaredInSameFile(this.node, d) && transformer_util_1.isAmbient(d) &&
                    transformer_util_1.hasModifierFlag(d, ts.ModifierFlags.Export))) {
                return '';
            }
            // If from an ambient declaration, use and resolve the name from that. Otherwise, use the file
            // name from the (arbitrary) first declaration to mangle.
            const fileName = ambientModuleDeclaration ?
                ambientModuleDeclaration.name.text :
                ts.getOriginalNode(declarations[0]).getSourceFile().fileName;
            const mangled = annotator_host_1.moduleNameAsIdentifier(this.host, fileName);
            return mangled + '.';
        }
        // Clutz (https://github.com/angular/clutz) emits global type symbols hidden in a special
        // ಠ_ಠ.clutz namespace. While most code seen by Tsickle will only ever see local aliases, Clutz
        // symbols can be written by users directly in code, and they can appear by dereferencing
        // TypeAliases. The code below simply strips the prefix, the remaining type name then matches
        // Closure's type.
        stripClutzNamespace(name) {
            if (name.startsWith('ಠ_ಠ.clutz.'))
                return name.substring('ಠ_ಠ.clutz.'.length);
            return name;
        }
        translate(type) {
            // NOTE: Though type.flags has the name "flags", it usually can only be one
            // of the enum options at a time (except for unions of literal types, e.g. unions of boolean
            // values, string values, enum values). This switch handles all the cases in the ts.TypeFlags
            // enum in the order they occur.
            // NOTE: Some TypeFlags are marked "internal" in the d.ts but still show up in the value of
            // type.flags. This mask limits the flag checks to the ones in the public API. "lastFlag" here
            // is the last flag handled in this switch statement, and should be kept in sync with
            // typescript.d.ts.
            // NonPrimitive occurs on its own on the lower case "object" type. Special case to "!Object".
            if (type.flags === ts.TypeFlags.NonPrimitive)
                return '!Object';
            // Avoid infinite loops on recursive type literals.
            // It would be nice to just emit the name of the recursive type here (in type.aliasSymbol
            // below), but Closure Compiler does not allow recursive type definitions.
            if (this.seenAnonymousTypes.has(type))
                return '?';
            let isAmbient = false;
            let isInNamespace = false;
            let isModule = false;
            if (type.symbol) {
                for (const decl of type.symbol.declarations || []) {
                    if (ts.isExternalModule(decl.getSourceFile()))
                        isModule = true;
                    if (decl.getSourceFile().isDeclarationFile)
                        isAmbient = true;
                    let current = decl;
                    while (current) {
                        if (ts.getCombinedModifierFlags(current) & ts.ModifierFlags.Ambient)
                            isAmbient = true;
                        if (current.kind === ts.SyntaxKind.ModuleDeclaration)
                            isInNamespace = true;
                        current = current.parent;
                    }
                }
            }
            // tsickle cannot generate types for non-ambient namespaces nor any symbols contained in them.
            if (isInNamespace && !isAmbient)
                return '?';
            // Types in externs cannot reference types from external modules.
            // However ambient types in modules get moved to externs, too, so type references work and we
            // can emit a precise type.
            if (this.isForExterns && isModule && !isAmbient)
                return '?';
            const lastFlag = ts.TypeFlags.Substitution;
            const mask = (lastFlag << 1) - 1;
            switch (type.flags & mask) {
                case ts.TypeFlags.Any:
                    return '?';
                case ts.TypeFlags.Unknown:
                    return '*';
                case ts.TypeFlags.String:
                case ts.TypeFlags.StringLiteral:
                    return 'string';
                case ts.TypeFlags.Number:
                case ts.TypeFlags.NumberLiteral:
                    return 'number';
                case ts.TypeFlags.Boolean:
                case ts.TypeFlags.BooleanLiteral:
                    // See the note in translateUnion about booleans.
                    return 'boolean';
                case ts.TypeFlags.Enum:
                    if (!type.symbol) {
                        this.warn(`EnumType without a symbol`);
                        return '?';
                    }
                    return this.symbolToString(type.symbol) || '?';
                case ts.TypeFlags.ESSymbol:
                case ts.TypeFlags.UniqueESSymbol:
                    // ESSymbol indicates something typed symbol.
                    // UniqueESSymbol indicates a specific unique symbol, used e.g. to index into an object.
                    // Closure does not have this distinction, so tsickle emits both as 'symbol'.
                    return 'symbol';
                case ts.TypeFlags.Void:
                    return 'void';
                case ts.TypeFlags.Undefined:
                    return 'undefined';
                case ts.TypeFlags.BigInt:
                case ts.TypeFlags.BigIntLiteral:
                    return 'bigintPlaceholder';
                case ts.TypeFlags.Null:
                    return 'null';
                case ts.TypeFlags.Never:
                    this.warn(`should not emit a 'never' type`);
                    return '?';
                case ts.TypeFlags.TypeParameter:
                    // This is e.g. the T in a type like Foo<T>.
                    if (!type.symbol) {
                        this.warn(`TypeParameter without a symbol`); // should not happen (tm)
                        return '?';
                    }
                    // In Closure, type parameters ("<T>") are non-nullable by default, unlike references to
                    // classes or interfaces. However this code path can be reached by bound type parameters,
                    // where the type parameter's symbol references a plain class or interface. In this case,
                    // add `!` to avoid emitting a nullable type.
                    let prefix = '';
                    if ((type.symbol.flags & ts.SymbolFlags.TypeParameter) === 0) {
                        prefix = '!';
                    }
                    const name = this.symbolToString(type.symbol);
                    if (!name)
                        return '?';
                    return prefix + name;
                case ts.TypeFlags.Object:
                    return this.translateObject(type);
                case ts.TypeFlags.Union:
                    return this.translateUnion(type);
                case ts.TypeFlags.Conditional:
                case ts.TypeFlags.Substitution:
                    this.warn(`emitting ? for conditional/substitution type`);
                    return '?';
                case ts.TypeFlags.Intersection:
                case ts.TypeFlags.Index:
                case ts.TypeFlags.IndexedAccess:
                    // TODO(ts2.1): handle these special types.
                    this.warn(`unhandled type flags: ${ts.TypeFlags[type.flags]}`);
                    return '?';
                default:
                    // Handle cases where multiple flags are set.
                    // Types with literal members are represented as
                    //   ts.TypeFlags.Union | [literal member]
                    // E.g. an enum typed value is a union type with the enum's members as its members. A
                    // boolean type is a union type with 'true' and 'false' as its members.
                    // Note also that in a more complex union, e.g. boolean|number, then it's a union of three
                    // things (true|false|number) and ts.TypeFlags.Boolean doesn't show up at all.
                    if (type.flags & ts.TypeFlags.Union) {
                        return this.translateUnion(type);
                    }
                    if (type.flags & ts.TypeFlags.EnumLiteral) {
                        return this.translateEnumLiteral(type);
                    }
                    // The switch statement should have been exhaustive.
                    throw new Error(`unknown type flags ${type.flags} on ${typeToDebugString(type)}`);
            }
        }
        translateUnion(type) {
            // Union types that include literals (e.g. boolean, enum) can end up repeating the same Closure
            // type. For example: true | boolean will be translated to boolean | boolean.
            // Remove duplicates to produce types that read better.
            const parts = new Set(type.types.map(t => this.translate(t)));
            // If it's a single element set, return the single member.
            if (parts.size === 1)
                return parts.values().next().value;
            return `(${Array.from(parts.values()).join('|')})`;
        }
        translateEnumLiteral(type) {
            // Suppose you had:
            //   enum EnumType { MEMBER }
            // then the type of "EnumType.MEMBER" is an enum literal (the thing passed to this function)
            // and it has type flags that include
            //   ts.TypeFlags.NumberLiteral | ts.TypeFlags.EnumLiteral
            //
            // Closure Compiler doesn't support literals in types, so this code must not emit
            // "EnumType.MEMBER", but rather "EnumType".
            const enumLiteralBaseType = this.typeChecker.getBaseTypeOfLiteralType(type);
            if (!enumLiteralBaseType.symbol) {
                this.warn(`EnumLiteralType without a symbol`);
                return '?';
            }
            let symbol = enumLiteralBaseType.symbol;
            if (enumLiteralBaseType === type) {
                // TypeScript's API will return the same EnumLiteral type if the enum only has a single member
                // value. See https://github.com/Microsoft/TypeScript/issues/28869.
                // In that case, take the parent symbol of the enum member, which should be the enum
                // declaration.
                // tslint:disable-next-line:no-any working around a TS API deficiency.
                const parent = symbol['parent'];
                if (!parent)
                    return '?';
                symbol = parent;
            }
            const name = this.symbolToString(symbol);
            if (!name)
                return '?';
            // In Closure, enum types are non-null by default, so we wouldn't need to emit the `!` here.
            // However that's confusing to users, to the point that style guides and linters require to
            // *always* specify the nullability modifier. To be consistent with that style, include it here
            // as well.
            return '!' + name;
        }
        // translateObject translates a ts.ObjectType, which is the type of all
        // object-like things in TS, such as classes and interfaces.
        translateObject(type) {
            if (type.symbol && this.isBlackListed(type.symbol))
                return '?';
            // NOTE: objectFlags is an enum, but a given type can have multiple flags.
            // Array<string> is both ts.ObjectFlags.Reference and ts.ObjectFlags.Interface.
            if (type.objectFlags & ts.ObjectFlags.Class) {
                if (!type.symbol) {
                    this.warn('class has no symbol');
                    return '?';
                }
                const name = this.symbolToString(type.symbol);
                if (!name) {
                    // An anonymous type. Make sure not to emit '!?', as that is a syntax error in Closure
                    // Compiler.
                    return '?';
                }
                return '!' + name;
            }
            else if (type.objectFlags & ts.ObjectFlags.Interface) {
                // Note: ts.InterfaceType has a typeParameters field, but that
                // specifies the parameters that the interface type *expects*
                // when it's used, and should not be transformed to the output.
                // E.g. a type like Array<number> is a TypeReference to the
                // InterfaceType "Array", but the "number" type parameter is
                // part of the outer TypeReference, not a typeParameter on
                // the InterfaceType.
                if (!type.symbol) {
                    this.warn('interface has no symbol');
                    return '?';
                }
                if (type.symbol.flags & ts.SymbolFlags.Value) {
                    // The symbol is both a type and a value.
                    // For user-defined types in this state, we may not have a Closure name
                    // for the type.  See the type_and_value test.
                    if (!typeValueConflictHandled(type.symbol)) {
                        this.warn(`type/symbol conflict for ${type.symbol.name}, using {?} for now`);
                        return '?';
                    }
                }
                return '!' + this.symbolToString(type.symbol);
            }
            else if (type.objectFlags & ts.ObjectFlags.Reference) {
                // A reference to another type, e.g. Array<number> refers to Array.
                // Emit the referenced type and any type arguments.
                const referenceType = type;
                // A tuple is a ReferenceType where the target is flagged Tuple and the
                // typeArguments are the tuple arguments.  Just treat it as a mystery
                // array, because Closure doesn't understand tuples.
                if (referenceType.target.objectFlags & ts.ObjectFlags.Tuple) {
                    return '!Array<?>';
                }
                let typeStr = '';
                if (referenceType.target === referenceType) {
                    // We get into an infinite loop here if the inner reference is
                    // the same as the outer; this can occur when this function
                    // fails to translate a more specific type before getting to
                    // this point.
                    throw new Error(`reference loop in ${typeToDebugString(referenceType)} ${referenceType.flags}`);
                }
                typeStr += this.translate(referenceType.target);
                // Translate can return '?' for a number of situations, e.g. type/value conflicts.
                // `?<?>` is illegal syntax in Closure Compiler, so just return `?` here.
                if (typeStr === '?')
                    return '?';
                const typeArgs = this.typeChecker.getTypeArguments(referenceType);
                if (typeArgs) {
                    const params = typeArgs.map(t => this.translate(t));
                    typeStr += `<${params.join(', ')}>`;
                }
                return typeStr;
            }
            else if (type.objectFlags & ts.ObjectFlags.Anonymous) {
                return this.translateAnonymousType(type);
            }
            /*
            TODO(ts2.1): more unhandled object type flags:
              Tuple
              Mapped
              Instantiated
              ObjectLiteral
              EvolvingArray
              ObjectLiteralPatternWithComputedProperties
            */
            this.warn(`unhandled type ${typeToDebugString(type)}`);
            return '?';
        }
        /**
         * translateAnonymousType translates a ts.TypeFlags.ObjectType that is also
         * ts.ObjectFlags.Anonymous. That is, this type's symbol does not have a name. This is the
         * anonymous type encountered in e.g.
         *     let x: {a: number};
         * But also the inferred type in:
         *     let x = {a: 1};  // type of x is {a: number}, as above
         */
        translateAnonymousType(type) {
            this.seenAnonymousTypes.add(type);
            if (!type.symbol) {
                // This comes up when generating code for an arrow function as passed
                // to a generic function.  The passed-in type is tagged as anonymous
                // and has no properties so it's hard to figure out what to generate.
                // Just avoid it for now so we don't crash.
                this.warn('anonymous type has no symbol');
                return '?';
            }
            if (type.symbol.flags & ts.SymbolFlags.Function || type.symbol.flags & ts.SymbolFlags.Method) {
                const sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
                if (sigs.length === 1) {
                    return this.signatureToClosure(sigs[0]);
                }
                this.warn('unhandled anonymous type with multiple call signatures');
                return '?';
            }
            // Gather up all the named fields and whether the object is also callable.
            let callable = false;
            let indexable = false;
            const fields = [];
            if (!type.symbol.members) {
                this.warn('anonymous type has no symbol');
                return '?';
            }
            // special-case construct signatures.
            const ctors = type.getConstructSignatures();
            if (ctors.length) {
                // TODO(martinprobst): this does not support additional properties defined on constructors
                // (not expressible in Closure), nor multiple constructors (same).
                const decl = ctors[0].declaration;
                if (!decl) {
                    this.warn('unhandled anonymous type with constructor signature but no declaration');
                    return '?';
                }
                if (decl.kind === ts.SyntaxKind.JSDocSignature) {
                    this.warn('unhandled JSDoc based constructor signature');
                    return '?';
                }
                // new <T>(tee: T) is not supported by Closure, blacklist as ?.
                this.blacklistTypeParameters(this.symbolsToAliasedNames, decl.typeParameters);
                const params = this.convertParams(ctors[0], decl.parameters);
                const paramsStr = params.length ? (', ' + params.join(', ')) : '';
                const constructedType = this.translate(ctors[0].getReturnType());
                const constructedTypeStr = constructedType[0] === '!' ? constructedType.substring(1) : constructedType;
                // In the specific case of the "new" in a function, the correct Closure
                // type is:
                //
                //   function(new:Bar, ...args)
                //
                // Including the nullability annotation can cause the Closure compiler to
                // no longer recognize the function as a constructor type in externs.
                return `function(new:${constructedTypeStr}${paramsStr})`;
            }
            // members is an ES6 map, but the .d.ts defining it defined their own map
            // type, so typescript doesn't believe that .keys() is iterable
            // tslint:disable-next-line:no-any
            for (const field of type.symbol.members.keys()) {
                switch (field) {
                    case '__call':
                        callable = true;
                        break;
                    case '__index':
                        indexable = true;
                        break;
                    default:
                        if (!isValidClosurePropertyName(field)) {
                            this.warn(`omitting inexpressible property name: ${field}`);
                            continue;
                        }
                        const member = type.symbol.members.get(field);
                        // optional members are handled by the type including |undefined in a union type.
                        const memberType = this.translate(this.typeChecker.getTypeOfSymbolAtLocation(member, this.node));
                        fields.push(`${field}: ${memberType}`);
                        break;
                }
            }
            // Try to special-case plain key-value objects and functions.
            if (fields.length === 0) {
                if (callable && !indexable) {
                    // A function type.
                    const sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
                    if (sigs.length === 1) {
                        return this.signatureToClosure(sigs[0]);
                    }
                }
                else if (indexable && !callable) {
                    // A plain key-value map type.
                    let keyType = 'string';
                    let valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.String);
                    if (!valType) {
                        keyType = 'number';
                        valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.Number);
                    }
                    if (!valType) {
                        this.warn('unknown index key type');
                        return `!Object<?,?>`;
                    }
                    return `!Object<${keyType},${this.translate(valType)}>`;
                }
                else if (!callable && !indexable) {
                    // The object has no members.  This is the TS type '{}',
                    // which means "any value other than null or undefined".
                    // What is this in Closure's type system?
                    //
                    // First, {!Object} is wrong because it is not a supertype of
                    // {string} or {number}.  This would mean you cannot assign a
                    // number to a variable of TS type {}.
                    //
                    // We get closer with {*}, aka the ALL type.  This one better
                    // captures the typical use of the TS {}, which users use for
                    // "I don't care".
                    //
                    // {*} unfortunately does include null/undefined, so it's a closer
                    // match for TS 3.0's 'unknown'.
                    return '*';
                }
            }
            if (!callable && !indexable) {
                // Not callable, not indexable; implies a plain object with fields in it.
                return `{${fields.join(', ')}}`;
            }
            this.warn('unhandled anonymous type');
            return '?';
        }
        /** Converts a ts.Signature (function signature) to a Closure function type. */
        signatureToClosure(sig) {
            // TODO(martinprobst): Consider harmonizing some overlap with emitFunctionType in tsickle.ts.
            if (!sig.declaration) {
                this.warn('signature without declaration');
                return 'Function';
            }
            if (sig.declaration.kind === ts.SyntaxKind.JSDocSignature) {
                this.warn('signature with JSDoc declaration');
                return 'Function';
            }
            this.blacklistTypeParameters(this.symbolsToAliasedNames, sig.declaration.typeParameters);
            let typeStr = `function(`;
            let paramDecls = sig.declaration.parameters || [];
            const maybeThisParam = paramDecls[0];
            // Oddly, the this type shows up in paramDecls, but not in the type's parameters.
            // Handle it here and then pass paramDecls down without its first element.
            if (maybeThisParam && maybeThisParam.name.getText() === 'this') {
                if (maybeThisParam.type) {
                    const thisType = this.typeChecker.getTypeAtLocation(maybeThisParam.type);
                    typeStr += `this: (${this.translate(thisType)})`;
                    if (paramDecls.length > 1)
                        typeStr += ', ';
                }
                else {
                    this.warn('this type without type');
                }
                paramDecls = paramDecls.slice(1);
            }
            const params = this.convertParams(sig, paramDecls);
            typeStr += `${params.join(', ')})`;
            const retType = this.translate(this.typeChecker.getReturnTypeOfSignature(sig));
            if (retType) {
                typeStr += `: ${retType}`;
            }
            return typeStr;
        }
        /**
         * Converts parameters for the given signature. Takes parameter declarations as those might not
         * match the signature parameters (e.g. there might be an additional this parameter). This
         * difference is handled by the caller, as is converting the "this" parameter.
         */
        convertParams(sig, paramDecls) {
            const paramTypes = [];
            for (let i = 0; i < sig.parameters.length; i++) {
                const param = sig.parameters[i];
                const paramDecl = paramDecls[i];
                const optional = !!paramDecl.questionToken;
                const varArgs = !!paramDecl.dotDotDotToken;
                let paramType = this.typeChecker.getTypeOfSymbolAtLocation(param, this.node);
                if (varArgs) {
                    if ((paramType.flags & ts.TypeFlags.Object) === 0) {
                        this.warn('var args type is not an object type');
                        paramTypes.push('!Array<?>');
                        continue;
                    }
                    if ((paramType.objectFlags & ts.ObjectFlags.Reference) === 0) {
                        this.warn('unsupported var args type (not an array reference)');
                        paramTypes.push('!Array<?>');
                        continue;
                    }
                    const typeArgs = this.typeChecker.getTypeArguments(paramType);
                    if (typeArgs.length === 0) {
                        // When a rest argument resolves empty, i.e. the concrete instantiation does not take any
                        // arguments, the type arguments are empty. Emit a function type that takes no arg in this
                        // position then.
                        continue;
                    }
                    paramType = typeArgs[0];
                }
                let typeStr = this.translate(paramType);
                if (varArgs)
                    typeStr = '...' + typeStr;
                if (optional)
                    typeStr = typeStr + '=';
                paramTypes.push(typeStr);
            }
            return paramTypes;
        }
        warn(msg) {
            // By default, warn() does nothing.  The caller will overwrite this
            // if it wants different behavior.
        }
        /** @return true if sym should always have type {?}. */
        isBlackListed(symbol) {
            return isBlacklisted(this.pathBlackList, symbol);
        }
        /**
         * Closure doesn not support type parameters for function types, i.e. generic function types.
         * Blacklist the symbols declared by them and emit a ? for the types.
         *
         * This mutates the given blacklist map. The map's scope is one file, and symbols are
         * unique objects, so this should neither lead to excessive memory consumption nor introduce
         * errors.
         *
         * @param blacklist a map to store the blacklisted symbols in, with a value of '?'. In practice,
         *     this is always === this.symbolsToAliasedNames, but we're passing it explicitly to make it
         *    clear that the map is mutated (in particular when used from outside the class).
         * @param decls the declarations whose symbols should be blacklisted.
         */
        blacklistTypeParameters(blacklist, decls) {
            if (!decls || !decls.length)
                return;
            for (const tpd of decls) {
                const sym = this.typeChecker.getSymbolAtLocation(tpd.name);
                if (!sym) {
                    this.warn(`type parameter with no symbol`);
                    continue;
                }
                blacklist.set(sym, '?');
            }
        }
    }
    exports.TypeTranslator = TypeTranslator;
    /** @return true if sym should always have type {?}. */
    function isBlacklisted(pathBlackList, symbol) {
        if (pathBlackList === undefined)
            return false;
        // Some builtin types, such as {}, get represented by a symbol that has no declarations.
        if (symbol.declarations === undefined)
            return false;
        return symbol.declarations.every(n => {
            const fileName = path.normalize(n.getSourceFile().fileName);
            return pathBlackList.has(fileName);
        });
    }
    exports.isBlacklisted = isBlacklisted;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZV90cmFuc2xhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3R5cGVfdHJhbnNsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7SUFFSCxpQ0FBaUM7SUFFakMsK0RBQXVFO0lBQ3ZFLHlDQUErQjtJQUMvQixtRUFBaUY7SUFFakY7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0gsU0FBZ0IsMEJBQTBCLENBQUMsSUFBWTtRQUNyRCwwRUFBMEU7UUFDMUUsbURBQW1EO1FBQ25ELE9BQU8sMEJBQTBCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFKRCxnRUFJQztJQUVEOzs7T0FHRztJQUNILFNBQWdCLGVBQWUsQ0FBQyxRQUFnQjtRQUM5QyxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsMkJBQTJCLENBQUMsSUFBSSxJQUFJLENBQUM7SUFDN0QsQ0FBQztJQUZELDBDQUVDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUyxVQUFVLENBQUMsVUFBeUI7UUFDM0MsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNILFNBQWdCLHdCQUF3QixDQUFDLE1BQWlCO1FBQ3hELDRGQUE0RjtRQUM1RixvRUFBb0U7UUFDcEUsT0FBTyxNQUFNLENBQUMsWUFBWSxJQUFJLElBQUk7WUFDOUIsTUFBTSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQ3BCLENBQUMsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM3RixDQUFDO0lBTkQsNERBTUM7SUFFRCxTQUFnQixpQkFBaUIsQ0FBQyxJQUFhO1FBQzdDLElB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QUFTLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzVELE9BQU8sYUFBYSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNyQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFSRCxzQ0FRQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCB7QW5ub3RhdG9ySG9zdCwgbW9kdWxlTmFtZUFzSWRlbnRpZmllcn0gZnJvbSAnLi9hbm5vdGF0b3JfaG9zdCc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJy4vcGF0aCc7XG5pbXBvcnQge2dldElkZW50aWZpZXJUZXh0LCBoYXNNb2RpZmllckZsYWcsIGlzQW1iaWVudH0gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcblxuLyoqXG4gKiBUeXBlU2NyaXB0IGFsbG93cyB5b3UgdG8gd3JpdGUgaWRlbnRpZmllcnMgcXVvdGVkLCBsaWtlOlxuICogICBpbnRlcmZhY2UgRm9vIHtcbiAqICAgICAnYmFyJzogc3RyaW5nO1xuICogICAgICdjb21wbGV4IG5hbWUnOiBzdHJpbmc7XG4gKiAgIH1cbiAqICAgRm9vLmJhcjsgIC8vIG9rXG4gKiAgIEZvb1snYmFyJ10gIC8vIG9rXG4gKiAgIEZvb1snY29tcGxleCBuYW1lJ10gIC8vIG9rXG4gKlxuICogSW4gQ2xvc3VyZS1sYW5kLCB3ZSB3YW50IGlkZW50aWZ5IHRoYXQgdGhlIGxlZ2FsIG5hbWUgJ2JhcicgY2FuIGJlY29tZSBhblxuICogb3JkaW5hcnkgZmllbGQsIGJ1dCB3ZSBuZWVkIHRvIHNraXAgc3RyaW5ncyBsaWtlICdjb21wbGV4IG5hbWUnLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWUobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEluIGxvY2FsIGV4cGVyaW1lbnRhdGlvbiwgaXQgYXBwZWFycyB0aGF0IHJlc2VydmVkIHdvcmRzIGxpa2UgJ3ZhcicgYW5kXG4gIC8vICdpZicgYXJlIGxlZ2FsIEpTIGFuZCBzdGlsbCBhY2NlcHRlZCBieSBDbG9zdXJlLlxuICByZXR1cm4gL15bYS16QS1aX11bYS16QS1aMC05X10qJC8udGVzdChuYW1lKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGZpbGVOYW1lIHJlZmVycyB0byBhIGJ1aWx0aW4gbGliLmQudHMgZmlsZS5cbiAqIFRoaXMgaXMgYSB0ZXJyaWJsZSBoYWNrIGJ1dCBpdCBtaXJyb3JzIGEgc2ltaWxhciB0aGluZyBkb25lIGluIENsdXR6LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCdWlsdGluTGliRFRTKGZpbGVOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGZpbGVOYW1lLm1hdGNoKC9cXGJsaWJcXC4oPzpbXi9dK1xcLik/ZFxcLnRzJC8pICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzb3VyY2UgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgQ2x1dHosIGkuZS4gaGFzIHRoZSBtYWdpY1xuICogQ2x1dHogaGVhZGVyLlxuICovXG5mdW5jdGlvbiBpc0NsdXR6RHRzKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHNvdXJjZUZpbGUudGV4dC5zdGFydHNXaXRoKCcvLyEhIGdlbmVyYXRlZCBieSBjbHV0ei4nKTtcbn1cblxuLyoqXG4gKiB0eXBlVmFsdWVDb25mbGljdEhhbmRsZWQgcmV0dXJucyB0cnVlIGZvciBzeW1ib2xzIHdob3NlIHR5cGUvdmFsdWUgY29uZmxpY3QgaXMgaGFuZGxlZCBvdXRzaWRlIG9mXG4gKiB0c2lja2xlLlxuICpcbiAqIFRoaXMgY292ZXJzIHR3byBjYXNlczpcbiAqXG4gKiAtIHN5bWJvbHMgcHJvdmlkZWQgYnkgQ2x1dHouIEdpdmVuIHRoYXQgQ2xvc3VyZSBoYXMgYSBtZXJnZWQgdHlwZS92YWx1ZSBuYW1lc3BhY2UsIGFwcGFyZW50XG4gKiAgIHR5cGUvdmFsdWUgY29uZmxpY3RzIG9uIHRoZSBUeXBlU2NyaXB0IGxldmVsIGFyZSBhY3R1YWxseSBmaW5lLlxuICogLSBidWlsdGluIGxpYiouZC50cyBzeW1ib2xzLCBzdWNoIGFzIFwiQXJyYXlcIiwgd2hpY2ggYXJlIGNvbnNpZGVyZWQgQ2xvc3VyZS1jb21wYXRpYmxlLiBOb3RlIHRoYXRcbiAqICAgd2UgZG9uJ3QgYWN0dWFsbHkgZW5mb3JjZSB0aGF0IHRoZSB0eXBlcyBhcmUgYWN0dWFsbHkgY29tcGF0aWJsZSwgYnV0IG1vc3RseSBqdXN0IGhvcGUgdGhhdFxuICogICB0aGV5IGFyZSBkdWUgdG8gYmVpbmcgZGVyaXZlZCBmcm9tIHRoZSBzYW1lIEhUTUwgc3BlY3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0eXBlVmFsdWVDb25mbGljdEhhbmRsZWQoc3ltYm9sOiB0cy5TeW1ib2wpIHtcbiAgLy8gVE9ETygjMTA3Mik6IGlmIHRoZSBzeW1ib2wgY29tZXMgZnJvbSBhIHRzaWNrbGUtdHJhbnNwaWxlZCBmaWxlLCBlaXRoZXIgLnRzIG9yIC5kLnRzIHdpdGhcbiAgLy8gZXh0ZXJucyBnZW5lcmF0aW9uPyB0aGVuIG1heWJlIHdlIGNhbiBlbWl0IGl0IHdpdGggbmFtZSBtYW5nbGluZy5cbiAgcmV0dXJuIHN5bWJvbC5kZWNsYXJhdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgc3ltYm9sLmRlY2xhcmF0aW9ucy5zb21lKFxuICAgICAgICAgIG4gPT4gaXNCdWlsdGluTGliRFRTKG4uZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lKSB8fCBpc0NsdXR6RHRzKG4uZ2V0U291cmNlRmlsZSgpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0eXBlVG9EZWJ1Z1N0cmluZyh0eXBlOiB0cy5UeXBlKTogc3RyaW5nIHtcbiAgbGV0IGRlYnVnU3RyaW5nID0gYGZsYWdzOjB4JHt0eXBlLmZsYWdzLnRvU3RyaW5nKDE2KX1gO1xuXG4gIGlmICh0eXBlLmFsaWFzU3ltYm9sKSB7XG4gICAgZGVidWdTdHJpbmcgKz0gYCBhbGlhczoke3N5bWJvbFRvRGVidWdTdHJpbmcodHlwZS5hbGlhc1N5bWJvbCl9YDtcbiAgfVxuICBpZiAodHlwZS5hbGlhc1R5cGVBcmd1bWVudHMpIHtcbiAgICBkZWJ1Z1N0cmluZyArPSBgIGFsaWFzQXJnczo8JHt0eXBlLmFsaWFzVHlwZUFyZ3VtZW50cy5tYXAodHlwZVRvRGVidWdTdHJpbmcpLmpvaW4oJywnKX0+YDtcbiAgfVxuXG4gIC8vIEp1c3QgdGhlIHVuaXF1ZSBmbGFncyAocG93ZXJzIG9mIHR3bykuIERlY2xhcmVkIGluIHNyYy9jb21waWxlci90eXBlcy50cy5cbiAgY29uc3QgYmFzaWNUeXBlczogdHMuVHlwZUZsYWdzW10gPSBbXG4gICAgdHMuVHlwZUZsYWdzLkFueSwgICAgICAgICAgIHRzLlR5cGVGbGFncy5TdHJpbmcsICAgICAgICAgdHMuVHlwZUZsYWdzLk51bWJlcixcbiAgICB0cy5UeXBlRmxhZ3MuQm9vbGVhbiwgICAgICAgdHMuVHlwZUZsYWdzLkVudW0sICAgICAgICAgICB0cy5UeXBlRmxhZ3MuU3RyaW5nTGl0ZXJhbCxcbiAgICB0cy5UeXBlRmxhZ3MuTnVtYmVyTGl0ZXJhbCwgdHMuVHlwZUZsYWdzLkJvb2xlYW5MaXRlcmFsLCB0cy5UeXBlRmxhZ3MuRW51bUxpdGVyYWwsXG4gICAgdHMuVHlwZUZsYWdzLkJpZ0ludExpdGVyYWwsIHRzLlR5cGVGbGFncy5FU1N5bWJvbCwgICAgICAgdHMuVHlwZUZsYWdzLlVuaXF1ZUVTU3ltYm9sLFxuICAgIHRzLlR5cGVGbGFncy5Wb2lkLCAgICAgICAgICB0cy5UeXBlRmxhZ3MuVW5kZWZpbmVkLCAgICAgIHRzLlR5cGVGbGFncy5OdWxsLFxuICAgIHRzLlR5cGVGbGFncy5OZXZlciwgICAgICAgICB0cy5UeXBlRmxhZ3MuVHlwZVBhcmFtZXRlciwgIHRzLlR5cGVGbGFncy5PYmplY3QsXG4gICAgdHMuVHlwZUZsYWdzLlVuaW9uLCAgICAgICAgIHRzLlR5cGVGbGFncy5JbnRlcnNlY3Rpb24sICAgdHMuVHlwZUZsYWdzLkluZGV4LFxuICAgIHRzLlR5cGVGbGFncy5JbmRleGVkQWNjZXNzLCB0cy5UeXBlRmxhZ3MuQ29uZGl0aW9uYWwsICAgIHRzLlR5cGVGbGFncy5TdWJzdGl0dXRpb24sXG4gIF07XG4gIGZvciAoY29uc3QgZmxhZyBvZiBiYXNpY1R5cGVzKSB7XG4gICAgaWYgKCh0eXBlLmZsYWdzICYgZmxhZykgIT09IDApIHtcbiAgICAgIGRlYnVnU3RyaW5nICs9IGAgJHt0cy5UeXBlRmxhZ3NbZmxhZ119YDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZS5mbGFncyA9PT0gdHMuVHlwZUZsYWdzLk9iamVjdCkge1xuICAgIGNvbnN0IG9ialR5cGUgPSB0eXBlIGFzIHRzLk9iamVjdFR5cGU7XG4gICAgZGVidWdTdHJpbmcgKz0gYCBvYmplY3RGbGFnczoweCR7b2JqVHlwZS5vYmplY3RGbGFnc31gO1xuICAgIC8vIEp1c3QgdGhlIHVuaXF1ZSBmbGFncyAocG93ZXJzIG9mIHR3bykuIERlY2xhcmVkIGluIHNyYy9jb21waWxlci90eXBlcy50cy5cbiAgICBjb25zdCBvYmplY3RGbGFnczogdHMuT2JqZWN0RmxhZ3NbXSA9IFtcbiAgICAgIHRzLk9iamVjdEZsYWdzLkNsYXNzLFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuSW50ZXJmYWNlLFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuUmVmZXJlbmNlLFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuVHVwbGUsXG4gICAgICB0cy5PYmplY3RGbGFncy5Bbm9ueW1vdXMsXG4gICAgICB0cy5PYmplY3RGbGFncy5NYXBwZWQsXG4gICAgICB0cy5PYmplY3RGbGFncy5JbnN0YW50aWF0ZWQsXG4gICAgICB0cy5PYmplY3RGbGFncy5PYmplY3RMaXRlcmFsLFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuRXZvbHZpbmdBcnJheSxcbiAgICAgIHRzLk9iamVjdEZsYWdzLk9iamVjdExpdGVyYWxQYXR0ZXJuV2l0aENvbXB1dGVkUHJvcGVydGllcyxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgZmxhZyBvZiBvYmplY3RGbGFncykge1xuICAgICAgaWYgKChvYmpUeXBlLm9iamVjdEZsYWdzICYgZmxhZykgIT09IDApIHtcbiAgICAgICAgZGVidWdTdHJpbmcgKz0gYCBvYmplY3Q6JHt0cy5PYmplY3RGbGFnc1tmbGFnXX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlLnN5bWJvbCAmJiB0eXBlLnN5bWJvbC5uYW1lICE9PSAnX190eXBlJykge1xuICAgIGRlYnVnU3RyaW5nICs9IGAgc3ltYm9sLm5hbWU6JHtKU09OLnN0cmluZ2lmeSh0eXBlLnN5bWJvbC5uYW1lKX1gO1xuICB9XG5cbiAgaWYgKHR5cGUucGF0dGVybikge1xuICAgIGRlYnVnU3RyaW5nICs9IGAgZGVzdHJ1Y3R1cmluZzp0cnVlYDtcbiAgfVxuXG4gIHJldHVybiBge3R5cGUgJHtkZWJ1Z1N0cmluZ319YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bWJvbFRvRGVidWdTdHJpbmcoc3ltOiB0cy5TeW1ib2wpOiBzdHJpbmcge1xuICBsZXQgZGVidWdTdHJpbmcgPSBgJHtKU09OLnN0cmluZ2lmeShzeW0ubmFtZSl9IGZsYWdzOjB4JHtzeW0uZmxhZ3MudG9TdHJpbmcoMTYpfWA7XG5cbiAgLy8gSnVzdCB0aGUgdW5pcXVlIGZsYWdzIChwb3dlcnMgb2YgdHdvKS4gRGVjbGFyZWQgaW4gc3JjL2NvbXBpbGVyL3R5cGVzLnRzLlxuICBjb25zdCBzeW1ib2xGbGFncyA9IFtcbiAgICB0cy5TeW1ib2xGbGFncy5GdW5jdGlvblNjb3BlZFZhcmlhYmxlLFxuICAgIHRzLlN5bWJvbEZsYWdzLkJsb2NrU2NvcGVkVmFyaWFibGUsXG4gICAgdHMuU3ltYm9sRmxhZ3MuUHJvcGVydHksXG4gICAgdHMuU3ltYm9sRmxhZ3MuRW51bU1lbWJlcixcbiAgICB0cy5TeW1ib2xGbGFncy5GdW5jdGlvbixcbiAgICB0cy5TeW1ib2xGbGFncy5DbGFzcyxcbiAgICB0cy5TeW1ib2xGbGFncy5JbnRlcmZhY2UsXG4gICAgdHMuU3ltYm9sRmxhZ3MuQ29uc3RFbnVtLFxuICAgIHRzLlN5bWJvbEZsYWdzLlJlZ3VsYXJFbnVtLFxuICAgIHRzLlN5bWJvbEZsYWdzLlZhbHVlTW9kdWxlLFxuICAgIHRzLlN5bWJvbEZsYWdzLk5hbWVzcGFjZU1vZHVsZSxcbiAgICB0cy5TeW1ib2xGbGFncy5UeXBlTGl0ZXJhbCxcbiAgICB0cy5TeW1ib2xGbGFncy5PYmplY3RMaXRlcmFsLFxuICAgIHRzLlN5bWJvbEZsYWdzLk1ldGhvZCxcbiAgICB0cy5TeW1ib2xGbGFncy5Db25zdHJ1Y3RvcixcbiAgICB0cy5TeW1ib2xGbGFncy5HZXRBY2Nlc3NvcixcbiAgICB0cy5TeW1ib2xGbGFncy5TZXRBY2Nlc3NvcixcbiAgICB0cy5TeW1ib2xGbGFncy5TaWduYXR1cmUsXG4gICAgdHMuU3ltYm9sRmxhZ3MuVHlwZVBhcmFtZXRlcixcbiAgICB0cy5TeW1ib2xGbGFncy5UeXBlQWxpYXMsXG4gICAgdHMuU3ltYm9sRmxhZ3MuRXhwb3J0VmFsdWUsXG4gICAgdHMuU3ltYm9sRmxhZ3MuQWxpYXMsXG4gICAgdHMuU3ltYm9sRmxhZ3MuUHJvdG90eXBlLFxuICAgIHRzLlN5bWJvbEZsYWdzLkV4cG9ydFN0YXIsXG4gICAgdHMuU3ltYm9sRmxhZ3MuT3B0aW9uYWwsXG4gICAgdHMuU3ltYm9sRmxhZ3MuVHJhbnNpZW50LFxuICBdO1xuICBmb3IgKGNvbnN0IGZsYWcgb2Ygc3ltYm9sRmxhZ3MpIHtcbiAgICBpZiAoKHN5bS5mbGFncyAmIGZsYWcpICE9PSAwKSB7XG4gICAgICBkZWJ1Z1N0cmluZyArPSBgICR7dHMuU3ltYm9sRmxhZ3NbZmxhZ119YDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVidWdTdHJpbmc7XG59XG5cbi8qKiBBIG1vZHVsZSBkZWNsYXJlZCBhcyBcImRlY2xhcmUgbW9kdWxlICdleHRlcm5hbF9uYW1lJyB7Li4ufVwiIChub3RlIHRoZSBxdW90ZXMpLiAqL1xudHlwZSBBbWJpZW50TW9kdWxlRGVjbGFyYXRpb24gPSB0cy5Nb2R1bGVEZWNsYXJhdGlvbiZ7bmFtZTogdHMuU3RyaW5nTGl0ZXJhbH07XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIGFuIGFtYmllbnQgbW9kdWxlIGRlY2xhcmF0aW9uIGluIHRoZSBhbmNlc3RvcnMgb2YgZGVjbGFyYXRpb25zLCBkZXB0aCBmaXJzdCwgYW5kXG4gKiByZXR1cm5zIHRoZSBmaXJzdCBvciBudWxsIGlmIG5vbmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdBbWJpZW50TW9kdWxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zOiB0cy5EZWNsYXJhdGlvbltdKTpcbiAgICBBbWJpZW50TW9kdWxlRGVjbGFyYXRpb258bnVsbCB7XG4gIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgZGVjbGFyYXRpb25zKSB7XG4gICAgbGV0IHBhcmVudCA9IGRlY2xhcmF0aW9uLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAodHMuaXNNb2R1bGVEZWNsYXJhdGlvbihwYXJlbnQpICYmIHRzLmlzU3RyaW5nTGl0ZXJhbChwYXJlbnQubmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudCBhcyBBbWJpZW50TW9kdWxlRGVjbGFyYXRpb247XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgZGVjbGFyYXRpb25zIGlzIGEgdG9wIGxldmVsIGRlY2xhcmF0aW9uIGluIGFuIGV4dGVybmFsIG1vZHVsZS4gKi9cbmZ1bmN0aW9uIGlzVG9wTGV2ZWxFeHRlcm5hbChkZWNsYXJhdGlvbnM6IHRzLkRlY2xhcmF0aW9uW10pIHtcbiAgZm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiBkZWNsYXJhdGlvbnMpIHtcbiAgICBpZiAoZGVjbGFyYXRpb24ucGFyZW50ID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgIGlmICh0cy5pc1NvdXJjZUZpbGUoZGVjbGFyYXRpb24ucGFyZW50KSAmJiB0cy5pc0V4dGVybmFsTW9kdWxlKGRlY2xhcmF0aW9uLnBhcmVudCkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBhbmQgYiBhcmUgKG9yIHdlcmUgb3JpZ2luYWxseSBiZWZvcmUgdHJhbnNmb3JtYXRpb24pIG5vZGVzIG9mIHRoZSBzYW1lIHNvdXJjZVxuICogZmlsZS5cbiAqL1xuZnVuY3Rpb24gaXNEZWNsYXJlZEluU2FtZUZpbGUoYTogdHMuTm9kZSwgYjogdHMuTm9kZSkge1xuICByZXR1cm4gdHMuZ2V0T3JpZ2luYWxOb2RlKGEpLmdldFNvdXJjZUZpbGUoKSA9PT0gdHMuZ2V0T3JpZ2luYWxOb2RlKGIpLmdldFNvdXJjZUZpbGUoKTtcbn1cblxuLyoqXG4gKiBUeXBlVHJhbnNsYXRvciB0cmFuc2xhdGVzIFR5cGVTY3JpcHQgdHlwZXMgdG8gQ2xvc3VyZSB0eXBlcy4gSXQga2VlcHMgc3RhdGUgcGVyIHR5cGUsIHNvIGVhY2hcbiAqIHRyYW5zbGF0aW9uIG9wZXJhdGlvbiBoYXMgdG8gY3JlYXRlIGEgbmV3IGluc3RhbmNlLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZVRyYW5zbGF0b3Ige1xuICAvKipcbiAgICogQSBsaXN0IG9mIHR5cGUgbGl0ZXJhbHMgd2UndmUgZW5jb3VudGVyZWQgd2hpbGUgZW1pdHRpbmc7IHVzZWQgdG8gYXZvaWQgZ2V0dGluZyBzdHVjayBpblxuICAgKiByZWN1cnNpdmUgdHlwZXMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHNlZW5Bbm9ueW1vdXNUeXBlcyA9IG5ldyBTZXQ8dHMuVHlwZT4oKTtcblxuICAvKipcbiAgICogV2hldGhlciB0byB3cml0ZSB0eXBlcyBzdWl0YWJsZSBmb3IgYW4gI2V4dGVybnMgZmlsZS4gRXh0ZXJucyB0eXBlcyBtdXN0IG5vdCByZWZlciB0b1xuICAgKiBub24tZXh0ZXJucyB0eXBlcyAoaS5lLiBub24gYW1iaWVudCB0eXBlcykgYW5kIG5lZWQgdG8gdXNlIGZ1bGx5IHF1YWxpZmllZCBuYW1lcy5cbiAgICovXG4gIGlzRm9yRXh0ZXJucyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gbm9kZSBpcyB0aGUgc291cmNlIEFTVCB0cy5Ob2RlIHRoZSB0eXBlIGNvbWVzIGZyb20uICBUaGlzIGlzIHVzZWRcbiAgICogICAgIGluIHNvbWUgY2FzZXMgKGUuZy4gYW5vbnltb3VzIHR5cGVzKSBmb3IgbG9va2luZyB1cCBmaWVsZCBuYW1lcy5cbiAgICogQHBhcmFtIHBhdGhCbGFja0xpc3QgaXMgYSBzZXQgb2YgcGF0aHMgdGhhdCBzaG91bGQgbmV2ZXIgZ2V0IHR5cGVkO1xuICAgKiAgICAgYW55IHJlZmVyZW5jZSB0byBzeW1ib2xzIGRlZmluZWQgaW4gdGhlc2UgcGF0aHMgc2hvdWxkIGJ5IHR5cGVkXG4gICAqICAgICBhcyB7P30uXG4gICAqIEBwYXJhbSBzeW1ib2xzVG9BbGlhc2VkTmFtZXMgYSBtYXBwaW5nIGZyb20gc3ltYm9scyAoYEZvb2ApIHRvIGEgbmFtZSBpbiBzY29wZSB0aGV5IHNob3VsZCBiZVxuICAgKiAgICAgZW1pdHRlZCBhcyAoZS5nLiBgdHNpY2tsZV9yZXFUeXBlXzEuRm9vYCkuIENhbiBiZSBhdWdtZW50ZWQgZHVyaW5nIHR5cGUgdHJhbnNsYXRpb24sIGUuZy5cbiAgICogICAgIHRvIGJsYWNrbGlzdCBhIHN5bWJvbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSByZWFkb25seSBob3N0OiBBbm5vdGF0b3JIb3N0LCBwcml2YXRlIHJlYWRvbmx5IHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgbm9kZTogdHMuTm9kZSwgcHJpdmF0ZSByZWFkb25seSBwYXRoQmxhY2tMaXN0OiBTZXQ8c3RyaW5nPixcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgc3ltYm9sc1RvQWxpYXNlZE5hbWVzOiBNYXA8dHMuU3ltYm9sLCBzdHJpbmc+LFxuICAgICAgcHJpdmF0ZSByZWFkb25seSBzeW1ib2xUb05hbWVDYWNoZTogTWFwPHRzLlN5bWJvbCwgc3RyaW5nPixcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgZW5zdXJlU3ltYm9sRGVjbGFyZWQ6IChzeW06IHRzLlN5bWJvbCkgPT4gdm9pZCA9ICgpID0+IHt9KSB7XG4gICAgLy8gTm9ybWFsaXplIHBhdGhzIHRvIG5vdCBicmVhayBjaGVja3Mgb24gV2luZG93cy5cbiAgICB0aGlzLnBhdGhCbGFja0xpc3QgPVxuICAgICAgICBuZXcgU2V0PHN0cmluZz4oQXJyYXkuZnJvbSh0aGlzLnBhdGhCbGFja0xpc3QudmFsdWVzKCkpLm1hcChwID0+IHBhdGgubm9ybWFsaXplKHApKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSB0cy5TeW1ib2wgdG8gYSBzdHJpbmcsIGFwcGx5aW5nIGFsaWFzZXMgYW5kIGVuc3VyaW5nIHN5bWJvbHMgYXJlIGltcG9ydGVkLlxuICAgKiBAcmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzeW1ib2wgYXMgYSB2YWxpZCBDbG9zdXJlIHR5cGUgbmFtZSwgb3IgYHVuZGVmaW5lZGAgaWZcbiAgICogICAgIHRoZSB0eXBlIGNhbm5vdCBiZSBleHByZXNzZWQgKGUuZy4gZm9yIGFub255bW91cyB0eXBlcykuXG4gICAqL1xuICBzeW1ib2xUb1N0cmluZyhzeW06IHRzLlN5bWJvbCk6IHN0cmluZ3x1bmRlZmluZWQge1xuICAgIC8vIHN5bWJvbFRvRW50aXR5TmFtZSBjYW4gYmUgcmVsYXRpdmVseSBleHBlbnNpdmUgKDQwIG1zIGNhbGxzIHdpdGggc3ltYm9scyBpbiBsYXJnZSBuYW1lc3BhY2VzXG4gICAgLy8gd2l0aCBtYW55IGRlY2xhcmF0aW9ucywgaS5lLiBDbHV0eikuIHN5bWJvbFRvU3RyaW5nIGlzIGlkZW1wb3RlbnQgcGVyIHN5bWJvbCBhbmQgZmlsZSwgdGh1c1xuICAgIC8vIHdlIGNhY2hlIHRoZSBlbnRpcmUgb3BlcmF0aW9uIHRvIGF2b2lkIHRoZSBoaXQuXG4gICAgY29uc3QgY2FjaGVkTmFtZSA9IHRoaXMuc3ltYm9sVG9OYW1lQ2FjaGUuZ2V0KHN5bSk7XG4gICAgaWYgKGNhY2hlZE5hbWUpIHJldHVybiBjYWNoZWROYW1lO1xuXG4gICAgLy8gVHlwZVNjcmlwdCByZXNvbHZlcyBlLmcuIHVuaW9uIHR5cGVzIHRvIHRoZWlyIG1lbWJlcnMsIHdoaWNoIGNhbiBpbmNsdWRlIHN5bWJvbHMgbm90IGRlY2xhcmVkXG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgc2NvcGUuIEVuc3VyZSB0aGF0IGFsbCBzeW1ib2xzIGZvdW5kIHRoaXMgd2F5IGFyZSBhY3R1YWxseSBkZWNsYXJlZC5cbiAgICAvLyBUaGlzIG11c3QgaGFwcGVuIGJlZm9yZSB0aGUgYWxpYXMgY2hlY2sgYmVsb3csIGl0IG1pZ2h0IGludHJvZHVjZSBhIG5ldyBhbGlhcyBmb3IgdGhlIHN5bWJvbC5cbiAgICBpZiAoIXRoaXMuaXNGb3JFeHRlcm5zICYmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5UeXBlUGFyYW1ldGVyKSA9PT0gMCkge1xuICAgICAgdGhpcy5lbnN1cmVTeW1ib2xEZWNsYXJlZChzeW0pO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnR5cGVDaGVja2VyLnN5bWJvbFRvRW50aXR5TmFtZShcbiAgICAgICAgc3ltLCB0cy5TeW1ib2xGbGFncy5UeXBlLCB0aGlzLm5vZGUsIHRzLk5vZGVCdWlsZGVyRmxhZ3MuVXNlRnVsbHlRdWFsaWZpZWRUeXBlKTtcbiAgICAvLyBuYW1lIG1pZ2h0IGJlIHVuZGVmaW5lZCwgZS5nLiBmb3IgYW5vbnltb3VzIGNsYXNzZXMuXG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgLy8gVHlwZVNjcmlwdCdzIHN5bWJvbFRvRW50aXR5TmFtZSByZXR1cm5zIGEgdHJlZSBvZiBJZGVudGlmaWVyIG9iamVjdHMuIHRzaWNrbGUgbmVlZHMgdG9cbiAgICAvLyBpZGVudGlmeSBhbmQgYWxpYXMgc3BlY2lmaXkgc3ltYm9scyBvbiBpdC4gVGhlIGNvZGUgYmVsb3cgYWNjZXNzZXMgdGhlIFR5cGVTY3JpcHQgQGludGVybmFsXG4gICAgLy8gc3ltYm9sIGZpZWxkIG9uIElkZW50aWZpZXIgdG8gZG8gc28uXG4gICAgdHlwZSBJZGVudGlmaWVyV2l0aFN5bWJvbCA9IHRzLklkZW50aWZpZXIme3N5bWJvbDogdHMuU3ltYm9sfTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgLyoqIFJlY3Vyc2l2ZWx5IHZpc2l0cyBjb21wb25lbnRzIG9mIGVudGl0eSBuYW1lIGFuZCB3cml0ZXMgdGhlbSB0byBgc3RyYCBhYm92ZS4gKi9cbiAgICBjb25zdCB3cml0ZUVudGl0eVdpdGhTeW1ib2xzID0gKG5hbWU6IHRzLkVudGl0eU5hbWUpID0+IHtcbiAgICAgIGxldCBpZGVudGlmaWVyOiBJZGVudGlmaWVyV2l0aFN5bWJvbDtcbiAgICAgIGlmICh0cy5pc1F1YWxpZmllZE5hbWUobmFtZSkpIHtcbiAgICAgICAgd3JpdGVFbnRpdHlXaXRoU3ltYm9scyhuYW1lLmxlZnQpO1xuICAgICAgICBzdHIgKz0gJy4nO1xuICAgICAgICBpZGVudGlmaWVyID0gbmFtZS5yaWdodCBhcyBJZGVudGlmaWVyV2l0aFN5bWJvbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkZW50aWZpZXIgPSBuYW1lIGFzIElkZW50aWZpZXJXaXRoU3ltYm9sO1xuICAgICAgfVxuICAgICAgbGV0IHN5bWJvbCA9IGlkZW50aWZpZXIuc3ltYm9sO1xuICAgICAgLy8gV2hlbiB3cml0aW5nIGEgc3ltYm9sLCBjaGVjayBpZiB0aGVyZSBpcyBhbiBhbGlhcyBmb3IgaXQgaW4gdGhlIGN1cnJlbnQgc2NvcGUgdGhhdCBzaG91bGRcbiAgICAgIC8vIHRha2UgcHJlY2VkZW5jZSwgZS5nLiBmcm9tIGEgZ29vZy5yZXF1aXJlVHlwZS5cbiAgICAgIGlmIChzeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgICBzeW1ib2wgPSB0aGlzLnR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltYm9sKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsaWFzID0gdGhpcy5zeW1ib2xzVG9BbGlhc2VkTmFtZXMuZ2V0KHN5bWJvbCk7XG4gICAgICBpZiAoYWxpYXMpIHtcbiAgICAgICAgLy8gSWYgc28sIGRpc2NhcmQgdGhlIGVudGlyZSBjdXJyZW50IHRleHQgYW5kIG9ubHkgdXNlIHRoZSBhbGlhcyAtIG90aGVyd2lzZSBpZiBhIHN5bWJvbCBoYXNcbiAgICAgICAgLy8gYSBsb2NhbCBhbGlhcyBidXQgYXBwZWFycyBpbiBhIGRvdHRlZCB0eXBlIHBhdGggKGUuZy4gd2hlbiBpdCdzIGltcG9ydGVkIHVzaW5nIGltcG9ydCAqXG4gICAgICAgIC8vIGFzIGZvbyksIHN0ciB3b3VsZCBjb250YWluIGJvdGggdGhlIHByZWZ4ICphbmQqIHRoZSBmdWxsIGFsaWFzIChmb28uYWxpYXMubmFtZSkuXG4gICAgICAgIHN0ciA9IGFsaWFzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0ID0gZ2V0SWRlbnRpZmllclRleHQoaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBtYW5nbGVkUHJlZml4ID0gdGhpcy5tYXliZUdldE1hbmdsZWROYW1lUHJlZml4KHN5bWJvbCk7XG4gICAgICAgIHRleHQgPSBtYW5nbGVkUHJlZml4ICsgdGV4dDtcbiAgICAgIH1cbiAgICAgIHN0ciArPSB0ZXh0O1xuICAgIH07XG4gICAgd3JpdGVFbnRpdHlXaXRoU3ltYm9scyhuYW1lKTtcbiAgICBzdHIgPSB0aGlzLnN0cmlwQ2x1dHpOYW1lc3BhY2Uoc3RyKTtcbiAgICB0aGlzLnN5bWJvbFRvTmFtZUNhY2hlLnNldChzeW0sIHN0cik7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYW5nbGVkIG5hbWUgcHJlZml4IGZvciBzeW1ib2wsIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBub3QgYXBwbGljYWJsZS5cbiAgICpcbiAgICogVHlwZSBuYW1lcyBhcmUgZW1pdHRlZCB3aXRoIGEgbWFuZ2xlZCBwcmVmaXggaWYgdGhleSBhcmUgdG9wIGxldmVsIHN5bWJvbHMgZGVjbGFyZWQgaW4gYW5cbiAgICogZXh0ZXJuYWwgbW9kdWxlICguZC50cyBvciAudHMpLCBhbmQgYXJlIGFtYmllbnQgZGVjbGFyYXRpb25zIChcImRlY2xhcmUgLi4uXCIpLiBUaGlzIGlzIGJlY2F1c2VcbiAgICogdGhlaXIgZGVjbGFyYXRpb25zIGdldCBtb3ZlZCB0byBleHRlcm5zIGZpbGVzICh0byBtYWtlIGV4dGVybmFsIG5hbWVzIHZpc2libGUgdG8gQ2xvc3VyZSBhbmRcbiAgICogcHJldmVudCByZW5hbWluZyksIHdoaWNoIG9ubHkgdXNlIGdsb2JhbCBuYW1lcy4gVGhpcyBtZWFucyB0aGUgbmFtZXMgbXVzdCBiZSBtYW5nbGVkIHRvIHByZXZlbnRcbiAgICogY29sbGlzaW9ucyBhbmQgYWxsb3cgcmVmZXJlbmNpbmcgdGhlbSB1bmlxdWVseS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYWxzbyBoYW5kbGVzIHRoZSBzcGVjaWFsIGNhc2Ugb2Ygc3ltYm9scyBkZWNsYXJlZCBpbiBhbiBhbWJpZW50IGV4dGVybmFsIG1vZHVsZVxuICAgKiBjb250ZXh0LlxuICAgKlxuICAgKiBTeW1ib2xzIGRlY2xhcmVkIGluIGEgZ2xvYmFsIGJsb2NrLCBlLmcuIFwiZGVjbGFyZSBnbG9iYWwgeyB0eXBlIFg7IH1cIiwgYXJlIGhhbmRsZWQgaW1wbGljaXRseTpcbiAgICogd2hlbiByZWZlcmVuY2VkLCB0aGV5IGFyZSB3cml0dGVuIGFzIGp1c3QgXCJYXCIsIHdoaWNoIGlzIG5vdCBhIHRvcCBsZXZlbCBkZWNsYXJhdGlvbiwgc28gdGhlXG4gICAqIGNvZGUgYmVsb3cgaWdub3JlcyB0aGVtLlxuICAgKi9cbiAgbWF5YmVHZXRNYW5nbGVkTmFtZVByZWZpeChzeW1ib2w6IHRzLlN5bWJvbCk6IHN0cmluZ3wnJyB7XG4gICAgaWYgKCFzeW1ib2wuZGVjbGFyYXRpb25zKSByZXR1cm4gJyc7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gc3ltYm9sLmRlY2xhcmF0aW9ucztcbiAgICBsZXQgYW1iaWVudE1vZHVsZURlY2xhcmF0aW9uOiBBbWJpZW50TW9kdWxlRGVjbGFyYXRpb258bnVsbCA9IG51bGw7XG4gICAgLy8gSWYgdGhlIHN5bWJvbCBpcyBuZWl0aGVyIGEgdG9wIGxldmVsIGRlY2xhcmF0aW9uIGluIGFuIGV4dGVybmFsIG1vZHVsZSBub3IgaW4gYW4gYW1iaWVudFxuICAgIC8vIGJsb2NrLCB0c2lja2xlIHNob3VsZCBub3QgZW1pdCBhIHByZWZpeDogaXQncyBlaXRoZXIgbm90IGFuIGV4dGVybmFsIHN5bWJvbCwgb3IgaXQncyBhblxuICAgIC8vIGV4dGVybmFsIHN5bWJvbCBuZXN0ZWQgaW4gYSBtb2R1bGUsIHNvIGl0IHdpbGwgbmVlZCB0byBiZSBxdWFsaWZpZWQsIGFuZCB0aGUgbWFuZ2xpbmcgcHJlZml4XG4gICAgLy8gZ29lcyBvbiB0aGUgcXVhbGlmaWVyLlxuICAgIGlmICghaXNUb3BMZXZlbEV4dGVybmFsKGRlY2xhcmF0aW9ucykpIHtcbiAgICAgIGFtYmllbnRNb2R1bGVEZWNsYXJhdGlvbiA9IGdldENvbnRhaW5pbmdBbWJpZW50TW9kdWxlRGVjbGFyYXRpb24oZGVjbGFyYXRpb25zKTtcbiAgICAgIGlmICghYW1iaWVudE1vZHVsZURlY2xhcmF0aW9uKSByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBkZWNsYXJhdGlvbiBpcyBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSAocG9zc2libHkgYW1iaWVudCkuXG4gICAgLy8gVGhlc2UgZGVjbGFyYXRpb25zIG11c3QgYmUgcHJlZml4ZWQgaWYgZWl0aGVyOlxuICAgIC8vIChhKSB0c2lja2xlIGlzIGVtaXR0aW5nIGFuIGV4dGVybnMgZmlsZSwgc28gYWxsIHN5bWJvbHMgYXJlIHF1YWxpZmllZCB3aXRoaW4gaXRcbiAgICAvLyAoYikgb3IgdGhlIGRlY2xhcmF0aW9uIG11c3QgYmUgYW4gZXhwb3J0ZWQgYW1iaWVudCBkZWNsYXJhdGlvbiBmcm9tIHRoZSBsb2NhbCBmaWxlLlxuICAgIC8vIEFtYmllbnQgZXh0ZXJuYWwgZGVjbGFyYXRpb25zIGZyb20gb3RoZXIgZmlsZXMgYXJlIGltcG9ydGVkLCBzbyB0aGVyZSdzIGEgbG9jYWwgYWxpYXMgZm9yIHRoZVxuICAgIC8vIG1vZHVsZSBhbmQgbm8gbWFuZ2xpbmcgaXMgbmVlZGVkLlxuICAgIGlmICghdGhpcy5pc0ZvckV4dGVybnMgJiZcbiAgICAgICAgIWRlY2xhcmF0aW9ucy5ldmVyeShcbiAgICAgICAgICAgIGQgPT4gaXNEZWNsYXJlZEluU2FtZUZpbGUodGhpcy5ub2RlLCBkKSAmJiBpc0FtYmllbnQoZCkgJiZcbiAgICAgICAgICAgICAgICBoYXNNb2RpZmllckZsYWcoZCwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBJZiBmcm9tIGFuIGFtYmllbnQgZGVjbGFyYXRpb24sIHVzZSBhbmQgcmVzb2x2ZSB0aGUgbmFtZSBmcm9tIHRoYXQuIE90aGVyd2lzZSwgdXNlIHRoZSBmaWxlXG4gICAgLy8gbmFtZSBmcm9tIHRoZSAoYXJiaXRyYXJ5KSBmaXJzdCBkZWNsYXJhdGlvbiB0byBtYW5nbGUuXG4gICAgY29uc3QgZmlsZU5hbWUgPSBhbWJpZW50TW9kdWxlRGVjbGFyYXRpb24gP1xuICAgICAgICBhbWJpZW50TW9kdWxlRGVjbGFyYXRpb24ubmFtZS50ZXh0IDpcbiAgICAgICAgdHMuZ2V0T3JpZ2luYWxOb2RlKGRlY2xhcmF0aW9uc1swXSkuZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lO1xuICAgIGNvbnN0IG1hbmdsZWQgPSBtb2R1bGVOYW1lQXNJZGVudGlmaWVyKHRoaXMuaG9zdCwgZmlsZU5hbWUpO1xuICAgIHJldHVybiBtYW5nbGVkICsgJy4nO1xuICB9XG5cbiAgLy8gQ2x1dHogKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NsdXR6KSBlbWl0cyBnbG9iYWwgdHlwZSBzeW1ib2xzIGhpZGRlbiBpbiBhIHNwZWNpYWxcbiAgLy8g4LKgX+CyoC5jbHV0eiBuYW1lc3BhY2UuIFdoaWxlIG1vc3QgY29kZSBzZWVuIGJ5IFRzaWNrbGUgd2lsbCBvbmx5IGV2ZXIgc2VlIGxvY2FsIGFsaWFzZXMsIENsdXR6XG4gIC8vIHN5bWJvbHMgY2FuIGJlIHdyaXR0ZW4gYnkgdXNlcnMgZGlyZWN0bHkgaW4gY29kZSwgYW5kIHRoZXkgY2FuIGFwcGVhciBieSBkZXJlZmVyZW5jaW5nXG4gIC8vIFR5cGVBbGlhc2VzLiBUaGUgY29kZSBiZWxvdyBzaW1wbHkgc3RyaXBzIHRoZSBwcmVmaXgsIHRoZSByZW1haW5pbmcgdHlwZSBuYW1lIHRoZW4gbWF0Y2hlc1xuICAvLyBDbG9zdXJlJ3MgdHlwZS5cbiAgcHJpdmF0ZSBzdHJpcENsdXR6TmFtZXNwYWNlKG5hbWU6IHN0cmluZykge1xuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ+CyoF/gsqAuY2x1dHouJykpIHJldHVybiBuYW1lLnN1YnN0cmluZygn4LKgX+CyoC5jbHV0ei4nLmxlbmd0aCk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICB0cmFuc2xhdGUodHlwZTogdHMuVHlwZSk6IHN0cmluZyB7XG4gICAgLy8gTk9URTogVGhvdWdoIHR5cGUuZmxhZ3MgaGFzIHRoZSBuYW1lIFwiZmxhZ3NcIiwgaXQgdXN1YWxseSBjYW4gb25seSBiZSBvbmVcbiAgICAvLyBvZiB0aGUgZW51bSBvcHRpb25zIGF0IGEgdGltZSAoZXhjZXB0IGZvciB1bmlvbnMgb2YgbGl0ZXJhbCB0eXBlcywgZS5nLiB1bmlvbnMgb2YgYm9vbGVhblxuICAgIC8vIHZhbHVlcywgc3RyaW5nIHZhbHVlcywgZW51bSB2YWx1ZXMpLiBUaGlzIHN3aXRjaCBoYW5kbGVzIGFsbCB0aGUgY2FzZXMgaW4gdGhlIHRzLlR5cGVGbGFnc1xuICAgIC8vIGVudW0gaW4gdGhlIG9yZGVyIHRoZXkgb2NjdXIuXG5cbiAgICAvLyBOT1RFOiBTb21lIFR5cGVGbGFncyBhcmUgbWFya2VkIFwiaW50ZXJuYWxcIiBpbiB0aGUgZC50cyBidXQgc3RpbGwgc2hvdyB1cCBpbiB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0eXBlLmZsYWdzLiBUaGlzIG1hc2sgbGltaXRzIHRoZSBmbGFnIGNoZWNrcyB0byB0aGUgb25lcyBpbiB0aGUgcHVibGljIEFQSS4gXCJsYXN0RmxhZ1wiIGhlcmVcbiAgICAvLyBpcyB0aGUgbGFzdCBmbGFnIGhhbmRsZWQgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCBhbmQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoXG4gICAgLy8gdHlwZXNjcmlwdC5kLnRzLlxuXG4gICAgLy8gTm9uUHJpbWl0aXZlIG9jY3VycyBvbiBpdHMgb3duIG9uIHRoZSBsb3dlciBjYXNlIFwib2JqZWN0XCIgdHlwZS4gU3BlY2lhbCBjYXNlIHRvIFwiIU9iamVjdFwiLlxuICAgIGlmICh0eXBlLmZsYWdzID09PSB0cy5UeXBlRmxhZ3MuTm9uUHJpbWl0aXZlKSByZXR1cm4gJyFPYmplY3QnO1xuXG4gICAgLy8gQXZvaWQgaW5maW5pdGUgbG9vcHMgb24gcmVjdXJzaXZlIHR5cGUgbGl0ZXJhbHMuXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSB0byBqdXN0IGVtaXQgdGhlIG5hbWUgb2YgdGhlIHJlY3Vyc2l2ZSB0eXBlIGhlcmUgKGluIHR5cGUuYWxpYXNTeW1ib2xcbiAgICAvLyBiZWxvdyksIGJ1dCBDbG9zdXJlIENvbXBpbGVyIGRvZXMgbm90IGFsbG93IHJlY3Vyc2l2ZSB0eXBlIGRlZmluaXRpb25zLlxuICAgIGlmICh0aGlzLnNlZW5Bbm9ueW1vdXNUeXBlcy5oYXModHlwZSkpIHJldHVybiAnPyc7XG5cbiAgICBsZXQgaXNBbWJpZW50ID0gZmFsc2U7XG4gICAgbGV0IGlzSW5OYW1lc3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgaXNNb2R1bGUgPSBmYWxzZTtcbiAgICBpZiAodHlwZS5zeW1ib2wpIHtcbiAgICAgIGZvciAoY29uc3QgZGVjbCBvZiB0eXBlLnN5bWJvbC5kZWNsYXJhdGlvbnMgfHwgW10pIHtcbiAgICAgICAgaWYgKHRzLmlzRXh0ZXJuYWxNb2R1bGUoZGVjbC5nZXRTb3VyY2VGaWxlKCkpKSBpc01vZHVsZSA9IHRydWU7XG4gICAgICAgIGlmIChkZWNsLmdldFNvdXJjZUZpbGUoKS5pc0RlY2xhcmF0aW9uRmlsZSkgaXNBbWJpZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQ6IHRzLkRlY2xhcmF0aW9ufHVuZGVmaW5lZCA9IGRlY2w7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgaWYgKHRzLmdldENvbWJpbmVkTW9kaWZpZXJGbGFncyhjdXJyZW50KSAmIHRzLk1vZGlmaWVyRmxhZ3MuQW1iaWVudCkgaXNBbWJpZW50ID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoY3VycmVudC5raW5kID09PSB0cy5TeW50YXhLaW5kLk1vZHVsZURlY2xhcmF0aW9uKSBpc0luTmFtZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQgYXMgdHMuRGVjbGFyYXRpb24gfCB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0c2lja2xlIGNhbm5vdCBnZW5lcmF0ZSB0eXBlcyBmb3Igbm9uLWFtYmllbnQgbmFtZXNwYWNlcyBub3IgYW55IHN5bWJvbHMgY29udGFpbmVkIGluIHRoZW0uXG4gICAgaWYgKGlzSW5OYW1lc3BhY2UgJiYgIWlzQW1iaWVudCkgcmV0dXJuICc/JztcblxuICAgIC8vIFR5cGVzIGluIGV4dGVybnMgY2Fubm90IHJlZmVyZW5jZSB0eXBlcyBmcm9tIGV4dGVybmFsIG1vZHVsZXMuXG4gICAgLy8gSG93ZXZlciBhbWJpZW50IHR5cGVzIGluIG1vZHVsZXMgZ2V0IG1vdmVkIHRvIGV4dGVybnMsIHRvbywgc28gdHlwZSByZWZlcmVuY2VzIHdvcmsgYW5kIHdlXG4gICAgLy8gY2FuIGVtaXQgYSBwcmVjaXNlIHR5cGUuXG4gICAgaWYgKHRoaXMuaXNGb3JFeHRlcm5zICYmIGlzTW9kdWxlICYmICFpc0FtYmllbnQpIHJldHVybiAnPyc7XG5cbiAgICBjb25zdCBsYXN0RmxhZyA9IHRzLlR5cGVGbGFncy5TdWJzdGl0dXRpb247XG4gICAgY29uc3QgbWFzayA9IChsYXN0RmxhZyA8PCAxKSAtIDE7XG4gICAgc3dpdGNoICh0eXBlLmZsYWdzICYgbWFzaykge1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuQW55OlxuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuVW5rbm93bjpcbiAgICAgICAgcmV0dXJuICcqJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlN0cmluZzpcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlN0cmluZ0xpdGVyYWw6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLk51bWJlcjpcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLk51bWJlckxpdGVyYWw6XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkJvb2xlYW46XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5Cb29sZWFuTGl0ZXJhbDpcbiAgICAgICAgLy8gU2VlIHRoZSBub3RlIGluIHRyYW5zbGF0ZVVuaW9uIGFib3V0IGJvb2xlYW5zLlxuICAgICAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuRW51bTpcbiAgICAgICAgaWYgKCF0eXBlLnN5bWJvbCkge1xuICAgICAgICAgIHRoaXMud2FybihgRW51bVR5cGUgd2l0aG91dCBhIHN5bWJvbGApO1xuICAgICAgICAgIHJldHVybiAnPyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sVG9TdHJpbmcodHlwZS5zeW1ib2wpIHx8ICc/JztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkVTU3ltYm9sOlxuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuVW5pcXVlRVNTeW1ib2w6XG4gICAgICAgIC8vIEVTU3ltYm9sIGluZGljYXRlcyBzb21ldGhpbmcgdHlwZWQgc3ltYm9sLlxuICAgICAgICAvLyBVbmlxdWVFU1N5bWJvbCBpbmRpY2F0ZXMgYSBzcGVjaWZpYyB1bmlxdWUgc3ltYm9sLCB1c2VkIGUuZy4gdG8gaW5kZXggaW50byBhbiBvYmplY3QuXG4gICAgICAgIC8vIENsb3N1cmUgZG9lcyBub3QgaGF2ZSB0aGlzIGRpc3RpbmN0aW9uLCBzbyB0c2lja2xlIGVtaXRzIGJvdGggYXMgJ3N5bWJvbCcuXG4gICAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlZvaWQ6XG4gICAgICAgIHJldHVybiAndm9pZCc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5VbmRlZmluZWQ6XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkJpZ0ludDpcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkJpZ0ludExpdGVyYWw6XG4gICAgICAgIHJldHVybiAnYmlnaW50UGxhY2Vob2xkZXInO1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuTnVsbDpcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLk5ldmVyOlxuICAgICAgICB0aGlzLndhcm4oYHNob3VsZCBub3QgZW1pdCBhICduZXZlcicgdHlwZWApO1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuVHlwZVBhcmFtZXRlcjpcbiAgICAgICAgLy8gVGhpcyBpcyBlLmcuIHRoZSBUIGluIGEgdHlwZSBsaWtlIEZvbzxUPi5cbiAgICAgICAgaWYgKCF0eXBlLnN5bWJvbCkge1xuICAgICAgICAgIHRoaXMud2FybihgVHlwZVBhcmFtZXRlciB3aXRob3V0IGEgc3ltYm9sYCk7ICAvLyBzaG91bGQgbm90IGhhcHBlbiAodG0pXG4gICAgICAgICAgcmV0dXJuICc/JztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBDbG9zdXJlLCB0eXBlIHBhcmFtZXRlcnMgKFwiPFQ+XCIpIGFyZSBub24tbnVsbGFibGUgYnkgZGVmYXVsdCwgdW5saWtlIHJlZmVyZW5jZXMgdG9cbiAgICAgICAgLy8gY2xhc3NlcyBvciBpbnRlcmZhY2VzLiBIb3dldmVyIHRoaXMgY29kZSBwYXRoIGNhbiBiZSByZWFjaGVkIGJ5IGJvdW5kIHR5cGUgcGFyYW1ldGVycyxcbiAgICAgICAgLy8gd2hlcmUgdGhlIHR5cGUgcGFyYW1ldGVyJ3Mgc3ltYm9sIHJlZmVyZW5jZXMgYSBwbGFpbiBjbGFzcyBvciBpbnRlcmZhY2UuIEluIHRoaXMgY2FzZSxcbiAgICAgICAgLy8gYWRkIGAhYCB0byBhdm9pZCBlbWl0dGluZyBhIG51bGxhYmxlIHR5cGUuXG4gICAgICAgIGxldCBwcmVmaXggPSAnJztcbiAgICAgICAgaWYgKCh0eXBlLnN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlR5cGVQYXJhbWV0ZXIpID09PSAwKSB7XG4gICAgICAgICAgcHJlZml4ID0gJyEnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnN5bWJvbFRvU3RyaW5nKHR5cGUuc3ltYm9sKTtcbiAgICAgICAgaWYgKCFuYW1lKSByZXR1cm4gJz8nO1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgbmFtZTtcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLk9iamVjdDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT2JqZWN0KHR5cGUgYXMgdHMuT2JqZWN0VHlwZSk7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5VbmlvbjpcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVW5pb24odHlwZSBhcyB0cy5VbmlvblR5cGUpO1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuQ29uZGl0aW9uYWw6XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5TdWJzdGl0dXRpb246XG4gICAgICAgIHRoaXMud2FybihgZW1pdHRpbmcgPyBmb3IgY29uZGl0aW9uYWwvc3Vic3RpdHV0aW9uIHR5cGVgKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkludGVyc2VjdGlvbjpcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkluZGV4OlxuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuSW5kZXhlZEFjY2VzczpcbiAgICAgICAgLy8gVE9ETyh0czIuMSk6IGhhbmRsZSB0aGVzZSBzcGVjaWFsIHR5cGVzLlxuICAgICAgICB0aGlzLndhcm4oYHVuaGFuZGxlZCB0eXBlIGZsYWdzOiAke3RzLlR5cGVGbGFnc1t0eXBlLmZsYWdzXX1gKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlcyB3aGVyZSBtdWx0aXBsZSBmbGFncyBhcmUgc2V0LlxuXG4gICAgICAgIC8vIFR5cGVzIHdpdGggbGl0ZXJhbCBtZW1iZXJzIGFyZSByZXByZXNlbnRlZCBhc1xuICAgICAgICAvLyAgIHRzLlR5cGVGbGFncy5VbmlvbiB8IFtsaXRlcmFsIG1lbWJlcl1cbiAgICAgICAgLy8gRS5nLiBhbiBlbnVtIHR5cGVkIHZhbHVlIGlzIGEgdW5pb24gdHlwZSB3aXRoIHRoZSBlbnVtJ3MgbWVtYmVycyBhcyBpdHMgbWVtYmVycy4gQVxuICAgICAgICAvLyBib29sZWFuIHR5cGUgaXMgYSB1bmlvbiB0eXBlIHdpdGggJ3RydWUnIGFuZCAnZmFsc2UnIGFzIGl0cyBtZW1iZXJzLlxuICAgICAgICAvLyBOb3RlIGFsc28gdGhhdCBpbiBhIG1vcmUgY29tcGxleCB1bmlvbiwgZS5nLiBib29sZWFufG51bWJlciwgdGhlbiBpdCdzIGEgdW5pb24gb2YgdGhyZWVcbiAgICAgICAgLy8gdGhpbmdzICh0cnVlfGZhbHNlfG51bWJlcikgYW5kIHRzLlR5cGVGbGFncy5Cb29sZWFuIGRvZXNuJ3Qgc2hvdyB1cCBhdCBhbGwuXG4gICAgICAgIGlmICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLlVuaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVW5pb24odHlwZSBhcyB0cy5VbmlvblR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUuZmxhZ3MgJiB0cy5UeXBlRmxhZ3MuRW51bUxpdGVyYWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVFbnVtTGl0ZXJhbCh0eXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBzd2l0Y2ggc3RhdGVtZW50IHNob3VsZCBoYXZlIGJlZW4gZXhoYXVzdGl2ZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGUgZmxhZ3MgJHt0eXBlLmZsYWdzfSBvbiAke3R5cGVUb0RlYnVnU3RyaW5nKHR5cGUpfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNsYXRlVW5pb24odHlwZTogdHMuVW5pb25UeXBlKTogc3RyaW5nIHtcbiAgICAvLyBVbmlvbiB0eXBlcyB0aGF0IGluY2x1ZGUgbGl0ZXJhbHMgKGUuZy4gYm9vbGVhbiwgZW51bSkgY2FuIGVuZCB1cCByZXBlYXRpbmcgdGhlIHNhbWUgQ2xvc3VyZVxuICAgIC8vIHR5cGUuIEZvciBleGFtcGxlOiB0cnVlIHwgYm9vbGVhbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gYm9vbGVhbiB8IGJvb2xlYW4uXG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXMgdG8gcHJvZHVjZSB0eXBlcyB0aGF0IHJlYWQgYmV0dGVyLlxuICAgIGNvbnN0IHBhcnRzID0gbmV3IFNldCh0eXBlLnR5cGVzLm1hcCh0ID0+IHRoaXMudHJhbnNsYXRlKHQpKSk7XG4gICAgLy8gSWYgaXQncyBhIHNpbmdsZSBlbGVtZW50IHNldCwgcmV0dXJuIHRoZSBzaW5nbGUgbWVtYmVyLlxuICAgIGlmIChwYXJ0cy5zaXplID09PSAxKSByZXR1cm4gcGFydHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgIHJldHVybiBgKCR7QXJyYXkuZnJvbShwYXJ0cy52YWx1ZXMoKSkuam9pbignfCcpfSlgO1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2xhdGVFbnVtTGl0ZXJhbCh0eXBlOiB0cy5UeXBlKTogc3RyaW5nIHtcbiAgICAvLyBTdXBwb3NlIHlvdSBoYWQ6XG4gICAgLy8gICBlbnVtIEVudW1UeXBlIHsgTUVNQkVSIH1cbiAgICAvLyB0aGVuIHRoZSB0eXBlIG9mIFwiRW51bVR5cGUuTUVNQkVSXCIgaXMgYW4gZW51bSBsaXRlcmFsICh0aGUgdGhpbmcgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24pXG4gICAgLy8gYW5kIGl0IGhhcyB0eXBlIGZsYWdzIHRoYXQgaW5jbHVkZVxuICAgIC8vICAgdHMuVHlwZUZsYWdzLk51bWJlckxpdGVyYWwgfCB0cy5UeXBlRmxhZ3MuRW51bUxpdGVyYWxcbiAgICAvL1xuICAgIC8vIENsb3N1cmUgQ29tcGlsZXIgZG9lc24ndCBzdXBwb3J0IGxpdGVyYWxzIGluIHR5cGVzLCBzbyB0aGlzIGNvZGUgbXVzdCBub3QgZW1pdFxuICAgIC8vIFwiRW51bVR5cGUuTUVNQkVSXCIsIGJ1dCByYXRoZXIgXCJFbnVtVHlwZVwiLlxuXG4gICAgY29uc3QgZW51bUxpdGVyYWxCYXNlVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QmFzZVR5cGVPZkxpdGVyYWxUeXBlKHR5cGUpO1xuICAgIGlmICghZW51bUxpdGVyYWxCYXNlVHlwZS5zeW1ib2wpIHtcbiAgICAgIHRoaXMud2FybihgRW51bUxpdGVyYWxUeXBlIHdpdGhvdXQgYSBzeW1ib2xgKTtcbiAgICAgIHJldHVybiAnPyc7XG4gICAgfVxuICAgIGxldCBzeW1ib2wgPSBlbnVtTGl0ZXJhbEJhc2VUeXBlLnN5bWJvbDtcbiAgICBpZiAoZW51bUxpdGVyYWxCYXNlVHlwZSA9PT0gdHlwZSkge1xuICAgICAgLy8gVHlwZVNjcmlwdCdzIEFQSSB3aWxsIHJldHVybiB0aGUgc2FtZSBFbnVtTGl0ZXJhbCB0eXBlIGlmIHRoZSBlbnVtIG9ubHkgaGFzIGEgc2luZ2xlIG1lbWJlclxuICAgICAgLy8gdmFsdWUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI4ODY5LlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0YWtlIHRoZSBwYXJlbnQgc3ltYm9sIG9mIHRoZSBlbnVtIG1lbWJlciwgd2hpY2ggc2hvdWxkIGJlIHRoZSBlbnVtXG4gICAgICAvLyBkZWNsYXJhdGlvbi5cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgd29ya2luZyBhcm91bmQgYSBUUyBBUEkgZGVmaWNpZW5jeS5cbiAgICAgIGNvbnN0IHBhcmVudDogdHMuU3ltYm9sfHVuZGVmaW5lZCA9IChzeW1ib2wgYXMgYW55KVsncGFyZW50J107XG4gICAgICBpZiAoIXBhcmVudCkgcmV0dXJuICc/JztcbiAgICAgIHN5bWJvbCA9IHBhcmVudDtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuc3ltYm9sVG9TdHJpbmcoc3ltYm9sKTtcbiAgICBpZiAoIW5hbWUpIHJldHVybiAnPyc7XG4gICAgLy8gSW4gQ2xvc3VyZSwgZW51bSB0eXBlcyBhcmUgbm9uLW51bGwgYnkgZGVmYXVsdCwgc28gd2Ugd291bGRuJ3QgbmVlZCB0byBlbWl0IHRoZSBgIWAgaGVyZS5cbiAgICAvLyBIb3dldmVyIHRoYXQncyBjb25mdXNpbmcgdG8gdXNlcnMsIHRvIHRoZSBwb2ludCB0aGF0IHN0eWxlIGd1aWRlcyBhbmQgbGludGVycyByZXF1aXJlIHRvXG4gICAgLy8gKmFsd2F5cyogc3BlY2lmeSB0aGUgbnVsbGFiaWxpdHkgbW9kaWZpZXIuIFRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGF0IHN0eWxlLCBpbmNsdWRlIGl0IGhlcmVcbiAgICAvLyBhcyB3ZWxsLlxuICAgIHJldHVybiAnIScgKyBuYW1lO1xuICB9XG5cbiAgLy8gdHJhbnNsYXRlT2JqZWN0IHRyYW5zbGF0ZXMgYSB0cy5PYmplY3RUeXBlLCB3aGljaCBpcyB0aGUgdHlwZSBvZiBhbGxcbiAgLy8gb2JqZWN0LWxpa2UgdGhpbmdzIGluIFRTLCBzdWNoIGFzIGNsYXNzZXMgYW5kIGludGVyZmFjZXMuXG4gIHByaXZhdGUgdHJhbnNsYXRlT2JqZWN0KHR5cGU6IHRzLk9iamVjdFR5cGUpOiBzdHJpbmcge1xuICAgIGlmICh0eXBlLnN5bWJvbCAmJiB0aGlzLmlzQmxhY2tMaXN0ZWQodHlwZS5zeW1ib2wpKSByZXR1cm4gJz8nO1xuXG4gICAgLy8gTk9URTogb2JqZWN0RmxhZ3MgaXMgYW4gZW51bSwgYnV0IGEgZ2l2ZW4gdHlwZSBjYW4gaGF2ZSBtdWx0aXBsZSBmbGFncy5cbiAgICAvLyBBcnJheTxzdHJpbmc+IGlzIGJvdGggdHMuT2JqZWN0RmxhZ3MuUmVmZXJlbmNlIGFuZCB0cy5PYmplY3RGbGFncy5JbnRlcmZhY2UuXG5cbiAgICBpZiAodHlwZS5vYmplY3RGbGFncyAmIHRzLk9iamVjdEZsYWdzLkNsYXNzKSB7XG4gICAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICAgIHRoaXMud2FybignY2xhc3MgaGFzIG5vIHN5bWJvbCcpO1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IHRoaXMuc3ltYm9sVG9TdHJpbmcodHlwZS5zeW1ib2wpO1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIC8vIEFuIGFub255bW91cyB0eXBlLiBNYWtlIHN1cmUgbm90IHRvIGVtaXQgJyE/JywgYXMgdGhhdCBpcyBhIHN5bnRheCBlcnJvciBpbiBDbG9zdXJlXG4gICAgICAgIC8vIENvbXBpbGVyLlxuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICchJyArIG5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlLm9iamVjdEZsYWdzICYgdHMuT2JqZWN0RmxhZ3MuSW50ZXJmYWNlKSB7XG4gICAgICAvLyBOb3RlOiB0cy5JbnRlcmZhY2VUeXBlIGhhcyBhIHR5cGVQYXJhbWV0ZXJzIGZpZWxkLCBidXQgdGhhdFxuICAgICAgLy8gc3BlY2lmaWVzIHRoZSBwYXJhbWV0ZXJzIHRoYXQgdGhlIGludGVyZmFjZSB0eXBlICpleHBlY3RzKlxuICAgICAgLy8gd2hlbiBpdCdzIHVzZWQsIGFuZCBzaG91bGQgbm90IGJlIHRyYW5zZm9ybWVkIHRvIHRoZSBvdXRwdXQuXG4gICAgICAvLyBFLmcuIGEgdHlwZSBsaWtlIEFycmF5PG51bWJlcj4gaXMgYSBUeXBlUmVmZXJlbmNlIHRvIHRoZVxuICAgICAgLy8gSW50ZXJmYWNlVHlwZSBcIkFycmF5XCIsIGJ1dCB0aGUgXCJudW1iZXJcIiB0eXBlIHBhcmFtZXRlciBpc1xuICAgICAgLy8gcGFydCBvZiB0aGUgb3V0ZXIgVHlwZVJlZmVyZW5jZSwgbm90IGEgdHlwZVBhcmFtZXRlciBvblxuICAgICAgLy8gdGhlIEludGVyZmFjZVR5cGUuXG4gICAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICAgIHRoaXMud2FybignaW50ZXJmYWNlIGhhcyBubyBzeW1ib2wnKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlLnN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSB7XG4gICAgICAgIC8vIFRoZSBzeW1ib2wgaXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUuXG4gICAgICAgIC8vIEZvciB1c2VyLWRlZmluZWQgdHlwZXMgaW4gdGhpcyBzdGF0ZSwgd2UgbWF5IG5vdCBoYXZlIGEgQ2xvc3VyZSBuYW1lXG4gICAgICAgIC8vIGZvciB0aGUgdHlwZS4gIFNlZSB0aGUgdHlwZV9hbmRfdmFsdWUgdGVzdC5cbiAgICAgICAgaWYgKCF0eXBlVmFsdWVDb25mbGljdEhhbmRsZWQodHlwZS5zeW1ib2wpKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGB0eXBlL3N5bWJvbCBjb25mbGljdCBmb3IgJHt0eXBlLnN5bWJvbC5uYW1lfSwgdXNpbmcgez99IGZvciBub3dgKTtcbiAgICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyEnICsgdGhpcy5zeW1ib2xUb1N0cmluZyh0eXBlLnN5bWJvbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLm9iamVjdEZsYWdzICYgdHMuT2JqZWN0RmxhZ3MuUmVmZXJlbmNlKSB7XG4gICAgICAvLyBBIHJlZmVyZW5jZSB0byBhbm90aGVyIHR5cGUsIGUuZy4gQXJyYXk8bnVtYmVyPiByZWZlcnMgdG8gQXJyYXkuXG4gICAgICAvLyBFbWl0IHRoZSByZWZlcmVuY2VkIHR5cGUgYW5kIGFueSB0eXBlIGFyZ3VtZW50cy5cbiAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSB0eXBlIGFzIHRzLlR5cGVSZWZlcmVuY2U7XG5cbiAgICAgIC8vIEEgdHVwbGUgaXMgYSBSZWZlcmVuY2VUeXBlIHdoZXJlIHRoZSB0YXJnZXQgaXMgZmxhZ2dlZCBUdXBsZSBhbmQgdGhlXG4gICAgICAvLyB0eXBlQXJndW1lbnRzIGFyZSB0aGUgdHVwbGUgYXJndW1lbnRzLiAgSnVzdCB0cmVhdCBpdCBhcyBhIG15c3RlcnlcbiAgICAgIC8vIGFycmF5LCBiZWNhdXNlIENsb3N1cmUgZG9lc24ndCB1bmRlcnN0YW5kIHR1cGxlcy5cbiAgICAgIGlmIChyZWZlcmVuY2VUeXBlLnRhcmdldC5vYmplY3RGbGFncyAmIHRzLk9iamVjdEZsYWdzLlR1cGxlKSB7XG4gICAgICAgIHJldHVybiAnIUFycmF5PD8+JztcbiAgICAgIH1cblxuICAgICAgbGV0IHR5cGVTdHIgPSAnJztcbiAgICAgIGlmIChyZWZlcmVuY2VUeXBlLnRhcmdldCA9PT0gcmVmZXJlbmNlVHlwZSkge1xuICAgICAgICAvLyBXZSBnZXQgaW50byBhbiBpbmZpbml0ZSBsb29wIGhlcmUgaWYgdGhlIGlubmVyIHJlZmVyZW5jZSBpc1xuICAgICAgICAvLyB0aGUgc2FtZSBhcyB0aGUgb3V0ZXI7IHRoaXMgY2FuIG9jY3VyIHdoZW4gdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyBmYWlscyB0byB0cmFuc2xhdGUgYSBtb3JlIHNwZWNpZmljIHR5cGUgYmVmb3JlIGdldHRpbmcgdG9cbiAgICAgICAgLy8gdGhpcyBwb2ludC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYHJlZmVyZW5jZSBsb29wIGluICR7dHlwZVRvRGVidWdTdHJpbmcocmVmZXJlbmNlVHlwZSl9ICR7cmVmZXJlbmNlVHlwZS5mbGFnc31gKTtcbiAgICAgIH1cbiAgICAgIHR5cGVTdHIgKz0gdGhpcy50cmFuc2xhdGUocmVmZXJlbmNlVHlwZS50YXJnZXQpO1xuICAgICAgLy8gVHJhbnNsYXRlIGNhbiByZXR1cm4gJz8nIGZvciBhIG51bWJlciBvZiBzaXR1YXRpb25zLCBlLmcuIHR5cGUvdmFsdWUgY29uZmxpY3RzLlxuICAgICAgLy8gYD88Pz5gIGlzIGlsbGVnYWwgc3ludGF4IGluIENsb3N1cmUgQ29tcGlsZXIsIHNvIGp1c3QgcmV0dXJuIGA/YCBoZXJlLlxuICAgICAgaWYgKHR5cGVTdHIgPT09ICc/JykgcmV0dXJuICc/JztcbiAgICAgIGNvbnN0IHR5cGVBcmdzID0gdGhpcy50eXBlQ2hlY2tlci5nZXRUeXBlQXJndW1lbnRzKHJlZmVyZW5jZVR5cGUpO1xuICAgICAgaWYgKHR5cGVBcmdzKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHR5cGVBcmdzLm1hcCh0ID0+IHRoaXMudHJhbnNsYXRlKHQpKTtcbiAgICAgICAgdHlwZVN0ciArPSBgPCR7cGFyYW1zLmpvaW4oJywgJyl9PmA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVN0cjtcbiAgICB9IGVsc2UgaWYgKHR5cGUub2JqZWN0RmxhZ3MgJiB0cy5PYmplY3RGbGFncy5Bbm9ueW1vdXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZUFub255bW91c1R5cGUodHlwZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICBUT0RPKHRzMi4xKTogbW9yZSB1bmhhbmRsZWQgb2JqZWN0IHR5cGUgZmxhZ3M6XG4gICAgICBUdXBsZVxuICAgICAgTWFwcGVkXG4gICAgICBJbnN0YW50aWF0ZWRcbiAgICAgIE9iamVjdExpdGVyYWxcbiAgICAgIEV2b2x2aW5nQXJyYXlcbiAgICAgIE9iamVjdExpdGVyYWxQYXR0ZXJuV2l0aENvbXB1dGVkUHJvcGVydGllc1xuICAgICovXG4gICAgdGhpcy53YXJuKGB1bmhhbmRsZWQgdHlwZSAke3R5cGVUb0RlYnVnU3RyaW5nKHR5cGUpfWApO1xuICAgIHJldHVybiAnPyc7XG4gIH1cblxuICAvKipcbiAgICogdHJhbnNsYXRlQW5vbnltb3VzVHlwZSB0cmFuc2xhdGVzIGEgdHMuVHlwZUZsYWdzLk9iamVjdFR5cGUgdGhhdCBpcyBhbHNvXG4gICAqIHRzLk9iamVjdEZsYWdzLkFub255bW91cy4gVGhhdCBpcywgdGhpcyB0eXBlJ3Mgc3ltYm9sIGRvZXMgbm90IGhhdmUgYSBuYW1lLiBUaGlzIGlzIHRoZVxuICAgKiBhbm9ueW1vdXMgdHlwZSBlbmNvdW50ZXJlZCBpbiBlLmcuXG4gICAqICAgICBsZXQgeDoge2E6IG51bWJlcn07XG4gICAqIEJ1dCBhbHNvIHRoZSBpbmZlcnJlZCB0eXBlIGluOlxuICAgKiAgICAgbGV0IHggPSB7YTogMX07ICAvLyB0eXBlIG9mIHggaXMge2E6IG51bWJlcn0sIGFzIGFib3ZlXG4gICAqL1xuICBwcml2YXRlIHRyYW5zbGF0ZUFub255bW91c1R5cGUodHlwZTogdHMuVHlwZSk6IHN0cmluZyB7XG4gICAgdGhpcy5zZWVuQW5vbnltb3VzVHlwZXMuYWRkKHR5cGUpO1xuICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgIC8vIFRoaXMgY29tZXMgdXAgd2hlbiBnZW5lcmF0aW5nIGNvZGUgZm9yIGFuIGFycm93IGZ1bmN0aW9uIGFzIHBhc3NlZFxuICAgICAgLy8gdG8gYSBnZW5lcmljIGZ1bmN0aW9uLiAgVGhlIHBhc3NlZC1pbiB0eXBlIGlzIHRhZ2dlZCBhcyBhbm9ueW1vdXNcbiAgICAgIC8vIGFuZCBoYXMgbm8gcHJvcGVydGllcyBzbyBpdCdzIGhhcmQgdG8gZmlndXJlIG91dCB3aGF0IHRvIGdlbmVyYXRlLlxuICAgICAgLy8gSnVzdCBhdm9pZCBpdCBmb3Igbm93IHNvIHdlIGRvbid0IGNyYXNoLlxuICAgICAgdGhpcy53YXJuKCdhbm9ueW1vdXMgdHlwZSBoYXMgbm8gc3ltYm9sJyk7XG4gICAgICByZXR1cm4gJz8nO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkZ1bmN0aW9uIHx8IHR5cGUuc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuTWV0aG9kKSB7XG4gICAgICBjb25zdCBzaWdzID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTaWduYXR1cmVzT2ZUeXBlKHR5cGUsIHRzLlNpZ25hdHVyZUtpbmQuQ2FsbCk7XG4gICAgICBpZiAoc2lncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlVG9DbG9zdXJlKHNpZ3NbMF0pO1xuICAgICAgfVxuICAgICAgdGhpcy53YXJuKCd1bmhhbmRsZWQgYW5vbnltb3VzIHR5cGUgd2l0aCBtdWx0aXBsZSBjYWxsIHNpZ25hdHVyZXMnKTtcbiAgICAgIHJldHVybiAnPyc7XG4gICAgfVxuXG4gICAgLy8gR2F0aGVyIHVwIGFsbCB0aGUgbmFtZWQgZmllbGRzIGFuZCB3aGV0aGVyIHRoZSBvYmplY3QgaXMgYWxzbyBjYWxsYWJsZS5cbiAgICBsZXQgY2FsbGFibGUgPSBmYWxzZTtcbiAgICBsZXQgaW5kZXhhYmxlID0gZmFsc2U7XG4gICAgY29uc3QgZmllbGRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmICghdHlwZS5zeW1ib2wubWVtYmVycykge1xuICAgICAgdGhpcy53YXJuKCdhbm9ueW1vdXMgdHlwZSBoYXMgbm8gc3ltYm9sJyk7XG4gICAgICByZXR1cm4gJz8nO1xuICAgIH1cblxuICAgIC8vIHNwZWNpYWwtY2FzZSBjb25zdHJ1Y3Qgc2lnbmF0dXJlcy5cbiAgICBjb25zdCBjdG9ycyA9IHR5cGUuZ2V0Q29uc3RydWN0U2lnbmF0dXJlcygpO1xuICAgIGlmIChjdG9ycy5sZW5ndGgpIHtcbiAgICAgIC8vIFRPRE8obWFydGlucHJvYnN0KTogdGhpcyBkb2VzIG5vdCBzdXBwb3J0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBkZWZpbmVkIG9uIGNvbnN0cnVjdG9yc1xuICAgICAgLy8gKG5vdCBleHByZXNzaWJsZSBpbiBDbG9zdXJlKSwgbm9yIG11bHRpcGxlIGNvbnN0cnVjdG9ycyAoc2FtZSkuXG4gICAgICBjb25zdCBkZWNsID0gY3RvcnNbMF0uZGVjbGFyYXRpb247XG4gICAgICBpZiAoIWRlY2wpIHtcbiAgICAgICAgdGhpcy53YXJuKCd1bmhhbmRsZWQgYW5vbnltb3VzIHR5cGUgd2l0aCBjb25zdHJ1Y3RvciBzaWduYXR1cmUgYnV0IG5vIGRlY2xhcmF0aW9uJyk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICB9XG4gICAgICBpZiAoZGVjbC5raW5kID09PSB0cy5TeW50YXhLaW5kLkpTRG9jU2lnbmF0dXJlKSB7XG4gICAgICAgIHRoaXMud2FybigndW5oYW5kbGVkIEpTRG9jIGJhc2VkIGNvbnN0cnVjdG9yIHNpZ25hdHVyZScpO1xuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXcgPFQ+KHRlZTogVCkgaXMgbm90IHN1cHBvcnRlZCBieSBDbG9zdXJlLCBibGFja2xpc3QgYXMgPy5cbiAgICAgIHRoaXMuYmxhY2tsaXN0VHlwZVBhcmFtZXRlcnModGhpcy5zeW1ib2xzVG9BbGlhc2VkTmFtZXMsIGRlY2wudHlwZVBhcmFtZXRlcnMpO1xuXG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmNvbnZlcnRQYXJhbXMoY3RvcnNbMF0sIGRlY2wucGFyYW1ldGVycyk7XG4gICAgICBjb25zdCBwYXJhbXNTdHIgPSBwYXJhbXMubGVuZ3RoID8gKCcsICcgKyBwYXJhbXMuam9pbignLCAnKSkgOiAnJztcbiAgICAgIGNvbnN0IGNvbnN0cnVjdGVkVHlwZSA9IHRoaXMudHJhbnNsYXRlKGN0b3JzWzBdLmdldFJldHVyblR5cGUoKSk7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RlZFR5cGVTdHIgPVxuICAgICAgICAgIGNvbnN0cnVjdGVkVHlwZVswXSA9PT0gJyEnID8gY29uc3RydWN0ZWRUeXBlLnN1YnN0cmluZygxKSA6IGNvbnN0cnVjdGVkVHlwZTtcbiAgICAgIC8vIEluIHRoZSBzcGVjaWZpYyBjYXNlIG9mIHRoZSBcIm5ld1wiIGluIGEgZnVuY3Rpb24sIHRoZSBjb3JyZWN0IENsb3N1cmVcbiAgICAgIC8vIHR5cGUgaXM6XG4gICAgICAvL1xuICAgICAgLy8gICBmdW5jdGlvbihuZXc6QmFyLCAuLi5hcmdzKVxuICAgICAgLy9cbiAgICAgIC8vIEluY2x1ZGluZyB0aGUgbnVsbGFiaWxpdHkgYW5ub3RhdGlvbiBjYW4gY2F1c2UgdGhlIENsb3N1cmUgY29tcGlsZXIgdG9cbiAgICAgIC8vIG5vIGxvbmdlciByZWNvZ25pemUgdGhlIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3IgdHlwZSBpbiBleHRlcm5zLlxuICAgICAgcmV0dXJuIGBmdW5jdGlvbihuZXc6JHtjb25zdHJ1Y3RlZFR5cGVTdHJ9JHtwYXJhbXNTdHJ9KWA7XG4gICAgfVxuXG4gICAgLy8gbWVtYmVycyBpcyBhbiBFUzYgbWFwLCBidXQgdGhlIC5kLnRzIGRlZmluaW5nIGl0IGRlZmluZWQgdGhlaXIgb3duIG1hcFxuICAgIC8vIHR5cGUsIHNvIHR5cGVzY3JpcHQgZG9lc24ndCBiZWxpZXZlIHRoYXQgLmtleXMoKSBpcyBpdGVyYWJsZVxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mICh0eXBlLnN5bWJvbC5tZW1iZXJzLmtleXMoKSBhcyBhbnkpKSB7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgJ19fY2FsbCc6XG4gICAgICAgICAgY2FsbGFibGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdfX2luZGV4JzpcbiAgICAgICAgICBpbmRleGFibGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghaXNWYWxpZENsb3N1cmVQcm9wZXJ0eU5hbWUoZmllbGQpKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oYG9taXR0aW5nIGluZXhwcmVzc2libGUgcHJvcGVydHkgbmFtZTogJHtmaWVsZH1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtZW1iZXIgPSB0eXBlLnN5bWJvbC5tZW1iZXJzLmdldChmaWVsZCkhO1xuICAgICAgICAgIC8vIG9wdGlvbmFsIG1lbWJlcnMgYXJlIGhhbmRsZWQgYnkgdGhlIHR5cGUgaW5jbHVkaW5nIHx1bmRlZmluZWQgaW4gYSB1bmlvbiB0eXBlLlxuICAgICAgICAgIGNvbnN0IG1lbWJlclR5cGUgPVxuICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSh0aGlzLnR5cGVDaGVja2VyLmdldFR5cGVPZlN5bWJvbEF0TG9jYXRpb24obWVtYmVyLCB0aGlzLm5vZGUpKTtcbiAgICAgICAgICBmaWVsZHMucHVzaChgJHtmaWVsZH06ICR7bWVtYmVyVHlwZX1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gc3BlY2lhbC1jYXNlIHBsYWluIGtleS12YWx1ZSBvYmplY3RzIGFuZCBmdW5jdGlvbnMuXG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChjYWxsYWJsZSAmJiAhaW5kZXhhYmxlKSB7XG4gICAgICAgIC8vIEEgZnVuY3Rpb24gdHlwZS5cbiAgICAgICAgY29uc3Qgc2lncyA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U2lnbmF0dXJlc09mVHlwZSh0eXBlLCB0cy5TaWduYXR1cmVLaW5kLkNhbGwpO1xuICAgICAgICBpZiAoc2lncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVUb0Nsb3N1cmUoc2lnc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5kZXhhYmxlICYmICFjYWxsYWJsZSkge1xuICAgICAgICAvLyBBIHBsYWluIGtleS12YWx1ZSBtYXAgdHlwZS5cbiAgICAgICAgbGV0IGtleVR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgbGV0IHZhbFR5cGUgPSB0aGlzLnR5cGVDaGVja2VyLmdldEluZGV4VHlwZU9mVHlwZSh0eXBlLCB0cy5JbmRleEtpbmQuU3RyaW5nKTtcbiAgICAgICAgaWYgKCF2YWxUeXBlKSB7XG4gICAgICAgICAga2V5VHlwZSA9ICdudW1iZXInO1xuICAgICAgICAgIHZhbFR5cGUgPSB0aGlzLnR5cGVDaGVja2VyLmdldEluZGV4VHlwZU9mVHlwZSh0eXBlLCB0cy5JbmRleEtpbmQuTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbFR5cGUpIHtcbiAgICAgICAgICB0aGlzLndhcm4oJ3Vua25vd24gaW5kZXgga2V5IHR5cGUnKTtcbiAgICAgICAgICByZXR1cm4gYCFPYmplY3Q8Pyw/PmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAhT2JqZWN0PCR7a2V5VHlwZX0sJHt0aGlzLnRyYW5zbGF0ZSh2YWxUeXBlKX0+YDtcbiAgICAgIH0gZWxzZSBpZiAoIWNhbGxhYmxlICYmICFpbmRleGFibGUpIHtcbiAgICAgICAgLy8gVGhlIG9iamVjdCBoYXMgbm8gbWVtYmVycy4gIFRoaXMgaXMgdGhlIFRTIHR5cGUgJ3t9JyxcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgXCJhbnkgdmFsdWUgb3RoZXIgdGhhbiBudWxsIG9yIHVuZGVmaW5lZFwiLlxuICAgICAgICAvLyBXaGF0IGlzIHRoaXMgaW4gQ2xvc3VyZSdzIHR5cGUgc3lzdGVtP1xuICAgICAgICAvL1xuICAgICAgICAvLyBGaXJzdCwgeyFPYmplY3R9IGlzIHdyb25nIGJlY2F1c2UgaXQgaXMgbm90IGEgc3VwZXJ0eXBlIG9mXG4gICAgICAgIC8vIHtzdHJpbmd9IG9yIHtudW1iZXJ9LiAgVGhpcyB3b3VsZCBtZWFuIHlvdSBjYW5ub3QgYXNzaWduIGFcbiAgICAgICAgLy8gbnVtYmVyIHRvIGEgdmFyaWFibGUgb2YgVFMgdHlwZSB7fS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgZ2V0IGNsb3NlciB3aXRoIHsqfSwgYWthIHRoZSBBTEwgdHlwZS4gIFRoaXMgb25lIGJldHRlclxuICAgICAgICAvLyBjYXB0dXJlcyB0aGUgdHlwaWNhbCB1c2Ugb2YgdGhlIFRTIHt9LCB3aGljaCB1c2VycyB1c2UgZm9yXG4gICAgICAgIC8vIFwiSSBkb24ndCBjYXJlXCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHsqfSB1bmZvcnR1bmF0ZWx5IGRvZXMgaW5jbHVkZSBudWxsL3VuZGVmaW5lZCwgc28gaXQncyBhIGNsb3NlclxuICAgICAgICAvLyBtYXRjaCBmb3IgVFMgMy4wJ3MgJ3Vua25vd24nLlxuICAgICAgICByZXR1cm4gJyonO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2FsbGFibGUgJiYgIWluZGV4YWJsZSkge1xuICAgICAgLy8gTm90IGNhbGxhYmxlLCBub3QgaW5kZXhhYmxlOyBpbXBsaWVzIGEgcGxhaW4gb2JqZWN0IHdpdGggZmllbGRzIGluIGl0LlxuICAgICAgcmV0dXJuIGB7JHtmaWVsZHMuam9pbignLCAnKX19YDtcbiAgICB9XG5cbiAgICB0aGlzLndhcm4oJ3VuaGFuZGxlZCBhbm9ueW1vdXMgdHlwZScpO1xuICAgIHJldHVybiAnPyc7XG4gIH1cblxuICAvKiogQ29udmVydHMgYSB0cy5TaWduYXR1cmUgKGZ1bmN0aW9uIHNpZ25hdHVyZSkgdG8gYSBDbG9zdXJlIGZ1bmN0aW9uIHR5cGUuICovXG4gIHByaXZhdGUgc2lnbmF0dXJlVG9DbG9zdXJlKHNpZzogdHMuU2lnbmF0dXJlKTogc3RyaW5nIHtcbiAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IENvbnNpZGVyIGhhcm1vbml6aW5nIHNvbWUgb3ZlcmxhcCB3aXRoIGVtaXRGdW5jdGlvblR5cGUgaW4gdHNpY2tsZS50cy5cbiAgICBpZiAoIXNpZy5kZWNsYXJhdGlvbikge1xuICAgICAgdGhpcy53YXJuKCdzaWduYXR1cmUgd2l0aG91dCBkZWNsYXJhdGlvbicpO1xuICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgfVxuICAgIGlmIChzaWcuZGVjbGFyYXRpb24ua2luZCA9PT0gdHMuU3ludGF4S2luZC5KU0RvY1NpZ25hdHVyZSkge1xuICAgICAgdGhpcy53YXJuKCdzaWduYXR1cmUgd2l0aCBKU0RvYyBkZWNsYXJhdGlvbicpO1xuICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgfVxuICAgIHRoaXMuYmxhY2tsaXN0VHlwZVBhcmFtZXRlcnModGhpcy5zeW1ib2xzVG9BbGlhc2VkTmFtZXMsIHNpZy5kZWNsYXJhdGlvbi50eXBlUGFyYW1ldGVycyk7XG5cbiAgICBsZXQgdHlwZVN0ciA9IGBmdW5jdGlvbihgO1xuICAgIGxldCBwYXJhbURlY2xzOiBSZWFkb25seUFycmF5PHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uPiA9IHNpZy5kZWNsYXJhdGlvbi5wYXJhbWV0ZXJzIHx8IFtdO1xuICAgIGNvbnN0IG1heWJlVGhpc1BhcmFtID0gcGFyYW1EZWNsc1swXTtcbiAgICAvLyBPZGRseSwgdGhlIHRoaXMgdHlwZSBzaG93cyB1cCBpbiBwYXJhbURlY2xzLCBidXQgbm90IGluIHRoZSB0eXBlJ3MgcGFyYW1ldGVycy5cbiAgICAvLyBIYW5kbGUgaXQgaGVyZSBhbmQgdGhlbiBwYXNzIHBhcmFtRGVjbHMgZG93biB3aXRob3V0IGl0cyBmaXJzdCBlbGVtZW50LlxuICAgIGlmIChtYXliZVRoaXNQYXJhbSAmJiBtYXliZVRoaXNQYXJhbS5uYW1lLmdldFRleHQoKSA9PT0gJ3RoaXMnKSB7XG4gICAgICBpZiAobWF5YmVUaGlzUGFyYW0udHlwZSkge1xuICAgICAgICBjb25zdCB0aGlzVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obWF5YmVUaGlzUGFyYW0udHlwZSk7XG4gICAgICAgIHR5cGVTdHIgKz0gYHRoaXM6ICgke3RoaXMudHJhbnNsYXRlKHRoaXNUeXBlKX0pYDtcbiAgICAgICAgaWYgKHBhcmFtRGVjbHMubGVuZ3RoID4gMSkgdHlwZVN0ciArPSAnLCAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YXJuKCd0aGlzIHR5cGUgd2l0aG91dCB0eXBlJyk7XG4gICAgICB9XG4gICAgICBwYXJhbURlY2xzID0gcGFyYW1EZWNscy5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmNvbnZlcnRQYXJhbXMoc2lnLCBwYXJhbURlY2xzKTtcbiAgICB0eXBlU3RyICs9IGAke3BhcmFtcy5qb2luKCcsICcpfSlgO1xuXG4gICAgY29uc3QgcmV0VHlwZSA9IHRoaXMudHJhbnNsYXRlKHRoaXMudHlwZUNoZWNrZXIuZ2V0UmV0dXJuVHlwZU9mU2lnbmF0dXJlKHNpZykpO1xuICAgIGlmIChyZXRUeXBlKSB7XG4gICAgICB0eXBlU3RyICs9IGA6ICR7cmV0VHlwZX1gO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlU3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHBhcmFtZXRlcnMgZm9yIHRoZSBnaXZlbiBzaWduYXR1cmUuIFRha2VzIHBhcmFtZXRlciBkZWNsYXJhdGlvbnMgYXMgdGhvc2UgbWlnaHQgbm90XG4gICAqIG1hdGNoIHRoZSBzaWduYXR1cmUgcGFyYW1ldGVycyAoZS5nLiB0aGVyZSBtaWdodCBiZSBhbiBhZGRpdGlvbmFsIHRoaXMgcGFyYW1ldGVyKS4gVGhpc1xuICAgKiBkaWZmZXJlbmNlIGlzIGhhbmRsZWQgYnkgdGhlIGNhbGxlciwgYXMgaXMgY29udmVydGluZyB0aGUgXCJ0aGlzXCIgcGFyYW1ldGVyLlxuICAgKi9cbiAgcHJpdmF0ZSBjb252ZXJ0UGFyYW1zKHNpZzogdHMuU2lnbmF0dXJlLCBwYXJhbURlY2xzOiBSZWFkb25seUFycmF5PHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uPik6XG4gICAgICBzdHJpbmdbXSB7XG4gICAgY29uc3QgcGFyYW1UeXBlczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZy5wYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHNpZy5wYXJhbWV0ZXJzW2ldO1xuXG4gICAgICBjb25zdCBwYXJhbURlY2wgPSBwYXJhbURlY2xzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9uYWwgPSAhIXBhcmFtRGVjbC5xdWVzdGlvblRva2VuO1xuICAgICAgY29uc3QgdmFyQXJncyA9ICEhcGFyYW1EZWNsLmRvdERvdERvdFRva2VuO1xuICAgICAgbGV0IHBhcmFtVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZU9mU3ltYm9sQXRMb2NhdGlvbihwYXJhbSwgdGhpcy5ub2RlKTtcbiAgICAgIGlmICh2YXJBcmdzKSB7XG4gICAgICAgIGlmICgocGFyYW1UeXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLk9iamVjdCkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLndhcm4oJ3ZhciBhcmdzIHR5cGUgaXMgbm90IGFuIG9iamVjdCB0eXBlJyk7XG4gICAgICAgICAgcGFyYW1UeXBlcy5wdXNoKCchQXJyYXk8Pz4nKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChwYXJhbVR5cGUgYXMgdHMuT2JqZWN0VHlwZSkub2JqZWN0RmxhZ3MgJiB0cy5PYmplY3RGbGFncy5SZWZlcmVuY2UpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy53YXJuKCd1bnN1cHBvcnRlZCB2YXIgYXJncyB0eXBlIChub3QgYW4gYXJyYXkgcmVmZXJlbmNlKScpO1xuICAgICAgICAgIHBhcmFtVHlwZXMucHVzaCgnIUFycmF5PD8+Jyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZUFyZ3MgPSB0aGlzLnR5cGVDaGVja2VyLmdldFR5cGVBcmd1bWVudHMocGFyYW1UeXBlIGFzIHRzLlR5cGVSZWZlcmVuY2UpO1xuICAgICAgICBpZiAodHlwZUFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHJlc3QgYXJndW1lbnQgcmVzb2x2ZXMgZW1wdHksIGkuZS4gdGhlIGNvbmNyZXRlIGluc3RhbnRpYXRpb24gZG9lcyBub3QgdGFrZSBhbnlcbiAgICAgICAgICAvLyBhcmd1bWVudHMsIHRoZSB0eXBlIGFyZ3VtZW50cyBhcmUgZW1wdHkuIEVtaXQgYSBmdW5jdGlvbiB0eXBlIHRoYXQgdGFrZXMgbm8gYXJnIGluIHRoaXNcbiAgICAgICAgICAvLyBwb3NpdGlvbiB0aGVuLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtVHlwZSA9IHR5cGVBcmdzWzBdO1xuICAgICAgfVxuICAgICAgbGV0IHR5cGVTdHIgPSB0aGlzLnRyYW5zbGF0ZShwYXJhbVR5cGUpO1xuICAgICAgaWYgKHZhckFyZ3MpIHR5cGVTdHIgPSAnLi4uJyArIHR5cGVTdHI7XG4gICAgICBpZiAob3B0aW9uYWwpIHR5cGVTdHIgPSB0eXBlU3RyICsgJz0nO1xuICAgICAgcGFyYW1UeXBlcy5wdXNoKHR5cGVTdHIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1UeXBlcztcbiAgfVxuXG4gIHdhcm4obXNnOiBzdHJpbmcpIHtcbiAgICAvLyBCeSBkZWZhdWx0LCB3YXJuKCkgZG9lcyBub3RoaW5nLiAgVGhlIGNhbGxlciB3aWxsIG92ZXJ3cml0ZSB0aGlzXG4gICAgLy8gaWYgaXQgd2FudHMgZGlmZmVyZW50IGJlaGF2aW9yLlxuICB9XG5cbiAgLyoqIEByZXR1cm4gdHJ1ZSBpZiBzeW0gc2hvdWxkIGFsd2F5cyBoYXZlIHR5cGUgez99LiAqL1xuICBpc0JsYWNrTGlzdGVkKHN5bWJvbDogdHMuU3ltYm9sKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGlzQmxhY2tsaXN0ZWQodGhpcy5wYXRoQmxhY2tMaXN0LCBzeW1ib2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3N1cmUgZG9lc24gbm90IHN1cHBvcnQgdHlwZSBwYXJhbWV0ZXJzIGZvciBmdW5jdGlvbiB0eXBlcywgaS5lLiBnZW5lcmljIGZ1bmN0aW9uIHR5cGVzLlxuICAgKiBCbGFja2xpc3QgdGhlIHN5bWJvbHMgZGVjbGFyZWQgYnkgdGhlbSBhbmQgZW1pdCBhID8gZm9yIHRoZSB0eXBlcy5cbiAgICpcbiAgICogVGhpcyBtdXRhdGVzIHRoZSBnaXZlbiBibGFja2xpc3QgbWFwLiBUaGUgbWFwJ3Mgc2NvcGUgaXMgb25lIGZpbGUsIGFuZCBzeW1ib2xzIGFyZVxuICAgKiB1bmlxdWUgb2JqZWN0cywgc28gdGhpcyBzaG91bGQgbmVpdGhlciBsZWFkIHRvIGV4Y2Vzc2l2ZSBtZW1vcnkgY29uc3VtcHRpb24gbm9yIGludHJvZHVjZVxuICAgKiBlcnJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSBibGFja2xpc3QgYSBtYXAgdG8gc3RvcmUgdGhlIGJsYWNrbGlzdGVkIHN5bWJvbHMgaW4sIHdpdGggYSB2YWx1ZSBvZiAnPycuIEluIHByYWN0aWNlLFxuICAgKiAgICAgdGhpcyBpcyBhbHdheXMgPT09IHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCBidXQgd2UncmUgcGFzc2luZyBpdCBleHBsaWNpdGx5IHRvIG1ha2UgaXRcbiAgICogICAgY2xlYXIgdGhhdCB0aGUgbWFwIGlzIG11dGF0ZWQgKGluIHBhcnRpY3VsYXIgd2hlbiB1c2VkIGZyb20gb3V0c2lkZSB0aGUgY2xhc3MpLlxuICAgKiBAcGFyYW0gZGVjbHMgdGhlIGRlY2xhcmF0aW9ucyB3aG9zZSBzeW1ib2xzIHNob3VsZCBiZSBibGFja2xpc3RlZC5cbiAgICovXG4gIGJsYWNrbGlzdFR5cGVQYXJhbWV0ZXJzKFxuICAgICAgYmxhY2tsaXN0OiBNYXA8dHMuU3ltYm9sLCBzdHJpbmc+LFxuICAgICAgZGVjbHM6IFJlYWRvbmx5QXJyYXk8dHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uPnx1bmRlZmluZWQpIHtcbiAgICBpZiAoIWRlY2xzIHx8ICFkZWNscy5sZW5ndGgpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHRwZCBvZiBkZWNscykge1xuICAgICAgY29uc3Qgc3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHRwZC5uYW1lKTtcbiAgICAgIGlmICghc3ltKSB7XG4gICAgICAgIHRoaXMud2FybihgdHlwZSBwYXJhbWV0ZXIgd2l0aCBubyBzeW1ib2xgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBibGFja2xpc3Quc2V0KHN5bSwgJz8nKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIEByZXR1cm4gdHJ1ZSBpZiBzeW0gc2hvdWxkIGFsd2F5cyBoYXZlIHR5cGUgez99LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmxhY2tsaXN0ZWQocGF0aEJsYWNrTGlzdDogU2V0PHN0cmluZz58dW5kZWZpbmVkLCBzeW1ib2w6IHRzLlN5bWJvbCkge1xuICBpZiAocGF0aEJsYWNrTGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gIC8vIFNvbWUgYnVpbHRpbiB0eXBlcywgc3VjaCBhcyB7fSwgZ2V0IHJlcHJlc2VudGVkIGJ5IGEgc3ltYm9sIHRoYXQgaGFzIG5vIGRlY2xhcmF0aW9ucy5cbiAgaWYgKHN5bWJvbC5kZWNsYXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc3ltYm9sLmRlY2xhcmF0aW9ucy5ldmVyeShuID0+IHtcbiAgICBjb25zdCBmaWxlTmFtZSA9IHBhdGgubm9ybWFsaXplKG4uZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lKTtcbiAgICByZXR1cm4gcGF0aEJsYWNrTGlzdC5oYXMoZmlsZU5hbWUpO1xuICB9KTtcbn1cbiJdfQ==