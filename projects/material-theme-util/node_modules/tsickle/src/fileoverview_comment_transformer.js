/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/fileoverview_comment_transformer", ["require", "exports", "typescript", "tsickle/src/jsdoc", "tsickle/src/path", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformFileoverviewCommentFactory = void 0;
    const ts = require("typescript");
    const jsdoc = require("tsickle/src/jsdoc");
    const path = require("tsickle/src/path");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    /**
     * A set of JSDoc tags that mark a comment as a fileoverview comment. These are recognized by other
     * pieces of infrastructure (Closure Compiler, module system, ...).
     */
    const FILEOVERVIEW_COMMENT_MARKERS = new Set(['fileoverview', 'externs', 'modName', 'mods', 'pintomodule']);
    /**
     * Given a parsed \@fileoverview comment, ensures it has all the attributes we need.
     * This function can be called to modify an existing comment or to make a new one.
     *
     * @param source Original TS source file. Its path is added in \@fileoverview.
     * @param tags Comment as parsed list of tags; modified in-place.
     */
    function augmentFileoverviewComments(options, source, tags) {
        // Ensure we start with a @fileoverview.
        let fileOverview = tags.find(t => t.tagName === 'fileoverview');
        if (!fileOverview) {
            fileOverview = { tagName: 'fileoverview', text: 'added by tsickle' };
            tags.splice(0, 0, fileOverview);
        }
        if (options.rootDir != null) {
            // This comment is read by other tools so it's important that its format
            // doesn't change.
            fileOverview.text += `\nGenerated from: ${path.relative(options.rootDir, source.fileName)}`;
        }
        // Find or create a @suppress tag.
        // Closure compiler barfs if there's a duplicated @suppress tag in a file, so the tag must
        // only appear once and be merged.
        let suppressTag = tags.find(t => t.tagName === 'suppress');
        let suppressions;
        if (suppressTag) {
            suppressions = new Set((suppressTag.type || '').split(',').map(s => s.trim()));
        }
        else {
            suppressTag = { tagName: 'suppress', text: 'checked by tsc' };
            // Special case the @license tag because all text following this tag is
            // treated by the compiler as part of the license, so we need to place the
            // new @suppress tag before @license.
            const licenseTagIndex = tags.findIndex(t => t.tagName === 'license');
            if (licenseTagIndex !== -1) {
                tags.splice(licenseTagIndex, 0, suppressTag);
            }
            else {
                tags.push(suppressTag);
            }
            suppressions = new Set();
        }
        // Ensure our suppressions are included in the @suppress tag:
        // * Suppress checkTypes.  We believe the code has already been type-checked
        // by TypeScript, and we cannot model all the TypeScript type decisions in
        // Closure syntax.
        suppressions.add('checkTypes');
        // * Suppress extraRequire.  We remove extra requires at the TypeScript level,
        // so any require that gets to the JS level is a load-bearing require.
        suppressions.add('extraRequire');
        // * Types references are propagated between files even when they are not
        // directly imported. While these are violations of the "missing require"
        // rules they are believed to be safe.
        suppressions.add('missingRequire');
        // * Suppress uselessCode.  We emit an "if (false)" around type declarations,
        // which is flagged as unused code unless we suppress it.
        suppressions.add('uselessCode');
        // * Suppress some checks for user errors that TS already checks.
        suppressions.add('missingReturn');
        suppressions.add('unusedPrivateMembers');
        // * Suppress checking for @override, because TS doesn't model it.
        suppressions.add('missingOverride');
        // * Suppress constantProperty checking, which errors when a namespace is
        // reopened. Namespace reopening happens when one writes namespace foo {}
        // or namespace foo.* {} more than once.
        suppressions.add('constantProperty');
        suppressTag.type = Array.from(suppressions.values()).sort().join(',');
        return tags;
    }
    /**
     * A transformer that ensures the emitted JS file has an \@fileoverview comment that contains an
     * \@suppress {checkTypes} annotation by either adding or updating an existing comment.
     */
    function transformFileoverviewCommentFactory(options, diagnostics) {
        return () => {
            function checkNoFileoverviewComments(context, comments, message) {
                for (const comment of comments) {
                    const parse = jsdoc.parse(comment);
                    if (parse !== null && parse.tags.some(t => FILEOVERVIEW_COMMENT_MARKERS.has(t.tagName))) {
                        // Report a warning; this should not break compilation in third party code.
                        transformer_util_1.reportDiagnostic(diagnostics, context, message, comment.originalRange, ts.DiagnosticCategory.Warning);
                    }
                }
            }
            return (sourceFile) => {
                const text = sourceFile.getFullText();
                let fileComments = [];
                const firstStatement = sourceFile.statements.length && sourceFile.statements[0] || null;
                const originalComments = ts.getLeadingCommentRanges(text, 0) || [];
                if (!firstStatement) {
                    // In an empty source file, all comments are file-level comments.
                    fileComments = transformer_util_1.synthesizeCommentRanges(sourceFile, originalComments);
                }
                else {
                    // Search for the last comment split from the file with a \n\n. All comments before that are
                    // considered fileoverview comments, all comments after that belong to the next
                    // statement(s). If none found, comments remains empty, and the code below will insert a new
                    // fileoverview comment.
                    for (let i = originalComments.length - 1; i >= 0; i--) {
                        const end = originalComments[i].end;
                        if (!text.substring(end).startsWith('\n\n') &&
                            !text.substring(end).startsWith('\r\n\r\n')) {
                            continue;
                        }
                        // This comment is separated from the source file with a double break, marking it (and any
                        // preceding comments) as a file-level comment. Split them off and attach them onto a
                        // NotEmittedStatement, so that they do not get lost later on.
                        const synthesizedComments = jsdoc.synthesizeLeadingComments(firstStatement);
                        const notEmitted = ts.createNotEmittedStatement(sourceFile);
                        // Modify the comments on the firstStatement in place by removing the file-level comments.
                        fileComments = synthesizedComments.splice(0, i + 1);
                        // Move the fileComments onto notEmitted.
                        ts.setSyntheticLeadingComments(notEmitted, fileComments);
                        sourceFile = transformer_util_1.updateSourceFileNode(sourceFile, ts.createNodeArray([notEmitted, firstStatement, ...sourceFile.statements.slice(1)]));
                        break;
                    }
                    // Now walk every top level statement and escape/drop any @fileoverview comments found.
                    // Closure ignores all @fileoverview comments but the last, so tsickle must make sure not to
                    // emit duplicated ones.
                    for (let i = 0; i < sourceFile.statements.length; i++) {
                        const stmt = sourceFile.statements[i];
                        // Accept the NotEmittedStatement inserted above.
                        if (i === 0 && stmt.kind === ts.SyntaxKind.NotEmittedStatement)
                            continue;
                        const comments = jsdoc.synthesizeLeadingComments(stmt);
                        checkNoFileoverviewComments(stmt, comments, `file comments must be at the top of the file, ` +
                            `separated from the file body by an empty line.`);
                    }
                }
                // Closure Compiler considers the *last* comment with @fileoverview (or #externs or
                // @nocompile) that has not been attached to some other tree node to be the file overview
                // comment, and only applies @suppress tags from it. Google-internal tooling considers *any*
                // comment mentioning @fileoverview.
                let fileoverviewIdx = -1;
                let tags = [];
                for (let i = fileComments.length - 1; i >= 0; i--) {
                    const parse = jsdoc.parseContents(fileComments[i].text);
                    if (parse !== null && parse.tags.some(t => FILEOVERVIEW_COMMENT_MARKERS.has(t.tagName))) {
                        fileoverviewIdx = i;
                        tags = parse.tags;
                        break;
                    }
                }
                if (fileoverviewIdx !== -1) {
                    checkNoFileoverviewComments(firstStatement || sourceFile, fileComments.slice(0, fileoverviewIdx), `duplicate file level comment`);
                }
                augmentFileoverviewComments(options, sourceFile, tags);
                const commentText = jsdoc.toStringWithoutStartEnd(tags);
                if (fileoverviewIdx < 0) {
                    // No existing comment to merge with, just emit a new one.
                    return addNewFileoverviewComment(sourceFile, commentText);
                }
                fileComments[fileoverviewIdx].text = commentText;
                // sf does not need to be updated, synthesized comments are mutable.
                return sourceFile;
            };
        };
    }
    exports.transformFileoverviewCommentFactory = transformFileoverviewCommentFactory;
    function addNewFileoverviewComment(sf, commentText) {
        let syntheticFirstStatement = transformer_util_1.createNotEmittedStatement(sf);
        syntheticFirstStatement = ts.addSyntheticTrailingComment(syntheticFirstStatement, ts.SyntaxKind.MultiLineCommentTrivia, commentText, true);
        return transformer_util_1.updateSourceFileNode(sf, ts.createNodeArray([syntheticFirstStatement, ...sf.statements]));
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZW92ZXJ2aWV3X2NvbW1lbnRfdHJhbnNmb3JtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvZmlsZW92ZXJ2aWV3X2NvbW1lbnRfdHJhbnNmb3JtZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7O0lBRUgsaUNBQWlDO0lBRWpDLDJDQUFpQztJQUNqQyx5Q0FBK0I7SUFDL0IsbUVBQThIO0lBRTlIOzs7T0FHRztJQUNILE1BQU0sNEJBQTRCLEdBQzlCLElBQUksR0FBRyxDQUFDLENBQUMsY0FBYyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFFM0U7Ozs7OztPQU1HO0lBQ0gsU0FBUywyQkFBMkIsQ0FDaEMsT0FBMkIsRUFBRSxNQUFxQixFQUFFLElBQWlCO1FBQ3ZFLHdDQUF3QztRQUN4QyxJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxjQUFjLENBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ2pCLFlBQVksR0FBRyxFQUFDLE9BQU8sRUFBRSxjQUFjLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixFQUFDLENBQUM7WUFDbkUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ2pDO1FBQ0QsSUFBSSxPQUFPLENBQUMsT0FBTyxJQUFJLElBQUksRUFBRTtZQUMzQix3RUFBd0U7WUFDeEUsa0JBQWtCO1lBQ2xCLFlBQVksQ0FBQyxJQUFJLElBQUkscUJBQXFCLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztTQUM3RjtRQUVELGtDQUFrQztRQUNsQywwRkFBMEY7UUFDMUYs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QyxDQUFDLElBQUksR0FBRyxXQUFXLENBQUM7Z0JBQ2pELG9FQUFvRTtnQkFDcEUsT0FBTyxVQUFVLENBQUM7WUFDcEIsQ0FBQyxDQUFDO1FBQ0osQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQXJHRCxrRkFxR0M7SUFFRCxTQUFTLHlCQUF5QixDQUFDLEVBQWlCLEVBQUUsV0FBbUI7UUFDdkUsSUFBSSx1QkFBdUIsR0FBRyw0Q0FBeUIsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM1RCx1QkFBdUIsR0FBRyxFQUFFLENBQUMsMkJBQTJCLENBQ3BELHVCQUF1QixFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3RGLE9BQU8sdUNBQW9CLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQyx1QkFBdUIsRUFBRSxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbmltcG9ydCAqIGFzIGpzZG9jIGZyb20gJy4vanNkb2MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICcuL3BhdGgnO1xuaW1wb3J0IHtjcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50LCByZXBvcnREaWFnbm9zdGljLCBzeW50aGVzaXplQ29tbWVudFJhbmdlcywgdXBkYXRlU291cmNlRmlsZU5vZGV9IGZyb20gJy4vdHJhbnNmb3JtZXJfdXRpbCc7XG5cbi8qKlxuICogQSBzZXQgb2YgSlNEb2MgdGFncyB0aGF0IG1hcmsgYSBjb21tZW50IGFzIGEgZmlsZW92ZXJ2aWV3IGNvbW1lbnQuIFRoZXNlIGFyZSByZWNvZ25pemVkIGJ5IG90aGVyXG4gKiBwaWVjZXMgb2YgaW5mcmFzdHJ1Y3R1cmUgKENsb3N1cmUgQ29tcGlsZXIsIG1vZHVsZSBzeXN0ZW0sIC4uLikuXG4gKi9cbmNvbnN0IEZJTEVPVkVSVklFV19DT01NRU5UX01BUktFUlM6IFJlYWRvbmx5U2V0PHN0cmluZz4gPVxuICAgIG5ldyBTZXQoWydmaWxlb3ZlcnZpZXcnLCAnZXh0ZXJucycsICdtb2ROYW1lJywgJ21vZHMnLCAncGludG9tb2R1bGUnXSk7XG5cbi8qKlxuICogR2l2ZW4gYSBwYXJzZWQgXFxAZmlsZW92ZXJ2aWV3IGNvbW1lbnQsIGVuc3VyZXMgaXQgaGFzIGFsbCB0aGUgYXR0cmlidXRlcyB3ZSBuZWVkLlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIHRvIG1vZGlmeSBhbiBleGlzdGluZyBjb21tZW50IG9yIHRvIG1ha2UgYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSBzb3VyY2UgT3JpZ2luYWwgVFMgc291cmNlIGZpbGUuIEl0cyBwYXRoIGlzIGFkZGVkIGluIFxcQGZpbGVvdmVydmlldy5cbiAqIEBwYXJhbSB0YWdzIENvbW1lbnQgYXMgcGFyc2VkIGxpc3Qgb2YgdGFnczsgbW9kaWZpZWQgaW4tcGxhY2UuXG4gKi9cbmZ1bmN0aW9uIGF1Z21lbnRGaWxlb3ZlcnZpZXdDb21tZW50cyhcbiAgICBvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMsIHNvdXJjZTogdHMuU291cmNlRmlsZSwgdGFnczoganNkb2MuVGFnW10pIHtcbiAgLy8gRW5zdXJlIHdlIHN0YXJ0IHdpdGggYSBAZmlsZW92ZXJ2aWV3LlxuICBsZXQgZmlsZU92ZXJ2aWV3ID0gdGFncy5maW5kKHQgPT4gdC50YWdOYW1lID09PSAnZmlsZW92ZXJ2aWV3Jyk7XG4gIGlmICghZmlsZU92ZXJ2aWV3KSB7XG4gICAgZmlsZU92ZXJ2aWV3ID0ge3RhZ05hbWU6ICdmaWxlb3ZlcnZpZXcnLCB0ZXh0OiAnYWRkZWQgYnkgdHNpY2tsZSd9O1xuICAgIHRhZ3Muc3BsaWNlKDAsIDAsIGZpbGVPdmVydmlldyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMucm9vdERpciAhPSBudWxsKSB7XG4gICAgLy8gVGhpcyBjb21tZW50IGlzIHJlYWQgYnkgb3RoZXIgdG9vbHMgc28gaXQncyBpbXBvcnRhbnQgdGhhdCBpdHMgZm9ybWF0XG4gICAgLy8gZG9lc24ndCBjaGFuZ2UuXG4gICAgZmlsZU92ZXJ2aWV3LnRleHQgKz0gYFxcbkdlbmVyYXRlZCBmcm9tOiAke3BhdGgucmVsYXRpdmUob3B0aW9ucy5yb290RGlyLCBzb3VyY2UuZmlsZU5hbWUpfWA7XG4gIH1cblxuICAvLyBGaW5kIG9yIGNyZWF0ZSBhIEBzdXBwcmVzcyB0YWcuXG4gIC8vIENsb3N1cmUgY29tcGlsZXIgYmFyZnMgaWYgdGhlcmUncyBhIGR1cGxpY2F0ZWQgQHN1cHByZXNzIHRhZyBpbiBhIGZpbGUsIHNvIHRoZSB0YWcgbXVzdFxuICAvLyBvbmx5IGFwcGVhciBvbmNlIGFuZCBiZSBtZXJnZWQuXG4gIGxldCBzdXBwcmVzc1RhZyA9IHRhZ3MuZmluZCh0ID0+IHQudGFnTmFtZSA9PT0gJ3N1cHByZXNzJyk7XG4gIGxldCBzdXBwcmVzc2lvbnM6IFNldDxzdHJpbmc+O1xuICBpZiAoc3VwcHJlc3NUYWcpIHtcbiAgICBzdXBwcmVzc2lvbnMgPSBuZXcgU2V0KChzdXBwcmVzc1RhZy50eXBlIHx8ICcnKS5zcGxpdCgnLCcpLm1hcChzID0+IHMudHJpbSgpKSk7XG4gIH0gZWxzZSB7XG4gICAgc3VwcHJlc3NUYWcgPSB7dGFnTmFtZTogJ3N1cHByZXNzJywgdGV4dDogJ2NoZWNrZWQgYnkgdHNjJ307XG4gICAgLy8gU3BlY2lhbCBjYXNlIHRoZSBAbGljZW5zZSB0YWcgYmVjYXVzZSBhbGwgdGV4dCBmb2xsb3dpbmcgdGhpcyB0YWcgaXNcbiAgICAvLyB0cmVhdGVkIGJ5IHRoZSBjb21waWxlciBhcyBwYXJ0IG9mIHRoZSBsaWNlbnNlLCBzbyB3ZSBuZWVkIHRvIHBsYWNlIHRoZVxuICAgIC8vIG5ldyBAc3VwcHJlc3MgdGFnIGJlZm9yZSBAbGljZW5zZS5cbiAgICBjb25zdCBsaWNlbnNlVGFnSW5kZXggPSB0YWdzLmZpbmRJbmRleCh0ID0+IHQudGFnTmFtZSA9PT0gJ2xpY2Vuc2UnKTtcbiAgICBpZiAobGljZW5zZVRhZ0luZGV4ICE9PSAtMSkge1xuICAgICAgdGFncy5zcGxpY2UobGljZW5zZVRhZ0luZGV4LCAwLCBzdXBwcmVzc1RhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ3MucHVzaChzdXBwcmVzc1RhZyk7XG4gICAgfVxuICAgIHN1cHByZXNzaW9ucyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSBvdXIgc3VwcHJlc3Npb25zIGFyZSBpbmNsdWRlZCBpbiB0aGUgQHN1cHByZXNzIHRhZzpcbiAgLy8gKiBTdXBwcmVzcyBjaGVja1R5cGVzLiAgV2UgYmVsaWV2ZSB0aGUgY29kZSBoYXMgYWxyZWFkeSBiZWVuIHR5cGUtY2hlY2tlZFxuICAvLyBieSBUeXBlU2NyaXB0LCBhbmQgd2UgY2Fubm90IG1vZGVsIGFsbCB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlY2lzaW9ucyBpblxuICAvLyBDbG9zdXJlIHN5bnRheC5cbiAgc3VwcHJlc3Npb25zLmFkZCgnY2hlY2tUeXBlcycpO1xuICAvLyAqIFN1cHByZXNzIGV4dHJhUmVxdWlyZS4gIFdlIHJlbW92ZSBleHRyYSByZXF1aXJlcyBhdCB0aGUgVHlwZVNjcmlwdCBsZXZlbCxcbiAgLy8gc28gYW55IHJlcXVpcmUgdGhhdCBnZXRzIHRvIHRoZSBKUyBsZXZlbCBpcyBhIGxvYWQtYmVhcmluZyByZXF1aXJlLlxuICBzdXBwcmVzc2lvbnMuYWRkKCdleHRyYVJlcXVpcmUnKTtcbiAgLy8gKiBUeXBlcyByZWZlcmVuY2VzIGFyZSBwcm9wYWdhdGVkIGJldHdlZW4gZmlsZXMgZXZlbiB3aGVuIHRoZXkgYXJlIG5vdFxuICAvLyBkaXJlY3RseSBpbXBvcnRlZC4gV2hpbGUgdGhlc2UgYXJlIHZpb2xhdGlvbnMgb2YgdGhlIFwibWlzc2luZyByZXF1aXJlXCJcbiAgLy8gcnVsZXMgdGhleSBhcmUgYmVsaWV2ZWQgdG8gYmUgc2FmZS5cbiAgc3VwcHJlc3Npb25zLmFkZCgnbWlzc2luZ1JlcXVpcmUnKTtcbiAgLy8gKiBTdXBwcmVzcyB1c2VsZXNzQ29kZS4gIFdlIGVtaXQgYW4gXCJpZiAoZmFsc2UpXCIgYXJvdW5kIHR5cGUgZGVjbGFyYXRpb25zLFxuICAvLyB3aGljaCBpcyBmbGFnZ2VkIGFzIHVudXNlZCBjb2RlIHVubGVzcyB3ZSBzdXBwcmVzcyBpdC5cbiAgc3VwcHJlc3Npb25zLmFkZCgndXNlbGVzc0NvZGUnKTtcbiAgLy8gKiBTdXBwcmVzcyBzb21lIGNoZWNrcyBmb3IgdXNlciBlcnJvcnMgdGhhdCBUUyBhbHJlYWR5IGNoZWNrcy5cbiAgc3VwcHJlc3Npb25zLmFkZCgnbWlzc2luZ1JldHVybicpO1xuICBzdXBwcmVzc2lvbnMuYWRkKCd1bnVzZWRQcml2YXRlTWVtYmVycycpO1xuICAvLyAqIFN1cHByZXNzIGNoZWNraW5nIGZvciBAb3ZlcnJpZGUsIGJlY2F1c2UgVFMgZG9lc24ndCBtb2RlbCBpdC5cbiAgc3VwcHJlc3Npb25zLmFkZCgnbWlzc2luZ092ZXJyaWRlJyk7XG4gIC8vICogU3VwcHJlc3MgY29uc3RhbnRQcm9wZXJ0eSBjaGVja2luZywgd2hpY2ggZXJyb3JzIHdoZW4gYSBuYW1lc3BhY2UgaXNcbiAgLy8gcmVvcGVuZWQuIE5hbWVzcGFjZSByZW9wZW5pbmcgaGFwcGVucyB3aGVuIG9uZSB3cml0ZXMgbmFtZXNwYWNlIGZvbyB7fVxuICAvLyBvciBuYW1lc3BhY2UgZm9vLioge30gbW9yZSB0aGFuIG9uY2UuXG4gIHN1cHByZXNzaW9ucy5hZGQoJ2NvbnN0YW50UHJvcGVydHknKTtcblxuICBzdXBwcmVzc1RhZy50eXBlID0gQXJyYXkuZnJvbShzdXBwcmVzc2lvbnMudmFsdWVzKCkpLnNvcnQoKS5qb2luKCcsJyk7XG5cbiAgcmV0dXJuIHRhZ3M7XG59XG5cbi8qKlxuICogQSB0cmFuc2Zvcm1lciB0aGF0IGVuc3VyZXMgdGhlIGVtaXR0ZWQgSlMgZmlsZSBoYXMgYW4gXFxAZmlsZW92ZXJ2aWV3IGNvbW1lbnQgdGhhdCBjb250YWlucyBhblxuICogXFxAc3VwcHJlc3Mge2NoZWNrVHlwZXN9IGFubm90YXRpb24gYnkgZWl0aGVyIGFkZGluZyBvciB1cGRhdGluZyBhbiBleGlzdGluZyBjb21tZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRmlsZW92ZXJ2aWV3Q29tbWVudEZhY3RvcnkoXG4gICAgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zLCBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdKSB7XG4gIHJldHVybiAoKTogKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpID0+IHRzLlNvdXJjZUZpbGUgPT4ge1xuICAgIGZ1bmN0aW9uIGNoZWNrTm9GaWxlb3ZlcnZpZXdDb21tZW50cyhcbiAgICAgICAgY29udGV4dDogdHMuTm9kZSwgY29tbWVudHM6IGpzZG9jLlN5bnRoZXNpemVkQ29tbWVudFdpdGhPcmlnaW5hbFtdLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICAgIGZvciAoY29uc3QgY29tbWVudCBvZiBjb21tZW50cykge1xuICAgICAgICBjb25zdCBwYXJzZSA9IGpzZG9jLnBhcnNlKGNvbW1lbnQpO1xuICAgICAgICBpZiAocGFyc2UgIT09IG51bGwgJiYgcGFyc2UudGFncy5zb21lKHQgPT4gRklMRU9WRVJWSUVXX0NPTU1FTlRfTUFSS0VSUy5oYXModC50YWdOYW1lKSkpIHtcbiAgICAgICAgICAvLyBSZXBvcnQgYSB3YXJuaW5nOyB0aGlzIHNob3VsZCBub3QgYnJlYWsgY29tcGlsYXRpb24gaW4gdGhpcmQgcGFydHkgY29kZS5cbiAgICAgICAgICByZXBvcnREaWFnbm9zdGljKFxuICAgICAgICAgICAgICBkaWFnbm9zdGljcywgY29udGV4dCwgbWVzc2FnZSwgY29tbWVudC5vcmlnaW5hbFJhbmdlLCB0cy5EaWFnbm9zdGljQ2F0ZWdvcnkuV2FybmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSBzb3VyY2VGaWxlLmdldEZ1bGxUZXh0KCk7XG5cbiAgICAgIGxldCBmaWxlQ29tbWVudHM6IHRzLlN5bnRoZXNpemVkQ29tbWVudFtdID0gW107XG4gICAgICBjb25zdCBmaXJzdFN0YXRlbWVudCA9IHNvdXJjZUZpbGUuc3RhdGVtZW50cy5sZW5ndGggJiYgc291cmNlRmlsZS5zdGF0ZW1lbnRzWzBdIHx8IG51bGw7XG5cbiAgICAgIGNvbnN0IG9yaWdpbmFsQ29tbWVudHMgPSB0cy5nZXRMZWFkaW5nQ29tbWVudFJhbmdlcyh0ZXh0LCAwKSB8fCBbXTtcbiAgICAgIGlmICghZmlyc3RTdGF0ZW1lbnQpIHtcbiAgICAgICAgLy8gSW4gYW4gZW1wdHkgc291cmNlIGZpbGUsIGFsbCBjb21tZW50cyBhcmUgZmlsZS1sZXZlbCBjb21tZW50cy5cbiAgICAgICAgZmlsZUNvbW1lbnRzID0gc3ludGhlc2l6ZUNvbW1lbnRSYW5nZXMoc291cmNlRmlsZSwgb3JpZ2luYWxDb21tZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZWFyY2ggZm9yIHRoZSBsYXN0IGNvbW1lbnQgc3BsaXQgZnJvbSB0aGUgZmlsZSB3aXRoIGEgXFxuXFxuLiBBbGwgY29tbWVudHMgYmVmb3JlIHRoYXQgYXJlXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgZmlsZW92ZXJ2aWV3IGNvbW1lbnRzLCBhbGwgY29tbWVudHMgYWZ0ZXIgdGhhdCBiZWxvbmcgdG8gdGhlIG5leHRcbiAgICAgICAgLy8gc3RhdGVtZW50KHMpLiBJZiBub25lIGZvdW5kLCBjb21tZW50cyByZW1haW5zIGVtcHR5LCBhbmQgdGhlIGNvZGUgYmVsb3cgd2lsbCBpbnNlcnQgYSBuZXdcbiAgICAgICAgLy8gZmlsZW92ZXJ2aWV3IGNvbW1lbnQuXG4gICAgICAgIGZvciAobGV0IGkgPSBvcmlnaW5hbENvbW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZW5kID0gb3JpZ2luYWxDb21tZW50c1tpXS5lbmQ7XG4gICAgICAgICAgaWYgKCF0ZXh0LnN1YnN0cmluZyhlbmQpLnN0YXJ0c1dpdGgoJ1xcblxcbicpICYmXG4gICAgICAgICAgICAgICF0ZXh0LnN1YnN0cmluZyhlbmQpLnN0YXJ0c1dpdGgoJ1xcclxcblxcclxcbicpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhpcyBjb21tZW50IGlzIHNlcGFyYXRlZCBmcm9tIHRoZSBzb3VyY2UgZmlsZSB3aXRoIGEgZG91YmxlIGJyZWFrLCBtYXJraW5nIGl0IChhbmQgYW55XG4gICAgICAgICAgLy8gcHJlY2VkaW5nIGNvbW1lbnRzKSBhcyBhIGZpbGUtbGV2ZWwgY29tbWVudC4gU3BsaXQgdGhlbSBvZmYgYW5kIGF0dGFjaCB0aGVtIG9udG8gYVxuICAgICAgICAgIC8vIE5vdEVtaXR0ZWRTdGF0ZW1lbnQsIHNvIHRoYXQgdGhleSBkbyBub3QgZ2V0IGxvc3QgbGF0ZXIgb24uXG4gICAgICAgICAgY29uc3Qgc3ludGhlc2l6ZWRDb21tZW50cyA9IGpzZG9jLnN5bnRoZXNpemVMZWFkaW5nQ29tbWVudHMoZmlyc3RTdGF0ZW1lbnQpO1xuICAgICAgICAgIGNvbnN0IG5vdEVtaXR0ZWQgPSB0cy5jcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50KHNvdXJjZUZpbGUpO1xuICAgICAgICAgIC8vIE1vZGlmeSB0aGUgY29tbWVudHMgb24gdGhlIGZpcnN0U3RhdGVtZW50IGluIHBsYWNlIGJ5IHJlbW92aW5nIHRoZSBmaWxlLWxldmVsIGNvbW1lbnRzLlxuICAgICAgICAgIGZpbGVDb21tZW50cyA9IHN5bnRoZXNpemVkQ29tbWVudHMuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgICAvLyBNb3ZlIHRoZSBmaWxlQ29tbWVudHMgb250byBub3RFbWl0dGVkLlxuICAgICAgICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhub3RFbWl0dGVkLCBmaWxlQ29tbWVudHMpO1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1cGRhdGVTb3VyY2VGaWxlTm9kZShcbiAgICAgICAgICAgICAgc291cmNlRmlsZSxcbiAgICAgICAgICAgICAgdHMuY3JlYXRlTm9kZUFycmF5KFtub3RFbWl0dGVkLCBmaXJzdFN0YXRlbWVudCwgLi4uc291cmNlRmlsZS5zdGF0ZW1lbnRzLnNsaWNlKDEpXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBOb3cgd2FsayBldmVyeSB0b3AgbGV2ZWwgc3RhdGVtZW50IGFuZCBlc2NhcGUvZHJvcCBhbnkgQGZpbGVvdmVydmlldyBjb21tZW50cyBmb3VuZC5cbiAgICAgICAgLy8gQ2xvc3VyZSBpZ25vcmVzIGFsbCBAZmlsZW92ZXJ2aWV3IGNvbW1lbnRzIGJ1dCB0aGUgbGFzdCwgc28gdHNpY2tsZSBtdXN0IG1ha2Ugc3VyZSBub3QgdG9cbiAgICAgICAgLy8gZW1pdCBkdXBsaWNhdGVkIG9uZXMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlRmlsZS5zdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc3RtdCA9IHNvdXJjZUZpbGUuc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAvLyBBY2NlcHQgdGhlIE5vdEVtaXR0ZWRTdGF0ZW1lbnQgaW5zZXJ0ZWQgYWJvdmUuXG4gICAgICAgICAgaWYgKGkgPT09IDAgJiYgc3RtdC5raW5kID09PSB0cy5TeW50YXhLaW5kLk5vdEVtaXR0ZWRTdGF0ZW1lbnQpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnRzID0ganNkb2Muc3ludGhlc2l6ZUxlYWRpbmdDb21tZW50cyhzdG10KTtcbiAgICAgICAgICBjaGVja05vRmlsZW92ZXJ2aWV3Q29tbWVudHMoXG4gICAgICAgICAgICAgIHN0bXQsIGNvbW1lbnRzLFxuICAgICAgICAgICAgICBgZmlsZSBjb21tZW50cyBtdXN0IGJlIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUsIGAgK1xuICAgICAgICAgICAgICAgICAgYHNlcGFyYXRlZCBmcm9tIHRoZSBmaWxlIGJvZHkgYnkgYW4gZW1wdHkgbGluZS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDbG9zdXJlIENvbXBpbGVyIGNvbnNpZGVycyB0aGUgKmxhc3QqIGNvbW1lbnQgd2l0aCBAZmlsZW92ZXJ2aWV3IChvciAjZXh0ZXJucyBvclxuICAgICAgLy8gQG5vY29tcGlsZSkgdGhhdCBoYXMgbm90IGJlZW4gYXR0YWNoZWQgdG8gc29tZSBvdGhlciB0cmVlIG5vZGUgdG8gYmUgdGhlIGZpbGUgb3ZlcnZpZXdcbiAgICAgIC8vIGNvbW1lbnQsIGFuZCBvbmx5IGFwcGxpZXMgQHN1cHByZXNzIHRhZ3MgZnJvbSBpdC4gR29vZ2xlLWludGVybmFsIHRvb2xpbmcgY29uc2lkZXJzICphbnkqXG4gICAgICAvLyBjb21tZW50IG1lbnRpb25pbmcgQGZpbGVvdmVydmlldy5cbiAgICAgIGxldCBmaWxlb3ZlcnZpZXdJZHggPSAtMTtcbiAgICAgIGxldCB0YWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IGZpbGVDb21tZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBwYXJzZSA9IGpzZG9jLnBhcnNlQ29udGVudHMoZmlsZUNvbW1lbnRzW2ldLnRleHQpO1xuICAgICAgICBpZiAocGFyc2UgIT09IG51bGwgJiYgcGFyc2UudGFncy5zb21lKHQgPT4gRklMRU9WRVJWSUVXX0NPTU1FTlRfTUFSS0VSUy5oYXModC50YWdOYW1lKSkpIHtcbiAgICAgICAgICBmaWxlb3ZlcnZpZXdJZHggPSBpO1xuICAgICAgICAgIHRhZ3MgPSBwYXJzZS50YWdzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxlb3ZlcnZpZXdJZHggIT09IC0xKSB7XG4gICAgICAgIGNoZWNrTm9GaWxlb3ZlcnZpZXdDb21tZW50cyhcbiAgICAgICAgICAgIGZpcnN0U3RhdGVtZW50IHx8IHNvdXJjZUZpbGUsIGZpbGVDb21tZW50cy5zbGljZSgwLCBmaWxlb3ZlcnZpZXdJZHgpLFxuICAgICAgICAgICAgYGR1cGxpY2F0ZSBmaWxlIGxldmVsIGNvbW1lbnRgKTtcbiAgICAgIH1cblxuICAgICAgYXVnbWVudEZpbGVvdmVydmlld0NvbW1lbnRzKG9wdGlvbnMsIHNvdXJjZUZpbGUsIHRhZ3MpO1xuICAgICAgY29uc3QgY29tbWVudFRleHQgPSBqc2RvYy50b1N0cmluZ1dpdGhvdXRTdGFydEVuZCh0YWdzKTtcblxuICAgICAgaWYgKGZpbGVvdmVydmlld0lkeCA8IDApIHtcbiAgICAgICAgLy8gTm8gZXhpc3RpbmcgY29tbWVudCB0byBtZXJnZSB3aXRoLCBqdXN0IGVtaXQgYSBuZXcgb25lLlxuICAgICAgICByZXR1cm4gYWRkTmV3RmlsZW92ZXJ2aWV3Q29tbWVudChzb3VyY2VGaWxlLCBjb21tZW50VGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGZpbGVDb21tZW50c1tmaWxlb3ZlcnZpZXdJZHhdLnRleHQgPSBjb21tZW50VGV4dDtcbiAgICAgIC8vIHNmIGRvZXMgbm90IG5lZWQgdG8gYmUgdXBkYXRlZCwgc3ludGhlc2l6ZWQgY29tbWVudHMgYXJlIG11dGFibGUuXG4gICAgICByZXR1cm4gc291cmNlRmlsZTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGROZXdGaWxlb3ZlcnZpZXdDb21tZW50KHNmOiB0cy5Tb3VyY2VGaWxlLCBjb21tZW50VGV4dDogc3RyaW5nKTogdHMuU291cmNlRmlsZSB7XG4gIGxldCBzeW50aGV0aWNGaXJzdFN0YXRlbWVudCA9IGNyZWF0ZU5vdEVtaXR0ZWRTdGF0ZW1lbnQoc2YpO1xuICBzeW50aGV0aWNGaXJzdFN0YXRlbWVudCA9IHRzLmFkZFN5bnRoZXRpY1RyYWlsaW5nQ29tbWVudChcbiAgICAgIHN5bnRoZXRpY0ZpcnN0U3RhdGVtZW50LCB0cy5TeW50YXhLaW5kLk11bHRpTGluZUNvbW1lbnRUcml2aWEsIGNvbW1lbnRUZXh0LCB0cnVlKTtcbiAgcmV0dXJuIHVwZGF0ZVNvdXJjZUZpbGVOb2RlKHNmLCB0cy5jcmVhdGVOb2RlQXJyYXkoW3N5bnRoZXRpY0ZpcnN0U3RhdGVtZW50LCAuLi5zZi5zdGF0ZW1lbnRzXSkpO1xufVxuIl19