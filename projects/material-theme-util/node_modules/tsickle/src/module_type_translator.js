/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/module_type_translator", ["require", "exports", "typescript", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/transformer_util", "tsickle/src/type_translator"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModuleTypeTranslator = exports.MutableJSDoc = void 0;
    /**
     * @fileoverview module_type_translator builds on top of type_translator, adding functionality to
     * translate types within the scope of a single module. The main entry point is
     * ModuleTypeTranslator.
     */
    const ts = require("typescript");
    const googmodule = require("tsickle/src/googmodule");
    const jsdoc = require("tsickle/src/jsdoc");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    const typeTranslator = require("tsickle/src/type_translator");
    /**
     * MutableJSDoc encapsulates a (potential) JSDoc comment on a specific node, and allows code to
     * modify (including delete) it.
     */
    class MutableJSDoc {
        constructor(node, sourceComment, tags) {
            this.node = node;
            this.sourceComment = sourceComment;
            this.tags = tags;
        }
        updateComment(escapeExtraTags) {
            const text = jsdoc.toStringWithoutStartEnd(this.tags, escapeExtraTags);
            if (this.sourceComment) {
                if (!text) {
                    // Delete the (now empty) comment.
                    const comments = ts.getSyntheticLeadingComments(this.node);
                    const idx = comments.indexOf(this.sourceComment);
                    comments.splice(idx, 1);
                    this.sourceComment = null;
                    return;
                }
                this.sourceComment.text = text;
                return;
            }
            // Don't add an empty comment.
            if (!text)
                return;
            const comment = {
                kind: ts.SyntaxKind.MultiLineCommentTrivia,
                text,
                hasTrailingNewLine: true,
                pos: -1,
                end: -1,
            };
            const comments = ts.getSyntheticLeadingComments(this.node) || [];
            comments.push(comment);
            ts.setSyntheticLeadingComments(this.node, comments);
        }
    }
    exports.MutableJSDoc = MutableJSDoc;
    /** Returns the Closure name of a function parameter, special-casing destructuring. */
    function getParameterName(param, index) {
        switch (param.name.kind) {
            case ts.SyntaxKind.Identifier:
                let name = transformer_util_1.getIdentifierText(param.name);
                // TypeScript allows parameters named "arguments", but Closure
                // disallows this, even in externs.
                if (name === 'arguments')
                    name = 'tsickle_arguments';
                return name;
            case ts.SyntaxKind.ArrayBindingPattern:
            case ts.SyntaxKind.ObjectBindingPattern:
                // Closure crashes if you put a binding pattern in the externs.
                // Avoid this by just generating an unused name; the name is
                // ignored anyway.
                return `__${index}`;
            default:
                // The above list of kinds is exhaustive.  param.name is 'never' at this point.
                const paramName = param.name;
                throw new Error(`unhandled function parameter kind: ${ts.SyntaxKind[paramName.kind]}`);
        }
    }
    /**
     * ModuleTypeTranslator encapsulates knowledge and helper functions to translate types in the scope
     * of a specific module. This includes managing Closure requireType statements and any symbol
     * aliases in scope for a whole file.
     */
    class ModuleTypeTranslator {
        constructor(sourceFile, typeChecker, host, diagnostics, isForExterns) {
            this.sourceFile = sourceFile;
            this.typeChecker = typeChecker;
            this.host = host;
            this.diagnostics = diagnostics;
            this.isForExterns = isForExterns;
            /**
             * A mapping of aliases for symbols in the current file, used when emitting types. TypeScript
             * emits imported symbols with unpredictable prefixes. To generate correct type annotations,
             * tsickle creates its own aliases for types, and registers them in this map (see
             * `emitImportDeclaration` and `requireType()` below). The aliases are then used when emitting
             * types.
             */
            this.symbolsToAliasedNames = new Map();
            /**
             * A cache for expensive symbol lookups, see TypeTranslator.symbolToString. Maps symbols to their
             * Closure name in this file scope.
             */
            this.symbolToNameCache = new Map();
            /**
             * The set of module symbols requireTyped in the local namespace.  This tracks which imported
             * modules we've already added to additionalImports below.
             */
            this.requireTypeModules = new Set();
            /**
             * The list of generated goog.requireType statements for this module. These are inserted into
             * the module's body statements after translation.
             */
            this.additionalImports = [];
        }
        debugWarn(context, messageText) {
            transformer_util_1.reportDebugWarning(this.host, context, messageText);
        }
        error(node, messageText) {
            transformer_util_1.reportDiagnostic(this.diagnostics, node, messageText);
        }
        /**
         * Convert a TypeScript ts.Type into the equivalent Closure type.
         *
         * @param context The ts.Node containing the type reference; used for resolving symbols
         *     in context.
         * @param type The type to translate; if not provided, the Node's type will be used.
         * @param resolveAlias If true, do not emit aliases as their symbol, but rather as the resolved
         *     type underlying the alias. This should be true only when emitting the typedef itself.
         */
        typeToClosure(context, type) {
            if (this.host.untyped) {
                return '?';
            }
            const typeChecker = this.typeChecker;
            if (!type) {
                type = typeChecker.getTypeAtLocation(context);
            }
            return this.newTypeTranslator(context).translate(type);
        }
        newTypeTranslator(context) {
            // In externs, there is no local scope, so all types must be relative to the file level scope.
            const translationContext = this.isForExterns ? this.sourceFile : context;
            const translator = new typeTranslator.TypeTranslator(this.host, this.typeChecker, translationContext, this.host.typeBlackListPaths || new Set(), this.symbolsToAliasedNames, this.symbolToNameCache, (sym) => this.ensureSymbolDeclared(sym));
            translator.isForExterns = this.isForExterns;
            translator.warn = msg => this.debugWarn(context, msg);
            return translator;
        }
        isBlackListed(context) {
            const type = this.typeChecker.getTypeAtLocation(context);
            let sym = type.symbol;
            if (!sym)
                return false;
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = this.typeChecker.getAliasedSymbol(sym);
            }
            return this.newTypeTranslator(context).isBlackListed(sym);
        }
        /**
         * Get the ts.Symbol at a location or throw.
         * The TypeScript API can return undefined when fetching a symbol, but in many contexts we know it
         * won't (e.g. our input is already type-checked).
         */
        mustGetSymbolAtLocation(node) {
            const sym = this.typeChecker.getSymbolAtLocation(node);
            if (!sym)
                throw new Error('no symbol');
            return sym;
        }
        /** Finds an exported (i.e. not global) declaration for the given symbol. */
        findExportedDeclaration(sym) {
            // TODO(martinprobst): it's unclear when a symbol wouldn't have a declaration, maybe just for
            // some builtins (e.g. Symbol)?
            if (!sym.declarations || sym.declarations.length === 0)
                return undefined;
            // A symbol declared in this file does not need to be imported.
            if (sym.declarations.some(d => d.getSourceFile() === this.sourceFile))
                return undefined;
            // Find an exported declaration.
            // Because tsickle runs with the --declaration flag, all types referenced from exported types
            // must be exported, too, so there must either be some declaration that is exported, or the
            // symbol is actually a global declaration (declared in a script file, not a module).
            const decl = sym.declarations.find(d => {
                // Check for Export | Default (default being a default export).
                if (!transformer_util_1.hasModifierFlag(d, ts.ModifierFlags.ExportDefault))
                    return false;
                // Exclude symbols declared in `declare global {...}` blocks, they are global and don't need
                // imports.
                let current = d;
                while (current) {
                    if (current.flags & ts.NodeFlags.GlobalAugmentation)
                        return false;
                    current = current.parent;
                }
                return true;
            });
            return decl;
        }
        /**
         * Generates a somewhat human-readable module prefix for the given import context, to make
         * debugging the emitted Closure types a bit easier.
         */
        generateModulePrefix(importPath) {
            const modulePrefix = importPath.replace(/(\/index)?(\.d)?\.[tj]sx?$/, '')
                .replace(/^.*[/.](.+?)/, '$1')
                .replace(/\W/g, '_');
            return `tsickle_${modulePrefix || 'reqType'}_`;
        }
        /**
         * Records that we we want a `const x = goog.requireType...` import of the given `importPath`,
         * which will be inserted when we emit.
         * This also registers aliases for symbols from the module that map to this requireType.
         *
         * @param isDefaultImport True if the import statement is a default import, e.g.
         *     `import Foo from ...;`, which matters for adjusting whether we emit a `.default`.
         */
        requireType(importPath, moduleSymbol, isDefaultImport = false) {
            if (this.host.untyped)
                return;
            // Already imported? Do not emit a duplicate requireType.
            if (this.requireTypeModules.has(moduleSymbol))
                return;
            if (typeTranslator.isBlacklisted(this.host.typeBlackListPaths, moduleSymbol)) {
                return; // Do not emit goog.requireType for blacklisted paths.
            }
            const nsImport = googmodule.extractGoogNamespaceImport(importPath);
            const requireTypePrefix = this.generateModulePrefix(importPath) + String(this.requireTypeModules.size + 1);
            const moduleNamespace = nsImport !== null ?
                nsImport :
                this.host.pathToModuleName(this.sourceFile.fileName, importPath);
            // In TypeScript, importing a module for use in a type annotation does not cause a runtime load.
            // In Closure Compiler, goog.require'ing a module causes a runtime load, so emitting requires
            // here would cause a change in load order, which is observable (and can lead to errors).
            // Instead, goog.requireType types, which allows using them in type annotations without
            // causing a load.
            //   const requireTypePrefix = goog.requireType(moduleNamespace)
            this.additionalImports.push(ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(requireTypePrefix, undefined, ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), 'requireType'), undefined, [ts.createLiteral(moduleNamespace)]))], ts.NodeFlags.Const)));
            this.requireTypeModules.add(moduleSymbol);
            for (let sym of this.typeChecker.getExportsOfModule(moduleSymbol)) {
                // Some users import {default as SomeAlias} from 'goog:...';
                // The code below must recognize this as a default import to alias the symbol to just the
                // blank module name.
                const namedDefaultImport = sym.name === 'default';
                // goog: imports don't actually use the .default property that TS thinks they have.
                const qualifiedName = nsImport && (isDefaultImport || namedDefaultImport) ?
                    requireTypePrefix :
                    requireTypePrefix + '.' + sym.name;
                if (sym.flags & ts.SymbolFlags.Alias) {
                    sym = this.typeChecker.getAliasedSymbol(sym);
                }
                this.symbolsToAliasedNames.set(sym, qualifiedName);
            }
        }
        ensureSymbolDeclared(sym) {
            const decl = this.findExportedDeclaration(sym);
            if (!decl)
                return;
            if (this.isForExterns) {
                this.error(decl, `declaration from module used in ambient type: ${sym.name}`);
                return;
            }
            // Actually import the symbol.
            const sourceFile = decl.getSourceFile();
            if (sourceFile === ts.getOriginalNode(this.sourceFile))
                return;
            const moduleSymbol = this.typeChecker.getSymbolAtLocation(sourceFile);
            // A source file might not have a symbol if it's not a module (no ES6 im/exports).
            if (!moduleSymbol)
                return;
            // TODO(martinprobst): this should possibly use fileNameToModuleId.
            this.requireType(sourceFile.fileName, moduleSymbol);
        }
        insertAdditionalImports(sourceFile) {
            let insertion = 0;
            // Skip over a leading file comment holder.
            if (sourceFile.statements.length &&
                sourceFile.statements[0].kind === ts.SyntaxKind.NotEmittedStatement) {
                insertion++;
            }
            return ts.updateSourceFileNode(sourceFile, [
                ...sourceFile.statements.slice(0, insertion),
                ...this.additionalImports,
                ...sourceFile.statements.slice(insertion),
            ]);
        }
        /**
         * Parses and synthesizes comments on node, and returns the JSDoc from it, if any.
         * @param reportWarnings if true, will report warnings from parsing the JSDoc. Set to false if
         *     this is not the "main" location dealing with a node to avoid duplicated warnings.
         */
        getJSDoc(node, reportWarnings) {
            const [tags,] = this.parseJSDoc(node, reportWarnings);
            return tags;
        }
        getMutableJSDoc(node) {
            const [tags, comment] = this.parseJSDoc(node, /* reportWarnings */ true);
            return new MutableJSDoc(node, comment, tags);
        }
        parseJSDoc(node, reportWarnings) {
            // synthesizeLeadingComments below changes text locations for node, so extract the location here
            // in case it is needed later to report diagnostics.
            const start = node.getFullStart();
            const length = node.getLeadingTriviaWidth(this.sourceFile);
            const comments = jsdoc.synthesizeLeadingComments(node);
            if (!comments || comments.length === 0)
                return [[], null];
            for (let i = comments.length - 1; i >= 0; i--) {
                const comment = comments[i];
                const parsed = jsdoc.parse(comment);
                if (parsed) {
                    if (reportWarnings && parsed.warnings) {
                        const range = comment.originalRange || { pos: start, end: start + length };
                        transformer_util_1.reportDiagnostic(this.diagnostics, node, parsed.warnings.join('\n'), range, ts.DiagnosticCategory.Warning);
                    }
                    return [parsed.tags, comment];
                }
            }
            return [[], null];
        }
        /**
         * resolveRestParameterType resolves the array member type for a rest parameter ("...").
         * In TypeScript you write "...x: number[]", but in Closure you don't write the array:
         * `@param {...number} x`. The code below unwraps the Array<> wrapper.
         */
        resolveRestParameterType(newTag, fnDecl, paramNode) {
            let type = this.typeChecker.getTypeAtLocation(paramNode);
            newTag.restParam = true;
            if ((type.flags & ts.TypeFlags.Object) === 0 && type.flags & ts.TypeFlags.TypeParameter) {
                // function f<T extends string[]>(...ts: T) has the Array type on the type parameter
                // constraint, not on the parameter itself. Resolve it.
                const baseConstraint = this.typeChecker.getBaseConstraintOfType(type);
                if (baseConstraint)
                    type = baseConstraint;
            }
            if ((type.flags & ts.TypeFlags.Object) !== 0 &&
                type.objectFlags & ts.ObjectFlags.Reference) {
                const typeRef = type;
                const typeArgs = this.typeChecker.getTypeArguments(typeRef);
                if (!typeArgs) {
                    throw new Error('rest parameter does not resolve to a reference type');
                }
                newTag.type = this.typeToClosure(fnDecl, typeArgs[0]);
                return;
            }
            // If we fail to unwrap the Array<> type, emit an unknown type.
            this.debugWarn(paramNode, 'failed to resolve rest parameter type, emitting ?');
            newTag.type = '?';
        }
        /**
         * Creates the jsdoc for methods, including overloads.
         * If overloaded, merges the signatures in the list of SignatureDeclarations into a single jsdoc.
         * - Total number of parameters will be the maximum count found across all variants.
         * - Different names at the same parameter index will be joined with "_or_"
         * - Variable args (...type[] in TypeScript) will be output as "...type",
         *    except if found at the same index as another argument.
         * @param fnDecls Pass > 1 declaration for overloads of same name
         * @return The list of parameter names that should be used to emit the actual
         *    function statement; for overloads, name will have been merged.
         */
        getFunctionTypeJSDoc(fnDecls, extraTags = []) {
            const typeChecker = this.typeChecker;
            // De-duplicate tags and docs found for the fnDecls.
            const tagsByName = new Map();
            function addTag(tag) {
                const existing = tagsByName.get(tag.tagName);
                tagsByName.set(tag.tagName, existing ? jsdoc.merge([existing, tag]) : tag);
            }
            for (const extraTag of extraTags)
                addTag(extraTag);
            const isConstructor = fnDecls.find(d => d.kind === ts.SyntaxKind.Constructor) !== undefined;
            // For each parameter index i, paramTags[i] is an array of parameters
            // that can be found at index i.  E.g.
            //    function foo(x: string)
            //    function foo(y: number, z: string)
            // then paramTags[0] = [info about x, info about y].
            const paramTags = [];
            const returnTags = [];
            const thisTags = [];
            const typeParameterNames = new Set();
            const argCounts = [];
            let thisReturnType = null;
            for (const fnDecl of fnDecls) {
                // Construct the JSDoc comment by reading the existing JSDoc, if
                // any, and merging it with the known types of the function
                // parameters and return type.
                const tags = this.getJSDoc(fnDecl, /* reportWarnings */ false);
                // Copy all the tags other than @param/@return into the new
                // JSDoc without any change; @param/@return are handled specially.
                // TODO: there may be problems if an annotation doesn't apply to all overloads;
                // is it worth checking for this and erroring?
                for (const tag of tags) {
                    if (tag.tagName === 'param' || tag.tagName === 'return')
                        continue;
                    addTag(tag);
                }
                const flags = ts.getCombinedModifierFlags(fnDecl);
                // Add @abstract on "abstract" declarations.
                if (flags & ts.ModifierFlags.Abstract) {
                    addTag({ tagName: 'abstract' });
                }
                // Add @protected/@private if present.
                if (flags & ts.ModifierFlags.Protected) {
                    addTag({ tagName: 'protected' });
                }
                else if (flags & ts.ModifierFlags.Private) {
                    addTag({ tagName: 'private' });
                }
                // Add any @template tags.
                // Multiple declarations with the same template variable names should work:
                // the declarations get turned into union types, and Closure Compiler will need
                // to find a union where all type arguments are satisfied.
                if (fnDecl.typeParameters) {
                    for (const tp of fnDecl.typeParameters) {
                        typeParameterNames.add(transformer_util_1.getIdentifierText(tp.name));
                    }
                }
                // Merge the parameters into a single list of merged names and list of types
                const sig = typeChecker.getSignatureFromDeclaration(fnDecl);
                if (!sig || !sig.declaration)
                    throw new Error(`invalid signature ${fnDecl.name}`);
                if (sig.declaration.kind === ts.SyntaxKind.JSDocSignature) {
                    throw new Error(`JSDoc signature ${fnDecl.name}`);
                }
                let hasThisParam = false;
                for (let i = 0; i < sig.declaration.parameters.length; i++) {
                    const paramNode = sig.declaration.parameters[i];
                    const name = getParameterName(paramNode, i);
                    const isThisParam = name === 'this';
                    if (isThisParam)
                        hasThisParam = true;
                    const newTag = {
                        tagName: isThisParam ? 'this' : 'param',
                        optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,
                        parameterName: isThisParam ? undefined : name,
                    };
                    if (paramNode.dotDotDotToken === undefined) {
                        // The simple case: a plain parameter type.
                        newTag.type = this.typeToClosure(fnDecl, this.typeChecker.getTypeAtLocation(paramNode));
                    }
                    else {
                        // The complex case: resolve the array member type in ...foo[].
                        this.resolveRestParameterType(newTag, fnDecl, paramNode);
                    }
                    for (const { tagName, parameterName, text } of tags) {
                        if (tagName === 'param' && parameterName === newTag.parameterName) {
                            newTag.text = text;
                            break;
                        }
                    }
                    if (!isThisParam) {
                        const paramIdx = hasThisParam ? i - 1 : i;
                        if (!paramTags[paramIdx])
                            paramTags.push([]);
                        paramTags[paramIdx].push(newTag);
                    }
                    else {
                        thisTags.push(newTag);
                    }
                }
                argCounts.push(hasThisParam ? sig.declaration.parameters.length - 1 : sig.declaration.parameters.length);
                // Return type.
                if (!isConstructor) {
                    const returnTag = {
                        tagName: 'return',
                    };
                    const retType = typeChecker.getReturnTypeOfSignature(sig);
                    // Generate a templated `@this` tag for TypeScript `foo(): this` return type specification.
                    // Make sure not to do that if the function already has used `@this` due to a this
                    // parameter. It's not clear how to resolve the two conflicting this types best, the current
                    // solution prefers the explicitly given `this` parameter.
                    // tslint:disable-next-line:no-any accessing TS internal field.
                    if (retType['isThisType'] && !hasThisParam) {
                        // foo(): this
                        thisReturnType = retType;
                        addTag({ tagName: 'template', text: 'THIS' });
                        addTag({ tagName: 'this', type: 'THIS' });
                        returnTag.type = 'THIS';
                    }
                    else {
                        returnTag.type = this.typeToClosure(fnDecl, retType);
                        for (const { tagName, text } of tags) {
                            if (tagName === 'return') {
                                returnTag.text = text;
                                break;
                            }
                        }
                    }
                    returnTags.push(returnTag);
                }
            }
            if (typeParameterNames.size > 0) {
                addTag({ tagName: 'template', text: Array.from(typeParameterNames.values()).join(', ') });
            }
            const newDoc = Array.from(tagsByName.values());
            if (thisTags.length > 0) {
                newDoc.push(jsdoc.merge(thisTags));
            }
            const minArgsCount = Math.min(...argCounts);
            const maxArgsCount = Math.max(...argCounts);
            // Merge the JSDoc tags for each overloaded parameter.
            // Ensure each parameter has a unique name; the merging process can otherwise
            // accidentally generate the same parameter name twice.
            const paramNames = new Set();
            let foundOptional = false;
            for (let i = 0; i < maxArgsCount; i++) {
                const paramTag = jsdoc.merge(paramTags[i]);
                if (paramTag.parameterName) {
                    if (paramNames.has(paramTag.parameterName)) {
                        paramTag.parameterName += i.toString();
                    }
                    paramNames.add(paramTag.parameterName);
                }
                // If the tag is optional, mark parameters following optional as optional,
                // even if they are not, since Closure restricts this, see
                // https://github.com/google/closure-compiler/issues/2314
                if (!paramTag.restParam && (paramTag.optional || foundOptional || i >= minArgsCount)) {
                    foundOptional = true;
                    paramTag.optional = true;
                }
                newDoc.push(paramTag);
                if (paramTag.restParam) {
                    // Cannot have any parameters after a rest param.
                    // Just dump the remaining parameters.
                    break;
                }
            }
            // Merge the JSDoc tags for each overloaded return.
            if (!isConstructor) {
                newDoc.push(jsdoc.merge(returnTags));
            }
            return {
                tags: newDoc,
                parameterNames: newDoc.filter(t => t.tagName === 'param').map(t => t.parameterName),
                thisReturnType,
            };
        }
    }
    exports.ModuleTypeTranslator = ModuleTypeTranslator;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kdWxlX3R5cGVfdHJhbnNsYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVfdHlwZV90cmFuc2xhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7OztJQUVIOzs7O09BSUc7SUFFSCxpQ0FBaUM7SUFHakMscURBQTJDO0lBQzNDLDJDQUFpQztJQUNqQyxtRUFBNEc7SUFDNUcsOERBQW9EO0lBRXBEOzs7T0FHRztJQUNILE1BQWEsWUFBWTtRQUN2QixZQUNZLElBQWEsRUFBVSxhQUF5QyxFQUNqRSxJQUFpQjtZQURoQixTQUFJLEdBQUosSUFBSSxDQUFTO1lBQVUsa0JBQWEsR0FBYixhQUFhLENBQTRCO1lBQ2pFLFNBQUksR0FBSixJQUFJLENBQWE7UUFBRyxDQUFDO1FBRWhDLGFBQWEsQ0FBQyxlQUE2QjtZQUN6QyxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztZQUN2RSxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQyxJQUFJLEVBQUU7b0JBQ1Qsa0NBQWtDO29CQUNsQyxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBRSxDQUFDO29CQUM1RCxNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztvQkFDakQsUUFBUSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQ3hCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO29CQUMxQixPQUFPO2lCQUNSO2dCQUNELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztnQkFDL0IsT0FBTzthQUNSO1lBRUQsOEJBQThCO1lBQzlCLElB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LEdBQUcsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7aUJBQ3hDO2dCQUNELDBFQUEwRTtnQkFDMUUsMERBQTBEO2dCQUMxRCx5REFBeUQ7Z0JBQ3pELElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsSUFBSSxhQUFhLElBQUksQ0FBQyxJQUFJLFlBQVksQ0FBQyxFQUFFO29CQUNwRixhQUFhLEdBQUcsSUFBSSxDQUFDO29CQUNyQixRQUFRLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztpQkFDMUI7Z0JBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDdEIsSUFBSSxRQUFRLENBQUMsU0FBUyxFQUFFO29CQUN0QixpREFBaUQ7b0JBQ2pELHNDQUFzQztvQkFDdEMsTUFBTTtpQkFDUDthQUNGO1lBRUQsbURBQW1EO1lBQ25ELElBQUksQ0FBQyxhQUFhLEVBQUU7Z0JBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO2FBQ3RDO1lBRUQsT0FBTztnQkFDTCxJQUFJLEVBQUUsTUFBTTtnQkFDWixjQUFjLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWMsQ0FBQztnQkFDcEYsY0FBYzthQUNmLENBQUM7UUFDSixDQUFDO0tBQ0Y7SUE1ZUQsb0RBNGVDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgbW9kdWxlX3R5cGVfdHJhbnNsYXRvciBidWlsZHMgb24gdG9wIG9mIHR5cGVfdHJhbnNsYXRvciwgYWRkaW5nIGZ1bmN0aW9uYWxpdHkgdG9cbiAqIHRyYW5zbGF0ZSB0eXBlcyB3aXRoaW4gdGhlIHNjb3BlIG9mIGEgc2luZ2xlIG1vZHVsZS4gVGhlIG1haW4gZW50cnkgcG9pbnQgaXNcbiAqIE1vZHVsZVR5cGVUcmFuc2xhdG9yLlxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge0Fubm90YXRvckhvc3R9IGZyb20gJy4vYW5ub3RhdG9yX2hvc3QnO1xuaW1wb3J0ICogYXMgZ29vZ21vZHVsZSBmcm9tICcuL2dvb2dtb2R1bGUnO1xuaW1wb3J0ICogYXMganNkb2MgZnJvbSAnLi9qc2RvYyc7XG5pbXBvcnQge2dldElkZW50aWZpZXJUZXh0LCBoYXNNb2RpZmllckZsYWcsIHJlcG9ydERlYnVnV2FybmluZywgcmVwb3J0RGlhZ25vc3RpY30gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCAqIGFzIHR5cGVUcmFuc2xhdG9yIGZyb20gJy4vdHlwZV90cmFuc2xhdG9yJztcblxuLyoqXG4gKiBNdXRhYmxlSlNEb2MgZW5jYXBzdWxhdGVzIGEgKHBvdGVudGlhbCkgSlNEb2MgY29tbWVudCBvbiBhIHNwZWNpZmljIG5vZGUsIGFuZCBhbGxvd3MgY29kZSB0b1xuICogbW9kaWZ5IChpbmNsdWRpbmcgZGVsZXRlKSBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIE11dGFibGVKU0RvYyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBub2RlOiB0cy5Ob2RlLCBwcml2YXRlIHNvdXJjZUNvbW1lbnQ6IHRzLlN5bnRoZXNpemVkQ29tbWVudHxudWxsLFxuICAgICAgcHVibGljIHRhZ3M6IGpzZG9jLlRhZ1tdKSB7fVxuXG4gIHVwZGF0ZUNvbW1lbnQoZXNjYXBlRXh0cmFUYWdzPzogU2V0PHN0cmluZz4pIHtcbiAgICBjb25zdCB0ZXh0ID0ganNkb2MudG9TdHJpbmdXaXRob3V0U3RhcnRFbmQodGhpcy50YWdzLCBlc2NhcGVFeHRyYVRhZ3MpO1xuICAgIGlmICh0aGlzLnNvdXJjZUNvbW1lbnQpIHtcbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAvLyBEZWxldGUgdGhlIChub3cgZW1wdHkpIGNvbW1lbnQuXG4gICAgICAgIGNvbnN0IGNvbW1lbnRzID0gdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHRoaXMubm9kZSkhO1xuICAgICAgICBjb25zdCBpZHggPSBjb21tZW50cy5pbmRleE9mKHRoaXMuc291cmNlQ29tbWVudCk7XG4gICAgICAgIGNvbW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB0aGlzLnNvdXJjZUNvbW1lbnQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNvdXJjZUNvbW1lbnQudGV4dCA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgYWRkIGFuIGVtcHR5IGNvbW1lbnQuXG4gICAgaWYgKCF0ZXh0KSByZXR1cm47XG5cbiAgICBjb25zdCBjb21tZW50OiB0cy5TeW50aGVzaXplZENvbW1lbnQgPSB7XG4gICAgICBraW5kOiB0cy5TeW50YXhLaW5kLk11bHRpTGluZUNvbW1lbnRUcml2aWEsXG4gICAgICB0ZXh0LFxuICAgICAgaGFzVHJhaWxpbmdOZXdMaW5lOiB0cnVlLFxuICAgICAgcG9zOiAtMSxcbiAgICAgIGVuZDogLTEsXG4gICAgfTtcbiAgICBjb25zdCBjb21tZW50cyA9IHRzLmdldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyh0aGlzLm5vZGUpIHx8IFtdO1xuICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgdHMuc2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHRoaXMubm9kZSwgY29tbWVudHMpO1xuICB9XG59XG5cbi8qKiBSZXR1cm5zIHRoZSBDbG9zdXJlIG5hbWUgb2YgYSBmdW5jdGlvbiBwYXJhbWV0ZXIsIHNwZWNpYWwtY2FzaW5nIGRlc3RydWN0dXJpbmcuICovXG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJOYW1lKHBhcmFtOiB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbiwgaW5kZXg6IG51bWJlcik6IHN0cmluZyB7XG4gIHN3aXRjaCAocGFyYW0ubmFtZS5raW5kKSB7XG4gICAgY2FzZSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXI6XG4gICAgICBsZXQgbmFtZSA9IGdldElkZW50aWZpZXJUZXh0KHBhcmFtLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgICAvLyBUeXBlU2NyaXB0IGFsbG93cyBwYXJhbWV0ZXJzIG5hbWVkIFwiYXJndW1lbnRzXCIsIGJ1dCBDbG9zdXJlXG4gICAgICAvLyBkaXNhbGxvd3MgdGhpcywgZXZlbiBpbiBleHRlcm5zLlxuICAgICAgaWYgKG5hbWUgPT09ICdhcmd1bWVudHMnKSBuYW1lID0gJ3RzaWNrbGVfYXJndW1lbnRzJztcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIGNhc2UgdHMuU3ludGF4S2luZC5BcnJheUJpbmRpbmdQYXR0ZXJuOlxuICAgIGNhc2UgdHMuU3ludGF4S2luZC5PYmplY3RCaW5kaW5nUGF0dGVybjpcbiAgICAgIC8vIENsb3N1cmUgY3Jhc2hlcyBpZiB5b3UgcHV0IGEgYmluZGluZyBwYXR0ZXJuIGluIHRoZSBleHRlcm5zLlxuICAgICAgLy8gQXZvaWQgdGhpcyBieSBqdXN0IGdlbmVyYXRpbmcgYW4gdW51c2VkIG5hbWU7IHRoZSBuYW1lIGlzXG4gICAgICAvLyBpZ25vcmVkIGFueXdheS5cbiAgICAgIHJldHVybiBgX18ke2luZGV4fWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFRoZSBhYm92ZSBsaXN0IG9mIGtpbmRzIGlzIGV4aGF1c3RpdmUuICBwYXJhbS5uYW1lIGlzICduZXZlcicgYXQgdGhpcyBwb2ludC5cbiAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhcmFtLm5hbWUgYXMgdHMuTm9kZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIGZ1bmN0aW9uIHBhcmFtZXRlciBraW5kOiAke3RzLlN5bnRheEtpbmRbcGFyYW1OYW1lLmtpbmRdfWApO1xuICB9XG59XG5cbi8qKlxuICogTW9kdWxlVHlwZVRyYW5zbGF0b3IgZW5jYXBzdWxhdGVzIGtub3dsZWRnZSBhbmQgaGVscGVyIGZ1bmN0aW9ucyB0byB0cmFuc2xhdGUgdHlwZXMgaW4gdGhlIHNjb3BlXG4gKiBvZiBhIHNwZWNpZmljIG1vZHVsZS4gVGhpcyBpbmNsdWRlcyBtYW5hZ2luZyBDbG9zdXJlIHJlcXVpcmVUeXBlIHN0YXRlbWVudHMgYW5kIGFueSBzeW1ib2xcbiAqIGFsaWFzZXMgaW4gc2NvcGUgZm9yIGEgd2hvbGUgZmlsZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZHVsZVR5cGVUcmFuc2xhdG9yIHtcbiAgLyoqXG4gICAqIEEgbWFwcGluZyBvZiBhbGlhc2VzIGZvciBzeW1ib2xzIGluIHRoZSBjdXJyZW50IGZpbGUsIHVzZWQgd2hlbiBlbWl0dGluZyB0eXBlcy4gVHlwZVNjcmlwdFxuICAgKiBlbWl0cyBpbXBvcnRlZCBzeW1ib2xzIHdpdGggdW5wcmVkaWN0YWJsZSBwcmVmaXhlcy4gVG8gZ2VuZXJhdGUgY29ycmVjdCB0eXBlIGFubm90YXRpb25zLFxuICAgKiB0c2lja2xlIGNyZWF0ZXMgaXRzIG93biBhbGlhc2VzIGZvciB0eXBlcywgYW5kIHJlZ2lzdGVycyB0aGVtIGluIHRoaXMgbWFwIChzZWVcbiAgICogYGVtaXRJbXBvcnREZWNsYXJhdGlvbmAgYW5kIGByZXF1aXJlVHlwZSgpYCBiZWxvdykuIFRoZSBhbGlhc2VzIGFyZSB0aGVuIHVzZWQgd2hlbiBlbWl0dGluZ1xuICAgKiB0eXBlcy5cbiAgICovXG4gIHN5bWJvbHNUb0FsaWFzZWROYW1lcyA9IG5ldyBNYXA8dHMuU3ltYm9sLCBzdHJpbmc+KCk7XG5cbiAgLyoqXG4gICAqIEEgY2FjaGUgZm9yIGV4cGVuc2l2ZSBzeW1ib2wgbG9va3Vwcywgc2VlIFR5cGVUcmFuc2xhdG9yLnN5bWJvbFRvU3RyaW5nLiBNYXBzIHN5bWJvbHMgdG8gdGhlaXJcbiAgICogQ2xvc3VyZSBuYW1lIGluIHRoaXMgZmlsZSBzY29wZS5cbiAgICovXG4gIHByaXZhdGUgc3ltYm9sVG9OYW1lQ2FjaGUgPSBuZXcgTWFwPHRzLlN5bWJvbCwgc3RyaW5nPigpO1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0IG9mIG1vZHVsZSBzeW1ib2xzIHJlcXVpcmVUeXBlZCBpbiB0aGUgbG9jYWwgbmFtZXNwYWNlLiAgVGhpcyB0cmFja3Mgd2hpY2ggaW1wb3J0ZWRcbiAgICogbW9kdWxlcyB3ZSd2ZSBhbHJlYWR5IGFkZGVkIHRvIGFkZGl0aW9uYWxJbXBvcnRzIGJlbG93LlxuICAgKi9cbiAgcHJpdmF0ZSByZXF1aXJlVHlwZU1vZHVsZXMgPSBuZXcgU2V0PHRzLlN5bWJvbD4oKTtcblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGdvb2cucmVxdWlyZVR5cGUgc3RhdGVtZW50cyBmb3IgdGhpcyBtb2R1bGUuIFRoZXNlIGFyZSBpbnNlcnRlZCBpbnRvXG4gICAqIHRoZSBtb2R1bGUncyBib2R5IHN0YXRlbWVudHMgYWZ0ZXIgdHJhbnNsYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGFkZGl0aW9uYWxJbXBvcnRzOiB0cy5TdGF0ZW1lbnRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsXG4gICAgICBwdWJsaWMgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgICAgcHJpdmF0ZSBob3N0OiBBbm5vdGF0b3JIb3N0LFxuICAgICAgcHJpdmF0ZSBkaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdLFxuICAgICAgcHJpdmF0ZSBpc0ZvckV4dGVybnM6IGJvb2xlYW4sXG4gICkge31cblxuICBkZWJ1Z1dhcm4oY29udGV4dDogdHMuTm9kZSwgbWVzc2FnZVRleHQ6IHN0cmluZykge1xuICAgIHJlcG9ydERlYnVnV2FybmluZyh0aGlzLmhvc3QsIGNvbnRleHQsIG1lc3NhZ2VUZXh0KTtcbiAgfVxuXG4gIGVycm9yKG5vZGU6IHRzLk5vZGUsIG1lc3NhZ2VUZXh0OiBzdHJpbmcpIHtcbiAgICByZXBvcnREaWFnbm9zdGljKHRoaXMuZGlhZ25vc3RpY3MsIG5vZGUsIG1lc3NhZ2VUZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgVHlwZVNjcmlwdCB0cy5UeXBlIGludG8gdGhlIGVxdWl2YWxlbnQgQ2xvc3VyZSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gY29udGV4dCBUaGUgdHMuTm9kZSBjb250YWluaW5nIHRoZSB0eXBlIHJlZmVyZW5jZTsgdXNlZCBmb3IgcmVzb2x2aW5nIHN5bWJvbHNcbiAgICogICAgIGluIGNvbnRleHQuXG4gICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIHRvIHRyYW5zbGF0ZTsgaWYgbm90IHByb3ZpZGVkLCB0aGUgTm9kZSdzIHR5cGUgd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0gcmVzb2x2ZUFsaWFzIElmIHRydWUsIGRvIG5vdCBlbWl0IGFsaWFzZXMgYXMgdGhlaXIgc3ltYm9sLCBidXQgcmF0aGVyIGFzIHRoZSByZXNvbHZlZFxuICAgKiAgICAgdHlwZSB1bmRlcmx5aW5nIHRoZSBhbGlhcy4gVGhpcyBzaG91bGQgYmUgdHJ1ZSBvbmx5IHdoZW4gZW1pdHRpbmcgdGhlIHR5cGVkZWYgaXRzZWxmLlxuICAgKi9cbiAgdHlwZVRvQ2xvc3VyZShjb250ZXh0OiB0cy5Ob2RlLCB0eXBlPzogdHMuVHlwZSk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuaG9zdC51bnR5cGVkKSB7XG4gICAgICByZXR1cm4gJz8nO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGVDaGVja2VyID0gdGhpcy50eXBlQ2hlY2tlcjtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHR5cGUgPSB0eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmV3VHlwZVRyYW5zbGF0b3IoY29udGV4dCkudHJhbnNsYXRlKHR5cGUpO1xuICB9XG5cbiAgbmV3VHlwZVRyYW5zbGF0b3IoY29udGV4dDogdHMuTm9kZSkge1xuICAgIC8vIEluIGV4dGVybnMsIHRoZXJlIGlzIG5vIGxvY2FsIHNjb3BlLCBzbyBhbGwgdHlwZXMgbXVzdCBiZSByZWxhdGl2ZSB0byB0aGUgZmlsZSBsZXZlbCBzY29wZS5cbiAgICBjb25zdCB0cmFuc2xhdGlvbkNvbnRleHQgPSB0aGlzLmlzRm9yRXh0ZXJucyA/IHRoaXMuc291cmNlRmlsZSA6IGNvbnRleHQ7XG5cbiAgICBjb25zdCB0cmFuc2xhdG9yID0gbmV3IHR5cGVUcmFuc2xhdG9yLlR5cGVUcmFuc2xhdG9yKFxuICAgICAgICB0aGlzLmhvc3QsIHRoaXMudHlwZUNoZWNrZXIsIHRyYW5zbGF0aW9uQ29udGV4dCwgdGhpcy5ob3N0LnR5cGVCbGFja0xpc3RQYXRocyB8fCBuZXcgU2V0KCksXG4gICAgICAgIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCB0aGlzLnN5bWJvbFRvTmFtZUNhY2hlLFxuICAgICAgICAoc3ltOiB0cy5TeW1ib2wpID0+IHRoaXMuZW5zdXJlU3ltYm9sRGVjbGFyZWQoc3ltKSk7XG4gICAgdHJhbnNsYXRvci5pc0ZvckV4dGVybnMgPSB0aGlzLmlzRm9yRXh0ZXJucztcbiAgICB0cmFuc2xhdG9yLndhcm4gPSBtc2cgPT4gdGhpcy5kZWJ1Z1dhcm4oY29udGV4dCwgbXNnKTtcbiAgICByZXR1cm4gdHJhbnNsYXRvcjtcbiAgfVxuXG4gIGlzQmxhY2tMaXN0ZWQoY29udGV4dDogdHMuTm9kZSkge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKGNvbnRleHQpO1xuICAgIGxldCBzeW0gPSB0eXBlLnN5bWJvbDtcbiAgICBpZiAoIXN5bSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgc3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5ld1R5cGVUcmFuc2xhdG9yKGNvbnRleHQpLmlzQmxhY2tMaXN0ZWQoc3ltKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRzLlN5bWJvbCBhdCBhIGxvY2F0aW9uIG9yIHRocm93LlxuICAgKiBUaGUgVHlwZVNjcmlwdCBBUEkgY2FuIHJldHVybiB1bmRlZmluZWQgd2hlbiBmZXRjaGluZyBhIHN5bWJvbCwgYnV0IGluIG1hbnkgY29udGV4dHMgd2Uga25vdyBpdFxuICAgKiB3b24ndCAoZS5nLiBvdXIgaW5wdXQgaXMgYWxyZWFkeSB0eXBlLWNoZWNrZWQpLlxuICAgKi9cbiAgbXVzdEdldFN5bWJvbEF0TG9jYXRpb24obm9kZTogdHMuTm9kZSk6IHRzLlN5bWJvbCB7XG4gICAgY29uc3Qgc3ltID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKG5vZGUpO1xuICAgIGlmICghc3ltKSB0aHJvdyBuZXcgRXJyb3IoJ25vIHN5bWJvbCcpO1xuICAgIHJldHVybiBzeW07XG4gIH1cblxuICAvKiogRmluZHMgYW4gZXhwb3J0ZWQgKGkuZS4gbm90IGdsb2JhbCkgZGVjbGFyYXRpb24gZm9yIHRoZSBnaXZlbiBzeW1ib2wuICovXG4gIHByb3RlY3RlZCBmaW5kRXhwb3J0ZWREZWNsYXJhdGlvbihzeW06IHRzLlN5bWJvbCk6IHRzLkRlY2xhcmF0aW9ufHVuZGVmaW5lZCB7XG4gICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiBpdCdzIHVuY2xlYXIgd2hlbiBhIHN5bWJvbCB3b3VsZG4ndCBoYXZlIGEgZGVjbGFyYXRpb24sIG1heWJlIGp1c3QgZm9yXG4gICAgLy8gc29tZSBidWlsdGlucyAoZS5nLiBTeW1ib2wpP1xuICAgIGlmICghc3ltLmRlY2xhcmF0aW9ucyB8fCBzeW0uZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAvLyBBIHN5bWJvbCBkZWNsYXJlZCBpbiB0aGlzIGZpbGUgZG9lcyBub3QgbmVlZCB0byBiZSBpbXBvcnRlZC5cbiAgICBpZiAoc3ltLmRlY2xhcmF0aW9ucy5zb21lKGQgPT4gZC5nZXRTb3VyY2VGaWxlKCkgPT09IHRoaXMuc291cmNlRmlsZSkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAvLyBGaW5kIGFuIGV4cG9ydGVkIGRlY2xhcmF0aW9uLlxuICAgIC8vIEJlY2F1c2UgdHNpY2tsZSBydW5zIHdpdGggdGhlIC0tZGVjbGFyYXRpb24gZmxhZywgYWxsIHR5cGVzIHJlZmVyZW5jZWQgZnJvbSBleHBvcnRlZCB0eXBlc1xuICAgIC8vIG11c3QgYmUgZXhwb3J0ZWQsIHRvbywgc28gdGhlcmUgbXVzdCBlaXRoZXIgYmUgc29tZSBkZWNsYXJhdGlvbiB0aGF0IGlzIGV4cG9ydGVkLCBvciB0aGVcbiAgICAvLyBzeW1ib2wgaXMgYWN0dWFsbHkgYSBnbG9iYWwgZGVjbGFyYXRpb24gKGRlY2xhcmVkIGluIGEgc2NyaXB0IGZpbGUsIG5vdCBhIG1vZHVsZSkuXG4gICAgY29uc3QgZGVjbCA9IHN5bS5kZWNsYXJhdGlvbnMuZmluZChkID0+IHtcbiAgICAgIC8vIENoZWNrIGZvciBFeHBvcnQgfCBEZWZhdWx0IChkZWZhdWx0IGJlaW5nIGEgZGVmYXVsdCBleHBvcnQpLlxuICAgICAgaWYgKCFoYXNNb2RpZmllckZsYWcoZCwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnREZWZhdWx0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRXhjbHVkZSBzeW1ib2xzIGRlY2xhcmVkIGluIGBkZWNsYXJlIGdsb2JhbCB7Li4ufWAgYmxvY2tzLCB0aGV5IGFyZSBnbG9iYWwgYW5kIGRvbid0IG5lZWRcbiAgICAgIC8vIGltcG9ydHMuXG4gICAgICBsZXQgY3VycmVudDogdHMuTm9kZXx1bmRlZmluZWQgPSBkO1xuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuR2xvYmFsQXVnbWVudGF0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWNsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNvbWV3aGF0IGh1bWFuLXJlYWRhYmxlIG1vZHVsZSBwcmVmaXggZm9yIHRoZSBnaXZlbiBpbXBvcnQgY29udGV4dCwgdG8gbWFrZVxuICAgKiBkZWJ1Z2dpbmcgdGhlIGVtaXR0ZWQgQ2xvc3VyZSB0eXBlcyBhIGJpdCBlYXNpZXIuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlTW9kdWxlUHJlZml4KGltcG9ydFBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IG1vZHVsZVByZWZpeCA9IGltcG9ydFBhdGgucmVwbGFjZSgvKFxcL2luZGV4KT8oXFwuZCk/XFwuW3RqXXN4PyQvLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL14uKlsvLl0oLis/KS8sICckMScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbiAgICByZXR1cm4gYHRzaWNrbGVfJHttb2R1bGVQcmVmaXggfHwgJ3JlcVR5cGUnfV9gO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29yZHMgdGhhdCB3ZSB3ZSB3YW50IGEgYGNvbnN0IHggPSBnb29nLnJlcXVpcmVUeXBlLi4uYCBpbXBvcnQgb2YgdGhlIGdpdmVuIGBpbXBvcnRQYXRoYCxcbiAgICogd2hpY2ggd2lsbCBiZSBpbnNlcnRlZCB3aGVuIHdlIGVtaXQuXG4gICAqIFRoaXMgYWxzbyByZWdpc3RlcnMgYWxpYXNlcyBmb3Igc3ltYm9scyBmcm9tIHRoZSBtb2R1bGUgdGhhdCBtYXAgdG8gdGhpcyByZXF1aXJlVHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGlzRGVmYXVsdEltcG9ydCBUcnVlIGlmIHRoZSBpbXBvcnQgc3RhdGVtZW50IGlzIGEgZGVmYXVsdCBpbXBvcnQsIGUuZy5cbiAgICogICAgIGBpbXBvcnQgRm9vIGZyb20gLi4uO2AsIHdoaWNoIG1hdHRlcnMgZm9yIGFkanVzdGluZyB3aGV0aGVyIHdlIGVtaXQgYSBgLmRlZmF1bHRgLlxuICAgKi9cbiAgcmVxdWlyZVR5cGUoaW1wb3J0UGF0aDogc3RyaW5nLCBtb2R1bGVTeW1ib2w6IHRzLlN5bWJvbCwgaXNEZWZhdWx0SW1wb3J0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHJldHVybjtcbiAgICAvLyBBbHJlYWR5IGltcG9ydGVkPyBEbyBub3QgZW1pdCBhIGR1cGxpY2F0ZSByZXF1aXJlVHlwZS5cbiAgICBpZiAodGhpcy5yZXF1aXJlVHlwZU1vZHVsZXMuaGFzKG1vZHVsZVN5bWJvbCkpIHJldHVybjtcbiAgICBpZiAodHlwZVRyYW5zbGF0b3IuaXNCbGFja2xpc3RlZCh0aGlzLmhvc3QudHlwZUJsYWNrTGlzdFBhdGhzLCBtb2R1bGVTeW1ib2wpKSB7XG4gICAgICByZXR1cm47ICAvLyBEbyBub3QgZW1pdCBnb29nLnJlcXVpcmVUeXBlIGZvciBibGFja2xpc3RlZCBwYXRocy5cbiAgICB9XG4gICAgY29uc3QgbnNJbXBvcnQgPSBnb29nbW9kdWxlLmV4dHJhY3RHb29nTmFtZXNwYWNlSW1wb3J0KGltcG9ydFBhdGgpO1xuICAgIGNvbnN0IHJlcXVpcmVUeXBlUHJlZml4ID1cbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1vZHVsZVByZWZpeChpbXBvcnRQYXRoKSArIFN0cmluZyh0aGlzLnJlcXVpcmVUeXBlTW9kdWxlcy5zaXplICsgMSk7XG4gICAgY29uc3QgbW9kdWxlTmFtZXNwYWNlID0gbnNJbXBvcnQgIT09IG51bGwgP1xuICAgICAgICBuc0ltcG9ydCA6XG4gICAgICAgIHRoaXMuaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKHRoaXMuc291cmNlRmlsZS5maWxlTmFtZSwgaW1wb3J0UGF0aCk7XG5cbiAgICAvLyBJbiBUeXBlU2NyaXB0LCBpbXBvcnRpbmcgYSBtb2R1bGUgZm9yIHVzZSBpbiBhIHR5cGUgYW5ub3RhdGlvbiBkb2VzIG5vdCBjYXVzZSBhIHJ1bnRpbWUgbG9hZC5cbiAgICAvLyBJbiBDbG9zdXJlIENvbXBpbGVyLCBnb29nLnJlcXVpcmUnaW5nIGEgbW9kdWxlIGNhdXNlcyBhIHJ1bnRpbWUgbG9hZCwgc28gZW1pdHRpbmcgcmVxdWlyZXNcbiAgICAvLyBoZXJlIHdvdWxkIGNhdXNlIGEgY2hhbmdlIGluIGxvYWQgb3JkZXIsIHdoaWNoIGlzIG9ic2VydmFibGUgKGFuZCBjYW4gbGVhZCB0byBlcnJvcnMpLlxuICAgIC8vIEluc3RlYWQsIGdvb2cucmVxdWlyZVR5cGUgdHlwZXMsIHdoaWNoIGFsbG93cyB1c2luZyB0aGVtIGluIHR5cGUgYW5ub3RhdGlvbnMgd2l0aG91dFxuICAgIC8vIGNhdXNpbmcgYSBsb2FkLlxuICAgIC8vICAgY29uc3QgcmVxdWlyZVR5cGVQcmVmaXggPSBnb29nLnJlcXVpcmVUeXBlKG1vZHVsZU5hbWVzcGFjZSlcbiAgICB0aGlzLmFkZGl0aW9uYWxJbXBvcnRzLnB1c2godHMuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoXG4gICAgICAgICAgICBbdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgICByZXF1aXJlVHlwZVByZWZpeCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2dvb2cnKSwgJ3JlcXVpcmVUeXBlJyksIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgW3RzLmNyZWF0ZUxpdGVyYWwobW9kdWxlTmFtZXNwYWNlKV0pKV0sXG4gICAgICAgICAgICB0cy5Ob2RlRmxhZ3MuQ29uc3QpKSk7XG4gICAgdGhpcy5yZXF1aXJlVHlwZU1vZHVsZXMuYWRkKG1vZHVsZVN5bWJvbCk7XG4gICAgZm9yIChsZXQgc3ltIG9mIHRoaXMudHlwZUNoZWNrZXIuZ2V0RXhwb3J0c09mTW9kdWxlKG1vZHVsZVN5bWJvbCkpIHtcbiAgICAgIC8vIFNvbWUgdXNlcnMgaW1wb3J0IHtkZWZhdWx0IGFzIFNvbWVBbGlhc30gZnJvbSAnZ29vZzouLi4nO1xuICAgICAgLy8gVGhlIGNvZGUgYmVsb3cgbXVzdCByZWNvZ25pemUgdGhpcyBhcyBhIGRlZmF1bHQgaW1wb3J0IHRvIGFsaWFzIHRoZSBzeW1ib2wgdG8ganVzdCB0aGVcbiAgICAgIC8vIGJsYW5rIG1vZHVsZSBuYW1lLlxuICAgICAgY29uc3QgbmFtZWREZWZhdWx0SW1wb3J0ID0gc3ltLm5hbWUgPT09ICdkZWZhdWx0JztcbiAgICAgIC8vIGdvb2c6IGltcG9ydHMgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSAuZGVmYXVsdCBwcm9wZXJ0eSB0aGF0IFRTIHRoaW5rcyB0aGV5IGhhdmUuXG4gICAgICBjb25zdCBxdWFsaWZpZWROYW1lID0gbnNJbXBvcnQgJiYgKGlzRGVmYXVsdEltcG9ydCB8fCBuYW1lZERlZmF1bHRJbXBvcnQpID9cbiAgICAgICAgICByZXF1aXJlVHlwZVByZWZpeCA6XG4gICAgICAgICAgcmVxdWlyZVR5cGVQcmVmaXggKyAnLicgKyBzeW0ubmFtZTtcbiAgICAgIGlmIChzeW0uZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5BbGlhcykge1xuICAgICAgICBzeW0gPSB0aGlzLnR5cGVDaGVja2VyLmdldEFsaWFzZWRTeW1ib2woc3ltKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLnNldChzeW0sIHF1YWxpZmllZE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBlbnN1cmVTeW1ib2xEZWNsYXJlZChzeW06IHRzLlN5bWJvbCkge1xuICAgIGNvbnN0IGRlY2wgPSB0aGlzLmZpbmRFeHBvcnRlZERlY2xhcmF0aW9uKHN5bSk7XG4gICAgaWYgKCFkZWNsKSByZXR1cm47XG4gICAgaWYgKHRoaXMuaXNGb3JFeHRlcm5zKSB7XG4gICAgICB0aGlzLmVycm9yKGRlY2wsIGBkZWNsYXJhdGlvbiBmcm9tIG1vZHVsZSB1c2VkIGluIGFtYmllbnQgdHlwZTogJHtzeW0ubmFtZX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQWN0dWFsbHkgaW1wb3J0IHRoZSBzeW1ib2wuXG4gICAgY29uc3Qgc291cmNlRmlsZSA9IGRlY2wuZ2V0U291cmNlRmlsZSgpO1xuICAgIGlmIChzb3VyY2VGaWxlID09PSB0cy5nZXRPcmlnaW5hbE5vZGUodGhpcy5zb3VyY2VGaWxlKSkgcmV0dXJuO1xuICAgIGNvbnN0IG1vZHVsZVN5bWJvbCA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihzb3VyY2VGaWxlKTtcbiAgICAvLyBBIHNvdXJjZSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgc3ltYm9sIGlmIGl0J3Mgbm90IGEgbW9kdWxlIChubyBFUzYgaW0vZXhwb3J0cykuXG4gICAgaWYgKCFtb2R1bGVTeW1ib2wpIHJldHVybjtcbiAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IHRoaXMgc2hvdWxkIHBvc3NpYmx5IHVzZSBmaWxlTmFtZVRvTW9kdWxlSWQuXG4gICAgdGhpcy5yZXF1aXJlVHlwZShzb3VyY2VGaWxlLmZpbGVOYW1lLCBtb2R1bGVTeW1ib2wpO1xuICB9XG5cbiAgaW5zZXJ0QWRkaXRpb25hbEltcG9ydHMoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSkge1xuICAgIGxldCBpbnNlcnRpb24gPSAwO1xuICAgIC8vIFNraXAgb3ZlciBhIGxlYWRpbmcgZmlsZSBjb21tZW50IGhvbGRlci5cbiAgICBpZiAoc291cmNlRmlsZS5zdGF0ZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBzb3VyY2VGaWxlLnN0YXRlbWVudHNbMF0ua2luZCA9PT0gdHMuU3ludGF4S2luZC5Ob3RFbWl0dGVkU3RhdGVtZW50KSB7XG4gICAgICBpbnNlcnRpb24rKztcbiAgICB9XG4gICAgcmV0dXJuIHRzLnVwZGF0ZVNvdXJjZUZpbGVOb2RlKHNvdXJjZUZpbGUsIFtcbiAgICAgIC4uLnNvdXJjZUZpbGUuc3RhdGVtZW50cy5zbGljZSgwLCBpbnNlcnRpb24pLFxuICAgICAgLi4udGhpcy5hZGRpdGlvbmFsSW1wb3J0cyxcbiAgICAgIC4uLnNvdXJjZUZpbGUuc3RhdGVtZW50cy5zbGljZShpbnNlcnRpb24pLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgc3ludGhlc2l6ZXMgY29tbWVudHMgb24gbm9kZSwgYW5kIHJldHVybnMgdGhlIEpTRG9jIGZyb20gaXQsIGlmIGFueS5cbiAgICogQHBhcmFtIHJlcG9ydFdhcm5pbmdzIGlmIHRydWUsIHdpbGwgcmVwb3J0IHdhcm5pbmdzIGZyb20gcGFyc2luZyB0aGUgSlNEb2MuIFNldCB0byBmYWxzZSBpZlxuICAgKiAgICAgdGhpcyBpcyBub3QgdGhlIFwibWFpblwiIGxvY2F0aW9uIGRlYWxpbmcgd2l0aCBhIG5vZGUgdG8gYXZvaWQgZHVwbGljYXRlZCB3YXJuaW5ncy5cbiAgICovXG4gIGdldEpTRG9jKG5vZGU6IHRzLk5vZGUsIHJlcG9ydFdhcm5pbmdzOiBib29sZWFuKToganNkb2MuVGFnW10ge1xuICAgIGNvbnN0IFt0YWdzLCBdID0gdGhpcy5wYXJzZUpTRG9jKG5vZGUsIHJlcG9ydFdhcm5pbmdzKTtcbiAgICByZXR1cm4gdGFncztcbiAgfVxuXG4gIGdldE11dGFibGVKU0RvYyhub2RlOiB0cy5Ob2RlKTogTXV0YWJsZUpTRG9jIHtcbiAgICBjb25zdCBbdGFncywgY29tbWVudF0gPSB0aGlzLnBhcnNlSlNEb2Mobm9kZSwgLyogcmVwb3J0V2FybmluZ3MgKi8gdHJ1ZSk7XG4gICAgcmV0dXJuIG5ldyBNdXRhYmxlSlNEb2Mobm9kZSwgY29tbWVudCwgdGFncyk7XG4gIH1cblxuICBwcml2YXRlIHBhcnNlSlNEb2Mobm9kZTogdHMuTm9kZSwgcmVwb3J0V2FybmluZ3M6IGJvb2xlYW4pOlxuICAgICAgW2pzZG9jLlRhZ1tdLCB0cy5TeW50aGVzaXplZENvbW1lbnR8bnVsbF0ge1xuICAgIC8vIHN5bnRoZXNpemVMZWFkaW5nQ29tbWVudHMgYmVsb3cgY2hhbmdlcyB0ZXh0IGxvY2F0aW9ucyBmb3Igbm9kZSwgc28gZXh0cmFjdCB0aGUgbG9jYXRpb24gaGVyZVxuICAgIC8vIGluIGNhc2UgaXQgaXMgbmVlZGVkIGxhdGVyIHRvIHJlcG9ydCBkaWFnbm9zdGljcy5cbiAgICBjb25zdCBzdGFydCA9IG5vZGUuZ2V0RnVsbFN0YXJ0KCk7XG4gICAgY29uc3QgbGVuZ3RoID0gbm9kZS5nZXRMZWFkaW5nVHJpdmlhV2lkdGgodGhpcy5zb3VyY2VGaWxlKTtcblxuICAgIGNvbnN0IGNvbW1lbnRzID0ganNkb2Muc3ludGhlc2l6ZUxlYWRpbmdDb21tZW50cyhub2RlKTtcbiAgICBpZiAoIWNvbW1lbnRzIHx8IGNvbW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtbXSwgbnVsbF07XG5cbiAgICBmb3IgKGxldCBpID0gY29tbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSBjb21tZW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IGpzZG9jLnBhcnNlKGNvbW1lbnQpO1xuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBpZiAocmVwb3J0V2FybmluZ3MgJiYgcGFyc2VkLndhcm5pbmdzKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBjb21tZW50Lm9yaWdpbmFsUmFuZ2UgfHwge3Bvczogc3RhcnQsIGVuZDogc3RhcnQgKyBsZW5ndGh9O1xuICAgICAgICAgIHJlcG9ydERpYWdub3N0aWMoXG4gICAgICAgICAgICAgIHRoaXMuZGlhZ25vc3RpY3MsIG5vZGUsIHBhcnNlZC53YXJuaW5ncy5qb2luKCdcXG4nKSwgcmFuZ2UsXG4gICAgICAgICAgICAgIHRzLkRpYWdub3N0aWNDYXRlZ29yeS5XYXJuaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3BhcnNlZC50YWdzLCBjb21tZW50XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtbXSwgbnVsbF07XG4gIH1cblxuICAvKipcbiAgICogcmVzb2x2ZVJlc3RQYXJhbWV0ZXJUeXBlIHJlc29sdmVzIHRoZSBhcnJheSBtZW1iZXIgdHlwZSBmb3IgYSByZXN0IHBhcmFtZXRlciAoXCIuLi5cIikuXG4gICAqIEluIFR5cGVTY3JpcHQgeW91IHdyaXRlIFwiLi4ueDogbnVtYmVyW11cIiwgYnV0IGluIENsb3N1cmUgeW91IGRvbid0IHdyaXRlIHRoZSBhcnJheTpcbiAgICogYEBwYXJhbSB7Li4ubnVtYmVyfSB4YC4gVGhlIGNvZGUgYmVsb3cgdW53cmFwcyB0aGUgQXJyYXk8PiB3cmFwcGVyLlxuICAgKi9cbiAgcHJpdmF0ZSByZXNvbHZlUmVzdFBhcmFtZXRlclR5cGUoXG4gICAgICBuZXdUYWc6IGpzZG9jLlRhZywgZm5EZWNsOiB0cy5TaWduYXR1cmVEZWNsYXJhdGlvbiwgcGFyYW1Ob2RlOiB0cy5QYXJhbWV0ZXJEZWNsYXJhdGlvbikge1xuICAgIGxldCB0eXBlID0gdGhpcy50eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihwYXJhbU5vZGUpO1xuICAgIG5ld1RhZy5yZXN0UGFyYW0gPSB0cnVlO1xuICAgIGlmICgodHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5PYmplY3QpID09PSAwICYmIHR5cGUuZmxhZ3MgJiB0cy5UeXBlRmxhZ3MuVHlwZVBhcmFtZXRlcikge1xuICAgICAgLy8gZnVuY3Rpb24gZjxUIGV4dGVuZHMgc3RyaW5nW10+KC4uLnRzOiBUKSBoYXMgdGhlIEFycmF5IHR5cGUgb24gdGhlIHR5cGUgcGFyYW1ldGVyXG4gICAgICAvLyBjb25zdHJhaW50LCBub3Qgb24gdGhlIHBhcmFtZXRlciBpdHNlbGYuIFJlc29sdmUgaXQuXG4gICAgICBjb25zdCBiYXNlQ29uc3RyYWludCA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QmFzZUNvbnN0cmFpbnRPZlR5cGUodHlwZSk7XG4gICAgICBpZiAoYmFzZUNvbnN0cmFpbnQpIHR5cGUgPSBiYXNlQ29uc3RyYWludDtcbiAgICB9XG4gICAgaWYgKCh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLk9iamVjdCkgIT09IDAgJiZcbiAgICAgICAgKHR5cGUgYXMgdHMuT2JqZWN0VHlwZSkub2JqZWN0RmxhZ3MgJiB0cy5PYmplY3RGbGFncy5SZWZlcmVuY2UpIHtcbiAgICAgIGNvbnN0IHR5cGVSZWYgPSB0eXBlIGFzIHRzLlR5cGVSZWZlcmVuY2U7XG4gICAgICBjb25zdCB0eXBlQXJncyA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUFyZ3VtZW50cyh0eXBlUmVmKTtcbiAgICAgIGlmICghdHlwZUFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXN0IHBhcmFtZXRlciBkb2VzIG5vdCByZXNvbHZlIHRvIGEgcmVmZXJlbmNlIHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIG5ld1RhZy50eXBlID0gdGhpcy50eXBlVG9DbG9zdXJlKGZuRGVjbCwgdHlwZUFyZ3NbMF0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBmYWlsIHRvIHVud3JhcCB0aGUgQXJyYXk8PiB0eXBlLCBlbWl0IGFuIHVua25vd24gdHlwZS5cbiAgICB0aGlzLmRlYnVnV2FybihwYXJhbU5vZGUsICdmYWlsZWQgdG8gcmVzb2x2ZSByZXN0IHBhcmFtZXRlciB0eXBlLCBlbWl0dGluZyA/Jyk7XG4gICAgbmV3VGFnLnR5cGUgPSAnPyc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUganNkb2MgZm9yIG1ldGhvZHMsIGluY2x1ZGluZyBvdmVybG9hZHMuXG4gICAqIElmIG92ZXJsb2FkZWQsIG1lcmdlcyB0aGUgc2lnbmF0dXJlcyBpbiB0aGUgbGlzdCBvZiBTaWduYXR1cmVEZWNsYXJhdGlvbnMgaW50byBhIHNpbmdsZSBqc2RvYy5cbiAgICogLSBUb3RhbCBudW1iZXIgb2YgcGFyYW1ldGVycyB3aWxsIGJlIHRoZSBtYXhpbXVtIGNvdW50IGZvdW5kIGFjcm9zcyBhbGwgdmFyaWFudHMuXG4gICAqIC0gRGlmZmVyZW50IG5hbWVzIGF0IHRoZSBzYW1lIHBhcmFtZXRlciBpbmRleCB3aWxsIGJlIGpvaW5lZCB3aXRoIFwiX29yX1wiXG4gICAqIC0gVmFyaWFibGUgYXJncyAoLi4udHlwZVtdIGluIFR5cGVTY3JpcHQpIHdpbGwgYmUgb3V0cHV0IGFzIFwiLi4udHlwZVwiLFxuICAgKiAgICBleGNlcHQgaWYgZm91bmQgYXQgdGhlIHNhbWUgaW5kZXggYXMgYW5vdGhlciBhcmd1bWVudC5cbiAgICogQHBhcmFtIGZuRGVjbHMgUGFzcyA+IDEgZGVjbGFyYXRpb24gZm9yIG92ZXJsb2FkcyBvZiBzYW1lIG5hbWVcbiAgICogQHJldHVybiBUaGUgbGlzdCBvZiBwYXJhbWV0ZXIgbmFtZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBlbWl0IHRoZSBhY3R1YWxcbiAgICogICAgZnVuY3Rpb24gc3RhdGVtZW50OyBmb3Igb3ZlcmxvYWRzLCBuYW1lIHdpbGwgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICovXG4gIGdldEZ1bmN0aW9uVHlwZUpTRG9jKGZuRGVjbHM6IHRzLlNpZ25hdHVyZURlY2xhcmF0aW9uW10sIGV4dHJhVGFnczoganNkb2MuVGFnW10gPSBbXSk6XG4gICAgICB7dGFnczoganNkb2MuVGFnW10sIHBhcmFtZXRlck5hbWVzOiBzdHJpbmdbXSwgdGhpc1JldHVyblR5cGU6IHRzLlR5cGV8bnVsbH0ge1xuICAgIGNvbnN0IHR5cGVDaGVja2VyID0gdGhpcy50eXBlQ2hlY2tlcjtcblxuICAgIC8vIERlLWR1cGxpY2F0ZSB0YWdzIGFuZCBkb2NzIGZvdW5kIGZvciB0aGUgZm5EZWNscy5cbiAgICBjb25zdCB0YWdzQnlOYW1lID0gbmV3IE1hcDxzdHJpbmcsIGpzZG9jLlRhZz4oKTtcbiAgICBmdW5jdGlvbiBhZGRUYWcodGFnOiBqc2RvYy5UYWcpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGFnc0J5TmFtZS5nZXQodGFnLnRhZ05hbWUpO1xuICAgICAgdGFnc0J5TmFtZS5zZXQodGFnLnRhZ05hbWUsIGV4aXN0aW5nID8ganNkb2MubWVyZ2UoW2V4aXN0aW5nLCB0YWddKSA6IHRhZyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0cmFUYWcgb2YgZXh0cmFUYWdzKSBhZGRUYWcoZXh0cmFUYWcpO1xuXG4gICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IGZuRGVjbHMuZmluZChkID0+IGQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Db25zdHJ1Y3RvcikgIT09IHVuZGVmaW5lZDtcbiAgICAvLyBGb3IgZWFjaCBwYXJhbWV0ZXIgaW5kZXggaSwgcGFyYW1UYWdzW2ldIGlzIGFuIGFycmF5IG9mIHBhcmFtZXRlcnNcbiAgICAvLyB0aGF0IGNhbiBiZSBmb3VuZCBhdCBpbmRleCBpLiAgRS5nLlxuICAgIC8vICAgIGZ1bmN0aW9uIGZvbyh4OiBzdHJpbmcpXG4gICAgLy8gICAgZnVuY3Rpb24gZm9vKHk6IG51bWJlciwgejogc3RyaW5nKVxuICAgIC8vIHRoZW4gcGFyYW1UYWdzWzBdID0gW2luZm8gYWJvdXQgeCwgaW5mbyBhYm91dCB5XS5cbiAgICBjb25zdCBwYXJhbVRhZ3M6IGpzZG9jLlRhZ1tdW10gPSBbXTtcbiAgICBjb25zdCByZXR1cm5UYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgIGNvbnN0IHRoaXNUYWdzOiBqc2RvYy5UYWdbXSA9IFtdO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgY29uc3QgYXJnQ291bnRzID0gW107XG4gICAgbGV0IHRoaXNSZXR1cm5UeXBlOiB0cy5UeXBlfG51bGwgPSBudWxsO1xuICAgIGZvciAoY29uc3QgZm5EZWNsIG9mIGZuRGVjbHMpIHtcbiAgICAgIC8vIENvbnN0cnVjdCB0aGUgSlNEb2MgY29tbWVudCBieSByZWFkaW5nIHRoZSBleGlzdGluZyBKU0RvYywgaWZcbiAgICAgIC8vIGFueSwgYW5kIG1lcmdpbmcgaXQgd2l0aCB0aGUga25vd24gdHlwZXMgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICAvLyBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdHlwZS5cbiAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLmdldEpTRG9jKGZuRGVjbCwgLyogcmVwb3J0V2FybmluZ3MgKi8gZmFsc2UpO1xuXG4gICAgICAvLyBDb3B5IGFsbCB0aGUgdGFncyBvdGhlciB0aGFuIEBwYXJhbS9AcmV0dXJuIGludG8gdGhlIG5ld1xuICAgICAgLy8gSlNEb2Mgd2l0aG91dCBhbnkgY2hhbmdlOyBAcGFyYW0vQHJldHVybiBhcmUgaGFuZGxlZCBzcGVjaWFsbHkuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBtYXkgYmUgcHJvYmxlbXMgaWYgYW4gYW5ub3RhdGlvbiBkb2Vzbid0IGFwcGx5IHRvIGFsbCBvdmVybG9hZHM7XG4gICAgICAvLyBpcyBpdCB3b3J0aCBjaGVja2luZyBmb3IgdGhpcyBhbmQgZXJyb3Jpbmc/XG4gICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgIGlmICh0YWcudGFnTmFtZSA9PT0gJ3BhcmFtJyB8fCB0YWcudGFnTmFtZSA9PT0gJ3JldHVybicpIGNvbnRpbnVlO1xuICAgICAgICBhZGRUYWcodGFnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmxhZ3MgPSB0cy5nZXRDb21iaW5lZE1vZGlmaWVyRmxhZ3MoZm5EZWNsKTtcbiAgICAgIC8vIEFkZCBAYWJzdHJhY3Qgb24gXCJhYnN0cmFjdFwiIGRlY2xhcmF0aW9ucy5cbiAgICAgIGlmIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpIHtcbiAgICAgICAgYWRkVGFnKHt0YWdOYW1lOiAnYWJzdHJhY3QnfSk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgQHByb3RlY3RlZC9AcHJpdmF0ZSBpZiBwcmVzZW50LlxuICAgICAgaWYgKGZsYWdzICYgdHMuTW9kaWZpZXJGbGFncy5Qcm90ZWN0ZWQpIHtcbiAgICAgICAgYWRkVGFnKHt0YWdOYW1lOiAncHJvdGVjdGVkJ30pO1xuICAgICAgfSBlbHNlIGlmIChmbGFncyAmIHRzLk1vZGlmaWVyRmxhZ3MuUHJpdmF0ZSkge1xuICAgICAgICBhZGRUYWcoe3RhZ05hbWU6ICdwcml2YXRlJ30pO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYW55IEB0ZW1wbGF0ZSB0YWdzLlxuICAgICAgLy8gTXVsdGlwbGUgZGVjbGFyYXRpb25zIHdpdGggdGhlIHNhbWUgdGVtcGxhdGUgdmFyaWFibGUgbmFtZXMgc2hvdWxkIHdvcms6XG4gICAgICAvLyB0aGUgZGVjbGFyYXRpb25zIGdldCB0dXJuZWQgaW50byB1bmlvbiB0eXBlcywgYW5kIENsb3N1cmUgQ29tcGlsZXIgd2lsbCBuZWVkXG4gICAgICAvLyB0byBmaW5kIGEgdW5pb24gd2hlcmUgYWxsIHR5cGUgYXJndW1lbnRzIGFyZSBzYXRpc2ZpZWQuXG4gICAgICBpZiAoZm5EZWNsLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHAgb2YgZm5EZWNsLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgdHlwZVBhcmFtZXRlck5hbWVzLmFkZChnZXRJZGVudGlmaWVyVGV4dCh0cC5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIHRoZSBwYXJhbWV0ZXJzIGludG8gYSBzaW5nbGUgbGlzdCBvZiBtZXJnZWQgbmFtZXMgYW5kIGxpc3Qgb2YgdHlwZXNcbiAgICAgIGNvbnN0IHNpZyA9IHR5cGVDaGVja2VyLmdldFNpZ25hdHVyZUZyb21EZWNsYXJhdGlvbihmbkRlY2wpO1xuICAgICAgaWYgKCFzaWcgfHwgIXNpZy5kZWNsYXJhdGlvbikgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSAke2ZuRGVjbC5uYW1lfWApO1xuICAgICAgaWYgKHNpZy5kZWNsYXJhdGlvbi5raW5kID09PSB0cy5TeW50YXhLaW5kLkpTRG9jU2lnbmF0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSlNEb2Mgc2lnbmF0dXJlICR7Zm5EZWNsLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICBsZXQgaGFzVGhpc1BhcmFtID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZy5kZWNsYXJhdGlvbi5wYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtTm9kZSA9IHNpZy5kZWNsYXJhdGlvbi5wYXJhbWV0ZXJzW2ldO1xuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRQYXJhbWV0ZXJOYW1lKHBhcmFtTm9kZSwgaSk7XG4gICAgICAgIGNvbnN0IGlzVGhpc1BhcmFtID0gbmFtZSA9PT0gJ3RoaXMnO1xuICAgICAgICBpZiAoaXNUaGlzUGFyYW0pIGhhc1RoaXNQYXJhbSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgbmV3VGFnOiBqc2RvYy5UYWcgPSB7XG4gICAgICAgICAgdGFnTmFtZTogaXNUaGlzUGFyYW0gPyAndGhpcycgOiAncGFyYW0nLFxuICAgICAgICAgIG9wdGlvbmFsOiBwYXJhbU5vZGUuaW5pdGlhbGl6ZXIgIT09IHVuZGVmaW5lZCB8fCBwYXJhbU5vZGUucXVlc3Rpb25Ub2tlbiAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHBhcmFtZXRlck5hbWU6IGlzVGhpc1BhcmFtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocGFyYW1Ob2RlLmRvdERvdERvdFRva2VuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBUaGUgc2ltcGxlIGNhc2U6IGEgcGxhaW4gcGFyYW1ldGVyIHR5cGUuXG4gICAgICAgICAgbmV3VGFnLnR5cGUgPSB0aGlzLnR5cGVUb0Nsb3N1cmUoZm5EZWNsLCB0aGlzLnR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKHBhcmFtTm9kZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSBjb21wbGV4IGNhc2U6IHJlc29sdmUgdGhlIGFycmF5IG1lbWJlciB0eXBlIGluIC4uLmZvb1tdLlxuICAgICAgICAgIHRoaXMucmVzb2x2ZVJlc3RQYXJhbWV0ZXJUeXBlKG5ld1RhZywgZm5EZWNsLCBwYXJhbU5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB7dGFnTmFtZSwgcGFyYW1ldGVyTmFtZSwgdGV4dH0gb2YgdGFncykge1xuICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncGFyYW0nICYmIHBhcmFtZXRlck5hbWUgPT09IG5ld1RhZy5wYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgICAgICBuZXdUYWcudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1RoaXNQYXJhbSkge1xuICAgICAgICAgIGNvbnN0IHBhcmFtSWR4ID0gaGFzVGhpc1BhcmFtID8gaSAtIDEgOiBpO1xuICAgICAgICAgIGlmICghcGFyYW1UYWdzW3BhcmFtSWR4XSkgcGFyYW1UYWdzLnB1c2goW10pO1xuICAgICAgICAgIHBhcmFtVGFnc1twYXJhbUlkeF0ucHVzaChuZXdUYWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNUYWdzLnB1c2gobmV3VGFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJnQ291bnRzLnB1c2goXG4gICAgICAgICAgaGFzVGhpc1BhcmFtID8gc2lnLmRlY2xhcmF0aW9uLnBhcmFtZXRlcnMubGVuZ3RoIC0gMSA6IHNpZy5kZWNsYXJhdGlvbi5wYXJhbWV0ZXJzLmxlbmd0aCk7XG5cbiAgICAgIC8vIFJldHVybiB0eXBlLlxuICAgICAgaWYgKCFpc0NvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHJldHVyblRhZzoganNkb2MuVGFnID0ge1xuICAgICAgICAgIHRhZ05hbWU6ICdyZXR1cm4nLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXRUeXBlID0gdHlwZUNoZWNrZXIuZ2V0UmV0dXJuVHlwZU9mU2lnbmF0dXJlKHNpZyk7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdGVtcGxhdGVkIGBAdGhpc2AgdGFnIGZvciBUeXBlU2NyaXB0IGBmb28oKTogdGhpc2AgcmV0dXJuIHR5cGUgc3BlY2lmaWNhdGlvbi5cbiAgICAgICAgLy8gTWFrZSBzdXJlIG5vdCB0byBkbyB0aGF0IGlmIHRoZSBmdW5jdGlvbiBhbHJlYWR5IGhhcyB1c2VkIGBAdGhpc2AgZHVlIHRvIGEgdGhpc1xuICAgICAgICAvLyBwYXJhbWV0ZXIuIEl0J3Mgbm90IGNsZWFyIGhvdyB0byByZXNvbHZlIHRoZSB0d28gY29uZmxpY3RpbmcgdGhpcyB0eXBlcyBiZXN0LCB0aGUgY3VycmVudFxuICAgICAgICAvLyBzb2x1dGlvbiBwcmVmZXJzIHRoZSBleHBsaWNpdGx5IGdpdmVuIGB0aGlzYCBwYXJhbWV0ZXIuXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgYWNjZXNzaW5nIFRTIGludGVybmFsIGZpZWxkLlxuICAgICAgICBpZiAoKHJldFR5cGUgYXMgYW55KVsnaXNUaGlzVHlwZSddICYmICFoYXNUaGlzUGFyYW0pIHtcbiAgICAgICAgICAvLyBmb28oKTogdGhpc1xuICAgICAgICAgIHRoaXNSZXR1cm5UeXBlID0gcmV0VHlwZTtcbiAgICAgICAgICBhZGRUYWcoe3RhZ05hbWU6ICd0ZW1wbGF0ZScsIHRleHQ6ICdUSElTJ30pO1xuICAgICAgICAgIGFkZFRhZyh7dGFnTmFtZTogJ3RoaXMnLCB0eXBlOiAnVEhJUyd9KTtcbiAgICAgICAgICByZXR1cm5UYWcudHlwZSA9ICdUSElTJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5UYWcudHlwZSA9IHRoaXMudHlwZVRvQ2xvc3VyZShmbkRlY2wsIHJldFR5cGUpO1xuICAgICAgICAgIGZvciAoY29uc3Qge3RhZ05hbWUsIHRleHR9IG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAncmV0dXJuJykge1xuICAgICAgICAgICAgICByZXR1cm5UYWcudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5UYWdzLnB1c2gocmV0dXJuVGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZVBhcmFtZXRlck5hbWVzLnNpemUgPiAwKSB7XG4gICAgICBhZGRUYWcoe3RhZ05hbWU6ICd0ZW1wbGF0ZScsIHRleHQ6IEFycmF5LmZyb20odHlwZVBhcmFtZXRlck5hbWVzLnZhbHVlcygpKS5qb2luKCcsICcpfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3RG9jID0gQXJyYXkuZnJvbSh0YWdzQnlOYW1lLnZhbHVlcygpKTtcblxuICAgIGlmICh0aGlzVGFncy5sZW5ndGggPiAwKSB7XG4gICAgICBuZXdEb2MucHVzaChqc2RvYy5tZXJnZSh0aGlzVGFncykpO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbkFyZ3NDb3VudCA9IE1hdGgubWluKC4uLmFyZ0NvdW50cyk7XG4gICAgY29uc3QgbWF4QXJnc0NvdW50ID0gTWF0aC5tYXgoLi4uYXJnQ291bnRzKTtcblxuICAgIC8vIE1lcmdlIHRoZSBKU0RvYyB0YWdzIGZvciBlYWNoIG92ZXJsb2FkZWQgcGFyYW1ldGVyLlxuICAgIC8vIEVuc3VyZSBlYWNoIHBhcmFtZXRlciBoYXMgYSB1bmlxdWUgbmFtZTsgdGhlIG1lcmdpbmcgcHJvY2VzcyBjYW4gb3RoZXJ3aXNlXG4gICAgLy8gYWNjaWRlbnRhbGx5IGdlbmVyYXRlIHRoZSBzYW1lIHBhcmFtZXRlciBuYW1lIHR3aWNlLlxuICAgIGNvbnN0IHBhcmFtTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBsZXQgZm91bmRPcHRpb25hbCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXJnc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcmFtVGFnID0ganNkb2MubWVyZ2UocGFyYW1UYWdzW2ldKTtcbiAgICAgIGlmIChwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgIGlmIChwYXJhbU5hbWVzLmhhcyhwYXJhbVRhZy5wYXJhbWV0ZXJOYW1lKSkge1xuICAgICAgICAgIHBhcmFtVGFnLnBhcmFtZXRlck5hbWUgKz0gaS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtTmFtZXMuYWRkKHBhcmFtVGFnLnBhcmFtZXRlck5hbWUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIHRhZyBpcyBvcHRpb25hbCwgbWFyayBwYXJhbWV0ZXJzIGZvbGxvd2luZyBvcHRpb25hbCBhcyBvcHRpb25hbCxcbiAgICAgIC8vIGV2ZW4gaWYgdGhleSBhcmUgbm90LCBzaW5jZSBDbG9zdXJlIHJlc3RyaWN0cyB0aGlzLCBzZWVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMjMxNFxuICAgICAgaWYgKCFwYXJhbVRhZy5yZXN0UGFyYW0gJiYgKHBhcmFtVGFnLm9wdGlvbmFsIHx8IGZvdW5kT3B0aW9uYWwgfHwgaSA+PSBtaW5BcmdzQ291bnQpKSB7XG4gICAgICAgIGZvdW5kT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICBwYXJhbVRhZy5vcHRpb25hbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBuZXdEb2MucHVzaChwYXJhbVRhZyk7XG4gICAgICBpZiAocGFyYW1UYWcucmVzdFBhcmFtKSB7XG4gICAgICAgIC8vIENhbm5vdCBoYXZlIGFueSBwYXJhbWV0ZXJzIGFmdGVyIGEgcmVzdCBwYXJhbS5cbiAgICAgICAgLy8gSnVzdCBkdW1wIHRoZSByZW1haW5pbmcgcGFyYW1ldGVycy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgdGhlIEpTRG9jIHRhZ3MgZm9yIGVhY2ggb3ZlcmxvYWRlZCByZXR1cm4uXG4gICAgaWYgKCFpc0NvbnN0cnVjdG9yKSB7XG4gICAgICBuZXdEb2MucHVzaChqc2RvYy5tZXJnZShyZXR1cm5UYWdzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZ3M6IG5ld0RvYyxcbiAgICAgIHBhcmFtZXRlck5hbWVzOiBuZXdEb2MuZmlsdGVyKHQgPT4gdC50YWdOYW1lID09PSAncGFyYW0nKS5tYXAodCA9PiB0LnBhcmFtZXRlck5hbWUhKSxcbiAgICAgIHRoaXNSZXR1cm5UeXBlLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==