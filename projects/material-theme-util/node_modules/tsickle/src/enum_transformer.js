/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/enum_transformer", ["require", "exports", "typescript", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumTransformer = exports.getEnumType = void 0;
    /**
     * @fileoverview Transforms TypeScript enum declarations to Closure enum declarations, which
     * look like:
     *
     *     /.. @enum {number} ./
     *     const Foo = {BAR: 0, BAZ: 1, ...};
     *     export {Foo};  // even if originally exported on one line.
     *
     * This declares an enum type for Closure Compiler (and Closure JS users of this TS code).
     * Splitting the enum into declaration and export is required so that local references to the
     * type resolve ("@type {Foo}").
     */
    const ts = require("typescript");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    /** isInNamespace returns true if any of node's ancestors is a namespace (ModuleDeclaration). */
    function isInNamespace(node) {
        // Must use the original node because node might have already been transformed, with node.parent
        // no longer being set.
        let parent = ts.getOriginalNode(node).parent;
        while (parent) {
            if (parent.kind === ts.SyntaxKind.ModuleDeclaration) {
                return true;
            }
            parent = parent.parent;
        }
        return false;
    }
    /**
     * getEnumMemberType computes the type of an enum member by inspecting its initializer expression.
     */
    function getEnumMemberType(typeChecker, member) {
        // Enum members without initialization have type 'number'
        if (!member.initializer) {
            return 'number';
        }
        const type = typeChecker.getTypeAtLocation(member.initializer);
        // Note: checking against 'NumberLike' instead of just 'Number' means this code
        // handles both
        //   MEMBER = 3,  // TypeFlags.NumberLiteral
        // and
        //   MEMBER = someFunction(),  // TypeFlags.Number
        if (type.flags & ts.TypeFlags.NumberLike) {
            return 'number';
        }
        // If the value is not a number, it must be a string.
        // TypeScript does not allow enum members to have any other type.
        return 'string';
    }
    /**
     * getEnumType computes the Closure type of an enum, by iterating through the members and gathering
     * their types.
     */
    function getEnumType(typeChecker, enumDecl) {
        let hasNumber = false;
        let hasString = false;
        for (const member of enumDecl.members) {
            const type = getEnumMemberType(typeChecker, member);
            if (type === 'string') {
                hasString = true;
            }
            else if (type === 'number') {
                hasNumber = true;
            }
        }
        if (hasNumber && hasString) {
            return '?'; // Closure's new type inference doesn't support enums of unions.
        }
        else if (hasNumber) {
            return 'number';
        }
        else if (hasString) {
            return 'string';
        }
        else {
            // Perhaps an empty enum?
            return '?';
        }
    }
    exports.getEnumType = getEnumType;
    /**
     * Transformer factory for the enum transformer. See fileoverview for details.
     */
    function enumTransformer(typeChecker, diagnostics) {
        return (context) => {
            function visitor(node) {
                if (!ts.isEnumDeclaration(node))
                    return ts.visitEachChild(node, visitor, context);
                // TODO(martinprobst): The enum transformer does not work for enums embedded in namespaces,
                // because TS does not support splitting export and declaration ("export {Foo};") in
                // namespaces. tsickle's emit for namespaces is unintelligible for Closure in any case, so
                // this is left to fix for another day.
                if (isInNamespace(node))
                    return ts.visitEachChild(node, visitor, context);
                // TypeScript does not emit any code for ambient enums, so early exit here to prevent the code
                // below from producing runtime values for an ambient structure.
                if (transformer_util_1.isAmbient(node))
                    return ts.visitEachChild(node, visitor, context);
                const isExported = transformer_util_1.hasModifierFlag(node, ts.ModifierFlags.Export);
                const enumType = getEnumType(typeChecker, node);
                const values = [];
                let enumIndex = 0;
                for (const member of node.members) {
                    let enumValue;
                    if (member.initializer) {
                        const enumConstValue = typeChecker.getConstantValue(member);
                        if (typeof enumConstValue === 'number') {
                            enumIndex = enumConstValue + 1;
                            enumValue = ts.createLiteral(enumConstValue);
                        }
                        else if (typeof enumConstValue === 'string') {
                            // tsickle does not care about string enum values. However TypeScript expects compile
                            // time constant enum values to be replaced with their constant expression, and e.g.
                            // doesn't emit imports for modules referenced in them. Because tsickle replaces the
                            // enum with an object literal, i.e. handles the enum transform, it must thus also do
                            // the const value substitution for strings.
                            enumValue = ts.createLiteral(enumConstValue);
                        }
                        else {
                            // Non-numeric enum value (string or an expression).
                            // Emit this initializer expression as-is.
                            // Note: if the member's initializer expression refers to another
                            // value within the enum (e.g. something like
                            //   enum Foo {
                            //     Field1,
                            //     Field2 = Field1 + something(),
                            //   }
                            // Then when we emit the initializer we produce invalid code because
                            // on the Closure side the reference to Field1 has to be namespaced,
                            // e.g. written "Foo.Field1 + something()".
                            // Hopefully this doesn't come up often -- if the enum instead has
                            // something like
                            //     Field2 = Field1 + 3,
                            // then it's still a constant expression and we inline the constant
                            // value in the above branch of this "if" statement.
                            enumValue = visitor(member.initializer);
                        }
                    }
                    else {
                        enumValue = ts.createLiteral(enumIndex);
                        enumIndex++;
                    }
                    values.push(ts.setOriginalNode(ts.setTextRange(ts.createPropertyAssignment(member.name, enumValue), member), member));
                }
                const varDecl = ts.createVariableDeclaration(node.name, /* type */ undefined, ts.createObjectLiteral(ts.setTextRange(ts.createNodeArray(values, true), node.members), true));
                const varDeclStmt = ts.setOriginalNode(ts.setTextRange(ts.createVariableStatement(
                /* modifiers */ undefined, ts.createVariableDeclarationList([varDecl], 
                /* create a const var */ ts.NodeFlags.Const)), node), node);
                const comment = {
                    kind: ts.SyntaxKind.MultiLineCommentTrivia,
                    text: `* @enum {${enumType}} `,
                    hasTrailingNewLine: true,
                    pos: -1,
                    end: -1
                };
                ts.setSyntheticLeadingComments(varDeclStmt, [comment]);
                const name = node.name.getText();
                const resultNodes = [varDeclStmt];
                if (isExported) {
                    // Create a separate export {...} statement, so that the enum name can be used in local
                    // type annotations within the file.
                    resultNodes.push(ts.createExportDeclaration(undefined, undefined, ts.createNamedExports([ts.createExportSpecifier(undefined, name)])));
                }
                if (transformer_util_1.hasModifierFlag(node, ts.ModifierFlags.Const)) {
                    // By TypeScript semantics, const enums disappear after TS compilation.
                    // We still need to generate the runtime value above to make Closure Compiler's type system
                    // happy and allow refering to enums from JS code, but we should at least not emit string
                    // value mappings.
                    return resultNodes;
                }
                // Emit the reverse mapping of foo[foo.BAR] = 'BAR'; lines for number enum members
                for (const member of node.members) {
                    const memberName = member.name;
                    const memberType = getEnumMemberType(typeChecker, member);
                    // Enum members cannot be named with a private identifier, although it
                    // is technically valid in the AST.
                    if (memberType !== 'number' || ts.isPrivateIdentifier(memberName)) {
                        continue;
                    }
                    // TypeScript enum members can have Identifier names or String names.
                    // We need to emit slightly different code to support these two syntaxes:
                    let nameExpr;
                    let memberAccess;
                    if (ts.isIdentifier(memberName)) {
                        // Foo[Foo.ABC] = "ABC";
                        nameExpr = transformer_util_1.createSingleQuoteStringLiteral(memberName.text);
                        // Make sure to create a clean, new identifier, so comments do not get emitted twice.
                        const ident = ts.createIdentifier(transformer_util_1.getIdentifierText(memberName));
                        memberAccess = ts.createPropertyAccess(ts.createIdentifier(name), ident);
                    }
                    else {
                        // Foo[Foo["A B C"]] = "A B C"; or Foo[Foo[expression]] = expression;
                        nameExpr = ts.isComputedPropertyName(memberName) ? memberName.expression : memberName;
                        memberAccess = ts.createElementAccess(ts.createIdentifier(name), nameExpr);
                    }
                    resultNodes.push(ts.createStatement(ts.createAssignment(ts.createElementAccess(ts.createIdentifier(name), memberAccess), nameExpr)));
                }
                return resultNodes;
            }
            return (sf) => visitor(sf);
        };
    }
    exports.enumTransformer = enumTransformer;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW51bV90cmFuc2Zvcm1lci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9lbnVtX3RyYW5zZm9ybWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7OztJQUVIOzs7Ozs7Ozs7OztPQVdHO0lBRUgsaUNBQWlDO0lBRWpDLG1FQUFpSDtJQUVqSCxnR0FBZ0c7SUFDaEcsU0FBUyxhQUFhLENBQUMsSUFBYTtRQUNsQyxnR0FBZ0c7UUFDaEcsdUJBQXVCO1FBQ3ZCLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQzdDLE9BQU8sTUFBTSxFQUFFO1lBQ2IsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLEVBQUU7Z0JBQ25ELE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFDRCxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUN4QjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsU0FBUyxpQkFBaUIsQ0FBQyxXQUEyQixFQUFFLE1BQXFCO1FBQzNFLHlEQUF5RDtRQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBRTtZQUN2QixPQUFPLFFBQVEsQ0FBQztTQUNqQjtRQUNELE1BQU0sSUFBSSxHQUFHLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDL0QsK0VBQStFO1FBQy9FLGVBQWU7UUFDZiw0Q0FBNEM7UUFDNUMsTUFBTTtRQUNOLGtEQUFrRDtRQUNsRCxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUU7WUFDeEMsT0FBTyxRQUFRLENBQUM7U0FDakI7UUFDRCxxREFBcUQ7UUFDckQsaUVBQWlFO1FBQ2pFLE9BQU8sUUFBUSxDQUFD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Q0FBQztpQkFDbEY7Z0JBQ0QsT0FBTyxXQUFXLENBQUM7WUFDckIsQ0FBQztZQUVELE9BQU8sQ0FBQyxFQUFpQixFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFrQixDQUFDO1FBQzdELENBQUMsQ0FBQztJQUNKLENBQUM7SUF2SUQsMENBdUlDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVHJhbnNmb3JtcyBUeXBlU2NyaXB0IGVudW0gZGVjbGFyYXRpb25zIHRvIENsb3N1cmUgZW51bSBkZWNsYXJhdGlvbnMsIHdoaWNoXG4gKiBsb29rIGxpa2U6XG4gKlxuICogICAgIC8uLiBAZW51bSB7bnVtYmVyfSAuL1xuICogICAgIGNvbnN0IEZvbyA9IHtCQVI6IDAsIEJBWjogMSwgLi4ufTtcbiAqICAgICBleHBvcnQge0Zvb307ICAvLyBldmVuIGlmIG9yaWdpbmFsbHkgZXhwb3J0ZWQgb24gb25lIGxpbmUuXG4gKlxuICogVGhpcyBkZWNsYXJlcyBhbiBlbnVtIHR5cGUgZm9yIENsb3N1cmUgQ29tcGlsZXIgKGFuZCBDbG9zdXJlIEpTIHVzZXJzIG9mIHRoaXMgVFMgY29kZSkuXG4gKiBTcGxpdHRpbmcgdGhlIGVudW0gaW50byBkZWNsYXJhdGlvbiBhbmQgZXhwb3J0IGlzIHJlcXVpcmVkIHNvIHRoYXQgbG9jYWwgcmVmZXJlbmNlcyB0byB0aGVcbiAqIHR5cGUgcmVzb2x2ZSAoXCJAdHlwZSB7Rm9vfVwiKS5cbiAqL1xuXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwsIGdldElkZW50aWZpZXJUZXh0LCBoYXNNb2RpZmllckZsYWcsIGlzQW1iaWVudH0gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcblxuLyoqIGlzSW5OYW1lc3BhY2UgcmV0dXJucyB0cnVlIGlmIGFueSBvZiBub2RlJ3MgYW5jZXN0b3JzIGlzIGEgbmFtZXNwYWNlIChNb2R1bGVEZWNsYXJhdGlvbikuICovXG5mdW5jdGlvbiBpc0luTmFtZXNwYWNlKG5vZGU6IHRzLk5vZGUpIHtcbiAgLy8gTXVzdCB1c2UgdGhlIG9yaWdpbmFsIG5vZGUgYmVjYXVzZSBub2RlIG1pZ2h0IGhhdmUgYWxyZWFkeSBiZWVuIHRyYW5zZm9ybWVkLCB3aXRoIG5vZGUucGFyZW50XG4gIC8vIG5vIGxvbmdlciBiZWluZyBzZXQuXG4gIGxldCBwYXJlbnQgPSB0cy5nZXRPcmlnaW5hbE5vZGUobm9kZSkucGFyZW50O1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5raW5kID09PSB0cy5TeW50YXhLaW5kLk1vZHVsZURlY2xhcmF0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogZ2V0RW51bU1lbWJlclR5cGUgY29tcHV0ZXMgdGhlIHR5cGUgb2YgYW4gZW51bSBtZW1iZXIgYnkgaW5zcGVjdGluZyBpdHMgaW5pdGlhbGl6ZXIgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0RW51bU1lbWJlclR5cGUodHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLCBtZW1iZXI6IHRzLkVudW1NZW1iZXIpOiAnbnVtYmVyJ3wnc3RyaW5nJyB7XG4gIC8vIEVudW0gbWVtYmVycyB3aXRob3V0IGluaXRpYWxpemF0aW9uIGhhdmUgdHlwZSAnbnVtYmVyJ1xuICBpZiAoIW1lbWJlci5pbml0aWFsaXplcikge1xuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfVxuICBjb25zdCB0eXBlID0gdHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obWVtYmVyLmluaXRpYWxpemVyKTtcbiAgLy8gTm90ZTogY2hlY2tpbmcgYWdhaW5zdCAnTnVtYmVyTGlrZScgaW5zdGVhZCBvZiBqdXN0ICdOdW1iZXInIG1lYW5zIHRoaXMgY29kZVxuICAvLyBoYW5kbGVzIGJvdGhcbiAgLy8gICBNRU1CRVIgPSAzLCAgLy8gVHlwZUZsYWdzLk51bWJlckxpdGVyYWxcbiAgLy8gYW5kXG4gIC8vICAgTUVNQkVSID0gc29tZUZ1bmN0aW9uKCksICAvLyBUeXBlRmxhZ3MuTnVtYmVyXG4gIGlmICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLk51bWJlckxpa2UpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cbiAgLy8gSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlciwgaXQgbXVzdCBiZSBhIHN0cmluZy5cbiAgLy8gVHlwZVNjcmlwdCBkb2VzIG5vdCBhbGxvdyBlbnVtIG1lbWJlcnMgdG8gaGF2ZSBhbnkgb3RoZXIgdHlwZS5cbiAgcmV0dXJuICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIGdldEVudW1UeXBlIGNvbXB1dGVzIHRoZSBDbG9zdXJlIHR5cGUgb2YgYW4gZW51bSwgYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIG1lbWJlcnMgYW5kIGdhdGhlcmluZ1xuICogdGhlaXIgdHlwZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnVtVHlwZSh0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIGVudW1EZWNsOiB0cy5FbnVtRGVjbGFyYXRpb24pOiAnbnVtYmVyJ3xcbiAgICAnc3RyaW5nJ3wnPycge1xuICBsZXQgaGFzTnVtYmVyID0gZmFsc2U7XG4gIGxldCBoYXNTdHJpbmcgPSBmYWxzZTtcbiAgZm9yIChjb25zdCBtZW1iZXIgb2YgZW51bURlY2wubWVtYmVycykge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRFbnVtTWVtYmVyVHlwZSh0eXBlQ2hlY2tlciwgbWVtYmVyKTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhhc1N0cmluZyA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaGFzTnVtYmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc051bWJlciAmJiBoYXNTdHJpbmcpIHtcbiAgICByZXR1cm4gJz8nOyAgLy8gQ2xvc3VyZSdzIG5ldyB0eXBlIGluZmVyZW5jZSBkb2Vzbid0IHN1cHBvcnQgZW51bXMgb2YgdW5pb25zLlxuICB9IGVsc2UgaWYgKGhhc051bWJlcikge1xuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfSBlbHNlIGlmIChoYXNTdHJpbmcpIHtcbiAgICByZXR1cm4gJ3N0cmluZyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gUGVyaGFwcyBhbiBlbXB0eSBlbnVtP1xuICAgIHJldHVybiAnPyc7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1lciBmYWN0b3J5IGZvciB0aGUgZW51bSB0cmFuc2Zvcm1lci4gU2VlIGZpbGVvdmVydmlldyBmb3IgZGV0YWlscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudW1UcmFuc2Zvcm1lcih0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10pOlxuICAgIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+IHRzLlRyYW5zZm9ybWVyPHRzLlNvdXJjZUZpbGU+IHtcbiAgcmV0dXJuIChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+IHtcbiAgICBmdW5jdGlvbiB2aXNpdG9yPFQgZXh0ZW5kcyB0cy5Ob2RlPihub2RlOiBUKTogVHx0cy5Ob2RlW10ge1xuICAgICAgaWYgKCF0cy5pc0VudW1EZWNsYXJhdGlvbihub2RlKSkgcmV0dXJuIHRzLnZpc2l0RWFjaENoaWxkKG5vZGUsIHZpc2l0b3IsIGNvbnRleHQpO1xuXG4gICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IFRoZSBlbnVtIHRyYW5zZm9ybWVyIGRvZXMgbm90IHdvcmsgZm9yIGVudW1zIGVtYmVkZGVkIGluIG5hbWVzcGFjZXMsXG4gICAgICAvLyBiZWNhdXNlIFRTIGRvZXMgbm90IHN1cHBvcnQgc3BsaXR0aW5nIGV4cG9ydCBhbmQgZGVjbGFyYXRpb24gKFwiZXhwb3J0IHtGb299O1wiKSBpblxuICAgICAgLy8gbmFtZXNwYWNlcy4gdHNpY2tsZSdzIGVtaXQgZm9yIG5hbWVzcGFjZXMgaXMgdW5pbnRlbGxpZ2libGUgZm9yIENsb3N1cmUgaW4gYW55IGNhc2UsIHNvXG4gICAgICAvLyB0aGlzIGlzIGxlZnQgdG8gZml4IGZvciBhbm90aGVyIGRheS5cbiAgICAgIGlmIChpc0luTmFtZXNwYWNlKG5vZGUpKSByZXR1cm4gdHMudmlzaXRFYWNoQ2hpbGQobm9kZSwgdmlzaXRvciwgY29udGV4dCk7XG5cbiAgICAgIC8vIFR5cGVTY3JpcHQgZG9lcyBub3QgZW1pdCBhbnkgY29kZSBmb3IgYW1iaWVudCBlbnVtcywgc28gZWFybHkgZXhpdCBoZXJlIHRvIHByZXZlbnQgdGhlIGNvZGVcbiAgICAgIC8vIGJlbG93IGZyb20gcHJvZHVjaW5nIHJ1bnRpbWUgdmFsdWVzIGZvciBhbiBhbWJpZW50IHN0cnVjdHVyZS5cbiAgICAgIGlmIChpc0FtYmllbnQobm9kZSkpIHJldHVybiB0cy52aXNpdEVhY2hDaGlsZChub2RlLCB2aXNpdG9yLCBjb250ZXh0KTtcblxuICAgICAgY29uc3QgaXNFeHBvcnRlZCA9IGhhc01vZGlmaWVyRmxhZyhub2RlLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCk7XG4gICAgICBjb25zdCBlbnVtVHlwZSA9IGdldEVudW1UeXBlKHR5cGVDaGVja2VyLCBub2RlKTtcblxuICAgICAgY29uc3QgdmFsdWVzOiB0cy5Qcm9wZXJ0eUFzc2lnbm1lbnRbXSA9IFtdO1xuICAgICAgbGV0IGVudW1JbmRleCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBub2RlLm1lbWJlcnMpIHtcbiAgICAgICAgbGV0IGVudW1WYWx1ZTogdHMuRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKG1lbWJlci5pbml0aWFsaXplcikge1xuICAgICAgICAgIGNvbnN0IGVudW1Db25zdFZhbHVlID0gdHlwZUNoZWNrZXIuZ2V0Q29uc3RhbnRWYWx1ZShtZW1iZXIpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZW51bUNvbnN0VmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlbnVtSW5kZXggPSBlbnVtQ29uc3RWYWx1ZSArIDE7XG4gICAgICAgICAgICBlbnVtVmFsdWUgPSB0cy5jcmVhdGVMaXRlcmFsKGVudW1Db25zdFZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbnVtQ29uc3RWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHRzaWNrbGUgZG9lcyBub3QgY2FyZSBhYm91dCBzdHJpbmcgZW51bSB2YWx1ZXMuIEhvd2V2ZXIgVHlwZVNjcmlwdCBleHBlY3RzIGNvbXBpbGVcbiAgICAgICAgICAgIC8vIHRpbWUgY29uc3RhbnQgZW51bSB2YWx1ZXMgdG8gYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBjb25zdGFudCBleHByZXNzaW9uLCBhbmQgZS5nLlxuICAgICAgICAgICAgLy8gZG9lc24ndCBlbWl0IGltcG9ydHMgZm9yIG1vZHVsZXMgcmVmZXJlbmNlZCBpbiB0aGVtLiBCZWNhdXNlIHRzaWNrbGUgcmVwbGFjZXMgdGhlXG4gICAgICAgICAgICAvLyBlbnVtIHdpdGggYW4gb2JqZWN0IGxpdGVyYWwsIGkuZS4gaGFuZGxlcyB0aGUgZW51bSB0cmFuc2Zvcm0sIGl0IG11c3QgdGh1cyBhbHNvIGRvXG4gICAgICAgICAgICAvLyB0aGUgY29uc3QgdmFsdWUgc3Vic3RpdHV0aW9uIGZvciBzdHJpbmdzLlxuICAgICAgICAgICAgZW51bVZhbHVlID0gdHMuY3JlYXRlTGl0ZXJhbChlbnVtQ29uc3RWYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vbi1udW1lcmljIGVudW0gdmFsdWUgKHN0cmluZyBvciBhbiBleHByZXNzaW9uKS5cbiAgICAgICAgICAgIC8vIEVtaXQgdGhpcyBpbml0aWFsaXplciBleHByZXNzaW9uIGFzLWlzLlxuICAgICAgICAgICAgLy8gTm90ZTogaWYgdGhlIG1lbWJlcidzIGluaXRpYWxpemVyIGV4cHJlc3Npb24gcmVmZXJzIHRvIGFub3RoZXJcbiAgICAgICAgICAgIC8vIHZhbHVlIHdpdGhpbiB0aGUgZW51bSAoZS5nLiBzb21ldGhpbmcgbGlrZVxuICAgICAgICAgICAgLy8gICBlbnVtIEZvbyB7XG4gICAgICAgICAgICAvLyAgICAgRmllbGQxLFxuICAgICAgICAgICAgLy8gICAgIEZpZWxkMiA9IEZpZWxkMSArIHNvbWV0aGluZygpLFxuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyBUaGVuIHdoZW4gd2UgZW1pdCB0aGUgaW5pdGlhbGl6ZXIgd2UgcHJvZHVjZSBpbnZhbGlkIGNvZGUgYmVjYXVzZVxuICAgICAgICAgICAgLy8gb24gdGhlIENsb3N1cmUgc2lkZSB0aGUgcmVmZXJlbmNlIHRvIEZpZWxkMSBoYXMgdG8gYmUgbmFtZXNwYWNlZCxcbiAgICAgICAgICAgIC8vIGUuZy4gd3JpdHRlbiBcIkZvby5GaWVsZDEgKyBzb21ldGhpbmcoKVwiLlxuICAgICAgICAgICAgLy8gSG9wZWZ1bGx5IHRoaXMgZG9lc24ndCBjb21lIHVwIG9mdGVuIC0tIGlmIHRoZSBlbnVtIGluc3RlYWQgaGFzXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgbGlrZVxuICAgICAgICAgICAgLy8gICAgIEZpZWxkMiA9IEZpZWxkMSArIDMsXG4gICAgICAgICAgICAvLyB0aGVuIGl0J3Mgc3RpbGwgYSBjb25zdGFudCBleHByZXNzaW9uIGFuZCB3ZSBpbmxpbmUgdGhlIGNvbnN0YW50XG4gICAgICAgICAgICAvLyB2YWx1ZSBpbiB0aGUgYWJvdmUgYnJhbmNoIG9mIHRoaXMgXCJpZlwiIHN0YXRlbWVudC5cbiAgICAgICAgICAgIGVudW1WYWx1ZSA9IHZpc2l0b3IobWVtYmVyLmluaXRpYWxpemVyKSBhcyB0cy5FeHByZXNzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnVtVmFsdWUgPSB0cy5jcmVhdGVMaXRlcmFsKGVudW1JbmRleCk7XG4gICAgICAgICAgZW51bUluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLnB1c2godHMuc2V0T3JpZ2luYWxOb2RlKFxuICAgICAgICAgICAgdHMuc2V0VGV4dFJhbmdlKHRzLmNyZWF0ZVByb3BlcnR5QXNzaWdubWVudChtZW1iZXIubmFtZSwgZW51bVZhbHVlKSwgbWVtYmVyKSwgbWVtYmVyKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhckRlY2wgPSB0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKFxuICAgICAgICAgIG5vZGUubmFtZSwgLyogdHlwZSAqLyB1bmRlZmluZWQsXG4gICAgICAgICAgdHMuY3JlYXRlT2JqZWN0TGl0ZXJhbChcbiAgICAgICAgICAgICAgdHMuc2V0VGV4dFJhbmdlKHRzLmNyZWF0ZU5vZGVBcnJheSh2YWx1ZXMsIHRydWUpLCBub2RlLm1lbWJlcnMpLCB0cnVlKSk7XG4gICAgICBjb25zdCB2YXJEZWNsU3RtdCA9IHRzLnNldE9yaWdpbmFsTm9kZShcbiAgICAgICAgICB0cy5zZXRUZXh0UmFuZ2UoXG4gICAgICAgICAgICAgIHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgICAgICAgICAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KFxuICAgICAgICAgICAgICAgICAgICAgIFt2YXJEZWNsXSxcbiAgICAgICAgICAgICAgICAgICAgICAvKiBjcmVhdGUgYSBjb25zdCB2YXIgKi8gdHMuTm9kZUZsYWdzLkNvbnN0KSksXG4gICAgICAgICAgICAgIG5vZGUpLFxuICAgICAgICAgIG5vZGUpO1xuICAgICAgY29uc3QgY29tbWVudDogdHMuU3ludGhlc2l6ZWRDb21tZW50ID0ge1xuICAgICAgICBraW5kOiB0cy5TeW50YXhLaW5kLk11bHRpTGluZUNvbW1lbnRUcml2aWEsXG4gICAgICAgIHRleHQ6IGAqIEBlbnVtIHske2VudW1UeXBlfX0gYCxcbiAgICAgICAgaGFzVHJhaWxpbmdOZXdMaW5lOiB0cnVlLFxuICAgICAgICBwb3M6IC0xLFxuICAgICAgICBlbmQ6IC0xXG4gICAgICB9O1xuICAgICAgdHMuc2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKHZhckRlY2xTdG10LCBbY29tbWVudF0pO1xuXG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5uYW1lLmdldFRleHQoKTtcbiAgICAgIGNvbnN0IHJlc3VsdE5vZGVzOiB0cy5Ob2RlW10gPSBbdmFyRGVjbFN0bXRdO1xuICAgICAgaWYgKGlzRXhwb3J0ZWQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgc2VwYXJhdGUgZXhwb3J0IHsuLi59IHN0YXRlbWVudCwgc28gdGhhdCB0aGUgZW51bSBuYW1lIGNhbiBiZSB1c2VkIGluIGxvY2FsXG4gICAgICAgIC8vIHR5cGUgYW5ub3RhdGlvbnMgd2l0aGluIHRoZSBmaWxlLlxuICAgICAgICByZXN1bHROb2Rlcy5wdXNoKHRzLmNyZWF0ZUV4cG9ydERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgICAgICAgICB0cy5jcmVhdGVOYW1lZEV4cG9ydHMoW3RzLmNyZWF0ZUV4cG9ydFNwZWNpZmllcih1bmRlZmluZWQsIG5hbWUpXSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc01vZGlmaWVyRmxhZyhub2RlLCB0cy5Nb2RpZmllckZsYWdzLkNvbnN0KSkge1xuICAgICAgICAvLyBCeSBUeXBlU2NyaXB0IHNlbWFudGljcywgY29uc3QgZW51bXMgZGlzYXBwZWFyIGFmdGVyIFRTIGNvbXBpbGF0aW9uLlxuICAgICAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIGdlbmVyYXRlIHRoZSBydW50aW1lIHZhbHVlIGFib3ZlIHRvIG1ha2UgQ2xvc3VyZSBDb21waWxlcidzIHR5cGUgc3lzdGVtXG4gICAgICAgIC8vIGhhcHB5IGFuZCBhbGxvdyByZWZlcmluZyB0byBlbnVtcyBmcm9tIEpTIGNvZGUsIGJ1dCB3ZSBzaG91bGQgYXQgbGVhc3Qgbm90IGVtaXQgc3RyaW5nXG4gICAgICAgIC8vIHZhbHVlIG1hcHBpbmdzLlxuICAgICAgICByZXR1cm4gcmVzdWx0Tm9kZXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEVtaXQgdGhlIHJldmVyc2UgbWFwcGluZyBvZiBmb29bZm9vLkJBUl0gPSAnQkFSJzsgbGluZXMgZm9yIG51bWJlciBlbnVtIG1lbWJlcnNcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIG5vZGUubWVtYmVycykge1xuICAgICAgICBjb25zdCBtZW1iZXJOYW1lID0gbWVtYmVyLm5hbWU7XG4gICAgICAgIGNvbnN0IG1lbWJlclR5cGUgPSBnZXRFbnVtTWVtYmVyVHlwZSh0eXBlQ2hlY2tlciwgbWVtYmVyKTtcbiAgICAgICAgLy8gRW51bSBtZW1iZXJzIGNhbm5vdCBiZSBuYW1lZCB3aXRoIGEgcHJpdmF0ZSBpZGVudGlmaWVyLCBhbHRob3VnaCBpdFxuICAgICAgICAvLyBpcyB0ZWNobmljYWxseSB2YWxpZCBpbiB0aGUgQVNULlxuICAgICAgICBpZiAobWVtYmVyVHlwZSAhPT0gJ251bWJlcicgfHwgdHMuaXNQcml2YXRlSWRlbnRpZmllcihtZW1iZXJOYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHlwZVNjcmlwdCBlbnVtIG1lbWJlcnMgY2FuIGhhdmUgSWRlbnRpZmllciBuYW1lcyBvciBTdHJpbmcgbmFtZXMuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZW1pdCBzbGlnaHRseSBkaWZmZXJlbnQgY29kZSB0byBzdXBwb3J0IHRoZXNlIHR3byBzeW50YXhlczpcbiAgICAgICAgbGV0IG5hbWVFeHByOiB0cy5FeHByZXNzaW9uO1xuICAgICAgICBsZXQgbWVtYmVyQWNjZXNzOiB0cy5FeHByZXNzaW9uO1xuICAgICAgICBpZiAodHMuaXNJZGVudGlmaWVyKG1lbWJlck5hbWUpKSB7XG4gICAgICAgICAgLy8gRm9vW0Zvby5BQkNdID0gXCJBQkNcIjtcbiAgICAgICAgICBuYW1lRXhwciA9IGNyZWF0ZVNpbmdsZVF1b3RlU3RyaW5nTGl0ZXJhbChtZW1iZXJOYW1lLnRleHQpO1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBjcmVhdGUgYSBjbGVhbiwgbmV3IGlkZW50aWZpZXIsIHNvIGNvbW1lbnRzIGRvIG5vdCBnZXQgZW1pdHRlZCB0d2ljZS5cbiAgICAgICAgICBjb25zdCBpZGVudCA9IHRzLmNyZWF0ZUlkZW50aWZpZXIoZ2V0SWRlbnRpZmllclRleHQobWVtYmVyTmFtZSkpO1xuICAgICAgICAgIG1lbWJlckFjY2VzcyA9IHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIobmFtZSksIGlkZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGb29bRm9vW1wiQSBCIENcIl1dID0gXCJBIEIgQ1wiOyBvciBGb29bRm9vW2V4cHJlc3Npb25dXSA9IGV4cHJlc3Npb247XG4gICAgICAgICAgbmFtZUV4cHIgPSB0cy5pc0NvbXB1dGVkUHJvcGVydHlOYW1lKG1lbWJlck5hbWUpID8gbWVtYmVyTmFtZS5leHByZXNzaW9uIDogbWVtYmVyTmFtZTtcbiAgICAgICAgICBtZW1iZXJBY2Nlc3MgPSB0cy5jcmVhdGVFbGVtZW50QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIobmFtZSksIG5hbWVFeHByKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHROb2Rlcy5wdXNoKHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVBc3NpZ25tZW50KFxuICAgICAgICAgICAgdHMuY3JlYXRlRWxlbWVudEFjY2Vzcyh0cy5jcmVhdGVJZGVudGlmaWVyKG5hbWUpLCBtZW1iZXJBY2Nlc3MpLCBuYW1lRXhwcikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHROb2RlcztcbiAgICB9XG5cbiAgICByZXR1cm4gKHNmOiB0cy5Tb3VyY2VGaWxlKSA9PiB2aXNpdG9yKHNmKSBhcyB0cy5Tb3VyY2VGaWxlO1xuICB9O1xufVxuIl19