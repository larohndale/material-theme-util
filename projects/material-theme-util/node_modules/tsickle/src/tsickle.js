/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/tsickle", ["require", "exports", "typescript", "tsickle/src/cli_support", "tsickle/src/decorator_downlevel_transformer", "tsickle/src/decorators", "tsickle/src/enum_transformer", "tsickle/src/externs", "tsickle/src/fileoverview_comment_transformer", "tsickle/src/googmodule", "tsickle/src/jsdoc_transformer", "tsickle/src/modules_manifest", "tsickle/src/transformer_util", "tsickle/src/cli_support", "tsickle/src/externs", "tsickle/src/modules_manifest"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.emit = exports.emitWithTsickle = exports.mergeEmitResults = void 0;
    const ts = require("typescript");
    const cli_support_1 = require("tsickle/src/cli_support");
    const decorator_downlevel_transformer_1 = require("tsickle/src/decorator_downlevel_transformer");
    const decorators_1 = require("tsickle/src/decorators");
    const enum_transformer_1 = require("tsickle/src/enum_transformer");
    const externs_1 = require("tsickle/src/externs");
    const fileoverview_comment_transformer_1 = require("tsickle/src/fileoverview_comment_transformer");
    const googmodule = require("tsickle/src/googmodule");
    const jsdoc_transformer_1 = require("tsickle/src/jsdoc_transformer");
    const modules_manifest_1 = require("tsickle/src/modules_manifest");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    // Exported for users as a default impl of pathToModuleName.
    var cli_support_2 = require("tsickle/src/cli_support");
    Object.defineProperty(exports, "pathToModuleName", { enumerable: true, get: function () { return cli_support_2.pathToModuleName; } });
    // Retained here for API compatibility.
    var externs_2 = require("tsickle/src/externs");
    Object.defineProperty(exports, "getGeneratedExterns", { enumerable: true, get: function () { return externs_2.getGeneratedExterns; } });
    var modules_manifest_2 = require("tsickle/src/modules_manifest");
    Object.defineProperty(exports, "ModulesManifest", { enumerable: true, get: function () { return modules_manifest_2.ModulesManifest; } });
    function mergeEmitResults(emitResults) {
        const diagnostics = [];
        let emitSkipped = true;
        const emittedFiles = [];
        const externs = {};
        const modulesManifest = new modules_manifest_1.ModulesManifest();
        for (const er of emitResults) {
            diagnostics.push(...er.diagnostics);
            emitSkipped = emitSkipped || er.emitSkipped;
            if (er.emittedFiles) {
                emittedFiles.push(...er.emittedFiles);
            }
            Object.assign(externs, er.externs);
            modulesManifest.addManifest(er.modulesManifest);
        }
        return { diagnostics, emitSkipped, emittedFiles, externs, modulesManifest };
    }
    exports.mergeEmitResults = mergeEmitResults;
    /** @deprecated Exposed for backward compat with Angular.  Use emit() instead. */
    function emitWithTsickle(program, host, tsHost, tsOptions, targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers = {}) {
        return emit(program, host, writeFile || tsHost.writeFile.bind(tsHost), targetSourceFile, cancellationToken, emitOnlyDtsFiles, customTransformers);
    }
    exports.emitWithTsickle = emitWithTsickle;
    function emit(program, host, writeFile, targetSourceFile, cancellationToken, emitOnlyDtsFiles, customTransformers = {}) {
        for (const sf of program.getSourceFiles()) {
            cli_support_1.assertAbsolute(sf.fileName);
        }
        let tsickleDiagnostics = [];
        const typeChecker = program.getTypeChecker();
        const tsOptions = program.getCompilerOptions();
        const tsickleSourceTransformers = [];
        if (host.transformTypesToClosure) {
            // Only add @suppress {checkTypes} comments when also adding type annotations.
            tsickleSourceTransformers.push(fileoverview_comment_transformer_1.transformFileoverviewCommentFactory(tsOptions, tsickleDiagnostics));
            tsickleSourceTransformers.push(jsdoc_transformer_1.jsdocTransformer(host, tsOptions, typeChecker, tsickleDiagnostics));
            tsickleSourceTransformers.push(enum_transformer_1.enumTransformer(typeChecker, tsickleDiagnostics));
        }
        if (host.transformDecorators) {
            tsickleSourceTransformers.push(decorator_downlevel_transformer_1.decoratorDownlevelTransformer(typeChecker, tsickleDiagnostics));
        }
        const modulesManifest = new modules_manifest_1.ModulesManifest();
        const tsTransformers = {
            before: [
                ...(customTransformers.beforeTsickle || []),
                ...(tsickleSourceTransformers || []).map(tf => skipTransformForSourceFileIfNeeded(host, tf)),
                ...(customTransformers.beforeTs || []),
            ],
            after: [
                ...(customTransformers.afterTs || []),
            ],
            afterDeclarations: customTransformers.afterDeclarations,
        };
        if (host.transformTypesToClosure) {
            // See comment on remoteTypeAssertions.
            tsTransformers.before.push(jsdoc_transformer_1.removeTypeAssertions());
        }
        if (host.googmodule) {
            tsTransformers.after.push(googmodule.commonJsToGoogmoduleTransformer(host, modulesManifest, typeChecker, tsickleDiagnostics));
            tsTransformers.after.push(decorators_1.transformDecoratorsOutputForClosurePropertyRenaming(tsickleDiagnostics));
        }
        // Wrap the writeFile callback to hook writing of the dts file.
        const writeFileImpl = (fileName, content, writeByteOrderMark, onError, sourceFiles) => {
            cli_support_1.assertAbsolute(fileName);
            if (host.addDtsClutzAliases && transformer_util_1.isDtsFileName(fileName) && sourceFiles) {
                // Only bundle emits pass more than one source file for .d.ts writes. Bundle emits however
                // are not supported by tsickle, as we cannot annotate them for Closure in any meaningful
                // way anyway.
                if (!sourceFiles || sourceFiles.length > 1) {
                    throw new Error(`expected exactly one source file for .d.ts emit, got ${sourceFiles.map(sf => sf.fileName)}`);
                }
                const originalSource = sourceFiles[0];
                content = addClutzAliases(content, originalSource, typeChecker, host, tsOptions);
            }
            writeFile(fileName, content, writeByteOrderMark, onError, sourceFiles);
        };
        const { diagnostics: tsDiagnostics, emitSkipped, emittedFiles } = program.emit(targetSourceFile, writeFileImpl, cancellationToken, emitOnlyDtsFiles, tsTransformers);
        const externs = {};
        if (host.transformTypesToClosure) {
            const sourceFiles = targetSourceFile ? [targetSourceFile] : program.getSourceFiles();
            for (const sourceFile of sourceFiles) {
                const isDts = transformer_util_1.isDtsFileName(sourceFile.fileName);
                if (isDts && host.shouldSkipTsickleProcessing(sourceFile.fileName)) {
                    continue;
                }
                const { output, diagnostics } = externs_1.generateExterns(typeChecker, sourceFile, host, host.moduleResolutionHost, program.getCompilerOptions());
                if (output) {
                    externs[sourceFile.fileName] = output;
                }
                if (diagnostics) {
                    tsickleDiagnostics.push(...diagnostics);
                }
            }
        }
        // All diagnostics (including warnings) are treated as errors.
        // If the host decides to ignore warnings, just discard them.
        // Warnings include stuff like "don't use @type in your jsdoc"; tsickle
        // warns and then fixes up the code to be Closure-compatible anyway.
        tsickleDiagnostics = tsickleDiagnostics.filter(d => d.category === ts.DiagnosticCategory.Error ||
            !host.shouldIgnoreWarningsForPath(d.file.fileName));
        return {
            modulesManifest,
            emitSkipped,
            emittedFiles: emittedFiles || [],
            diagnostics: [...tsDiagnostics, ...tsickleDiagnostics],
            externs
        };
    }
    exports.emit = emit;
    /** Compares two strings and returns a number suitable for use in sort(). */
    function stringCompare(a, b) {
        if (a < b)
            return -1;
        if (a > b)
            return 1;
        return 0;
    }
    /**
     * A tsickle produced declaration file might be consumed be referenced by Clutz
     * produced .d.ts files, which use symbol names based on Closure's internal
     * naming conventions, so we need to provide aliases for all the exported symbols
     * in the Clutz naming convention.
     */
    function addClutzAliases(dtsFileContent, sourceFile, typeChecker, host, options) {
        const moduleSymbol = typeChecker.getSymbolAtLocation(sourceFile);
        const moduleExports = moduleSymbol && typeChecker.getExportsOfModule(moduleSymbol);
        if (!moduleExports)
            return dtsFileContent;
        // .d.ts files can be transformed, too, so we need to compare the original node below.
        const origSourceFile = ts.getOriginalNode(sourceFile);
        // In order to write aliases, the exported symbols need to be available in the
        // the module scope. That is not always the case:
        //
        // export
        // 1) export const X;           // works
        //
        // reexport
        // 2) export {X} from './foo';  // doesn't
        //
        // imported reexport
        // 3) import {X} from './foo';  // works
        //    export {X} from './foo';
        //
        // getExportsOfModule returns all three types, but we need to separate 2).
        // For now we 'fix' 2) by simply not emitting a clutz alias, since clutz
        // interop is used in minority of scenarios.
        //
        // TODO(radokirov): attempt to add appropriate imports for 2) so that
        // currently finding out local appears even harder than fixing exports.
        const localExports = moduleExports.filter(e => {
            // If there are no declarations, be conservative and don't emit the aliases.
            // I don't know how can this happen, we have no tests that excercise it.
            if (!e.declarations)
                return false;
            // Skip default exports, they are not currently supported.
            // default is a keyword in typescript, so the name of the export being
            // default means that it's a default export.
            if (e.name === 'default')
                return false;
            // Use the declaration location to determine separate cases above.
            for (const d of e.declarations) {
                // This is a special case for export *. Technically, it is outside the
                // three cases outlined, but at this point we have rewritten it to a
                // reexport or an imported reexport. However, it appears that the
                // rewriting also has made it behave different from explicit named export
                // in the sense that the declaration appears to point at the original
                // location not the reexport location.  Since we can't figure out whether
                // there is a local import here, we err on the side of less emit.
                if (d.getSourceFile() !== origSourceFile) {
                    return false;
                }
                // @internal marked APIs are not exported, so must not get aliases.
                // This uses an internal TS API, assuming that accessing this will be more stable compared to
                // implementing our own version.
                // tslint:disable-next-line: no-any
                if (options.stripInternal && ts['isInternalDeclaration'](d, origSourceFile)) {
                    return false;
                }
                if (!ts.isExportSpecifier(d)) {
                    // we have a pure export (case 1) thus safe to emit clutz alias.
                    return true;
                }
                // The declaration d is useless to separate reexport and import-reexport
                // because they both point to the reexporting file and not to the original
                // one.  However, there is another ts API that can do a deeper resolution.
                const localSymbol = typeChecker.getExportSpecifierLocalTargetSymbol(d);
                // I don't know how can this happen, but err on the side of less emit.
                if (!localSymbol)
                    return false;
                // `declarations` is undefined for builtin symbols, such as `unknown`.
                if (!localSymbol.declarations)
                    return false;
                // In case of no import we ended up in a declaration in foo.ts, while in
                // case of having an import localD is still in the reexporing file.
                for (const localD of localSymbol.declarations) {
                    if (localD.getSourceFile() !== origSourceFile) {
                        return false;
                    }
                }
            }
            return true;
        });
        if (!localExports.length)
            return dtsFileContent;
        // TypeScript 2.8 and TypeScript 2.9 differ on the order in which the
        // module symbols come out, so sort here to make the tests stable.
        localExports.sort((a, b) => stringCompare(a.name, b.name));
        const moduleName = host.pathToModuleName('', sourceFile.fileName);
        const clutzModuleName = moduleName.replace(/\./g, '$');
        // Clutz might refer to the name in two different forms (stemming from goog.provide and
        // goog.module respectively).
        // 1) global in clutz:   ಠ_ಠ.clutz.module$contents$path$to$module_Symbol...
        // 2) local in a module: ಠ_ಠ.clutz.module$exports$path$to$module.Symbol ..
        // See examples at:
        // https://github.com/angular/clutz/tree/master/src/test/java/com/google/javascript/clutz
        // Case (1) from above.
        let globalSymbols = '';
        // Case (2) from above.
        let nestedSymbols = '';
        for (const symbol of localExports) {
            let localName = symbol.name;
            const declaration = symbol.declarations.find(d => d.getSourceFile() === origSourceFile);
            if (declaration && ts.isExportSpecifier(declaration) && declaration.propertyName) {
                // If declared in an "export {X as Y};" export specifier, then X (stored in propertyName) is
                // the local name that resolves within the module, whereas Y is only available on the exports,
                // i.e. the name used to address the symbol from outside the module.
                // Use the localName for the export then, but publish under the external name.
                localName = declaration.propertyName.text;
            }
            const mangledName = `module$contents$${clutzModuleName}_${symbol.name}`;
            globalSymbols += `\t\texport {${localName} as ${mangledName}}\n`;
            // TODO(mprobst): Once tsickle is on TS3.7, the two lines below can be replaced with
            // "export {localName};". However in TS3.5, localName resolves within the module, so
            // exporting {localName} causes a circular definition error. The workaround is to import the
            // mangled name.
            nestedSymbols += `\t\timport ${localName}$clutz = ಠ_ಠ.clutz.${mangledName};\n`;
            nestedSymbols += `\t\texport {${localName}$clutz as ${symbol.name}};\n`;
        }
        dtsFileContent += 'declare global {\n';
        dtsFileContent += `\tnamespace ಠ_ಠ.clutz {\n`;
        dtsFileContent += globalSymbols;
        dtsFileContent += `\t}\n`;
        dtsFileContent += `\tnamespace ಠ_ಠ.clutz.module$exports$${clutzModuleName} {\n`;
        // TODO(martinprobst): See https://github.com/Microsoft/TypeScript/issues/35385, remove once fixed
        dtsFileContent += `\t\tconst clutz$workaround$tissue$35385: number;\n`;
        dtsFileContent += nestedSymbols;
        dtsFileContent += `\t}\n`;
        dtsFileContent += '}\n';
        return dtsFileContent;
    }
    function skipTransformForSourceFileIfNeeded(host, delegateFactory) {
        return (context) => {
            const delegate = delegateFactory(context);
            return (sourceFile) => {
                if (host.shouldSkipTsickleProcessing(sourceFile.fileName)) {
                    return sourceFile;
                }
                return delegate(sourceFile);
            };
        };
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHNpY2tsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy90c2lja2xlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7OztJQUVILGlDQUFpQztJQUdqQyx5REFBNkM7SUFDN0MsaUdBQWdGO0lBQ2hGLHVEQUFpRjtJQUNqRixtRUFBbUQ7SUFDbkQsaURBQTBDO0lBQzFDLG1HQUF1RjtJQUN2RixxREFBMkM7SUFDM0MscUVBQTJFO0lBQzNFLG1FQUFtRDtJQUNuRCxtRUFBaUQ7SUFFakQsNERBQTREO0lBQzVELHVEQUErQztJQUF2QywrR0FBQSxnQkFBZ0IsT0FBQTtJQUN4Qix1Q0FBdUM7SUFDdkMsK0NBQThDO0lBQXRDLDhHQUFBLG1CQUFtQixPQUFBO0lBQzNCLGlFQUE0RDtJQUEzQyxtSEFBQSxlQUFlLE9BQUE7SUFtQ2hDLFNBQWdCLGdCQUFnQixDQUFDLFdBQXlCO1FBQ3hELE1BQU0sV0FBVyxHQUFvQixFQUFFLENBQUM7UUFDeEMsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLE1BQU0sWUFBWSxHQUFhLEVBQUUsQ0FBQztRQUNsQyxNQUFNLE9BQU8sR0FBaUMsRUFBRSxDQUFDO1FBQ2pELE1BQU0sZUFBZSxHQUFHLElBQUksa0NBQWUsRUFBRSxDQUFDO1FBQzlDLEtBQUssTUFBTSxFQUFFLElBQUksV0FBVyxFQUFFO1lBQzVCLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDcEMsV0FBVyxHQUFHLFdBQVcsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDO1lBQzVDLElBQUksRUFBRSxDQUFDLFlBQVksRUFBRTtnQkFDbkIsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUN2QztZQUNELE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENB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QWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUMxQyxPQUFPLENBQUMsVUFBeUIsRUFBRSxFQUFFO2dCQUNuQyxJQUFJLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7b0JBQ3pELE9BQU8sVUFBVSxDQUFDO2lCQUNuQjtnQkFDRCxPQUFPLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUM5QixDQUFDLENBQUM7UUFDSixDQUFDLENBQUM7SUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyB0cyBmcm9tICd0eXBlc2NyaXB0JztcblxuaW1wb3J0IHtBbm5vdGF0b3JIb3N0fSBmcm9tICcuL2Fubm90YXRvcl9ob3N0JztcbmltcG9ydCB7YXNzZXJ0QWJzb2x1dGV9IGZyb20gJy4vY2xpX3N1cHBvcnQnO1xuaW1wb3J0IHtkZWNvcmF0b3JEb3dubGV2ZWxUcmFuc2Zvcm1lcn0gZnJvbSAnLi9kZWNvcmF0b3JfZG93bmxldmVsX3RyYW5zZm9ybWVyJztcbmltcG9ydCB7dHJhbnNmb3JtRGVjb3JhdG9yc091dHB1dEZvckNsb3N1cmVQcm9wZXJ0eVJlbmFtaW5nfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0IHtlbnVtVHJhbnNmb3JtZXJ9IGZyb20gJy4vZW51bV90cmFuc2Zvcm1lcic7XG5pbXBvcnQge2dlbmVyYXRlRXh0ZXJuc30gZnJvbSAnLi9leHRlcm5zJztcbmltcG9ydCB7dHJhbnNmb3JtRmlsZW92ZXJ2aWV3Q29tbWVudEZhY3Rvcnl9IGZyb20gJy4vZmlsZW92ZXJ2aWV3X2NvbW1lbnRfdHJhbnNmb3JtZXInO1xuaW1wb3J0ICogYXMgZ29vZ21vZHVsZSBmcm9tICcuL2dvb2dtb2R1bGUnO1xuaW1wb3J0IHtqc2RvY1RyYW5zZm9ybWVyLCByZW1vdmVUeXBlQXNzZXJ0aW9uc30gZnJvbSAnLi9qc2RvY190cmFuc2Zvcm1lcic7XG5pbXBvcnQge01vZHVsZXNNYW5pZmVzdH0gZnJvbSAnLi9tb2R1bGVzX21hbmlmZXN0JztcbmltcG9ydCB7aXNEdHNGaWxlTmFtZX0gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcblxuLy8gRXhwb3J0ZWQgZm9yIHVzZXJzIGFzIGEgZGVmYXVsdCBpbXBsIG9mIHBhdGhUb01vZHVsZU5hbWUuXG5leHBvcnQge3BhdGhUb01vZHVsZU5hbWV9IGZyb20gJy4vY2xpX3N1cHBvcnQnO1xuLy8gUmV0YWluZWQgaGVyZSBmb3IgQVBJIGNvbXBhdGliaWxpdHkuXG5leHBvcnQge2dldEdlbmVyYXRlZEV4dGVybnN9IGZyb20gJy4vZXh0ZXJucyc7XG5leHBvcnQge0ZpbGVNYXAsIE1vZHVsZXNNYW5pZmVzdH0gZnJvbSAnLi9tb2R1bGVzX21hbmlmZXN0JztcblxuZXhwb3J0IGludGVyZmFjZSBUc2lja2xlSG9zdCBleHRlbmRzIGdvb2dtb2R1bGUuR29vZ01vZHVsZVByb2Nlc3Nvckhvc3QsIEFubm90YXRvckhvc3Qge1xuICAvKipcbiAgICogV2hldGhlciB0byBkb3dubGV2ZWwgZGVjb3JhdG9yc1xuICAgKi9cbiAgdHJhbnNmb3JtRGVjb3JhdG9ycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gY29udmVycyB0eXBlcyB0byBjbG9zdXJlXG4gICAqL1xuICB0cmFuc2Zvcm1UeXBlc1RvQ2xvc3VyZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYWRkIGFsaWFzZXMgdG8gdGhlIC5kLnRzIGZpbGVzIHRvIGFkZCB0aGUgZXhwb3J0cyB0byB0aGVcbiAgICog4LKgX+CyoC5jbHV0eiBuYW1lc3BhY2UuXG4gICAqL1xuICBhZGREdHNDbHV0ekFsaWFzZXM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0c2lja2xlIGFuZCBkZWNvcmF0b3IgZG93bmxldmVsIHByb2Nlc3Npbmcgd2lsbCBiZSBza2lwcGVkIGZvclxuICAgKiB0aGF0IGZpbGUuXG4gICAqL1xuICBzaG91bGRTa2lwVHNpY2tsZVByb2Nlc3NpbmcoZmlsZU5hbWU6IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRzaWNrbGUgdHJlYXRzIHdhcm5pbmdzIGFzIGVycm9ycywgaWYgdHJ1ZSwgaWdub3JlIHdhcm5pbmdzLiAgVGhpcyBtaWdodCBiZVxuICAgKiB1c2VmdWwgZm9yIGUuZy4gdGhpcmQgcGFydHkgY29kZS5cbiAgICovXG4gIHNob3VsZElnbm9yZVdhcm5pbmdzRm9yUGF0aChmaWxlUGF0aDogc3RyaW5nKTogYm9vbGVhbjtcblxuICAvKiogV2hldGhlciB0byBjb252ZXJ0IENvbW1vbkpTIHJlcXVpcmUoKSBpbXBvcnRzIHRvIGdvb2cubW9kdWxlKCkgYW5kIGdvb2cucmVxdWlyZSgpIGNhbGxzLiAqL1xuICBnb29nbW9kdWxlOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VFbWl0UmVzdWx0cyhlbWl0UmVzdWx0czogRW1pdFJlc3VsdFtdKTogRW1pdFJlc3VsdCB7XG4gIGNvbnN0IGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10gPSBbXTtcbiAgbGV0IGVtaXRTa2lwcGVkID0gdHJ1ZTtcbiAgY29uc3QgZW1pdHRlZEZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBleHRlcm5zOiB7W2ZpbGVOYW1lOiBzdHJpbmddOiBzdHJpbmd9ID0ge307XG4gIGNvbnN0IG1vZHVsZXNNYW5pZmVzdCA9IG5ldyBNb2R1bGVzTWFuaWZlc3QoKTtcbiAgZm9yIChjb25zdCBlciBvZiBlbWl0UmVzdWx0cykge1xuICAgIGRpYWdub3N0aWNzLnB1c2goLi4uZXIuZGlhZ25vc3RpY3MpO1xuICAgIGVtaXRTa2lwcGVkID0gZW1pdFNraXBwZWQgfHwgZXIuZW1pdFNraXBwZWQ7XG4gICAgaWYgKGVyLmVtaXR0ZWRGaWxlcykge1xuICAgICAgZW1pdHRlZEZpbGVzLnB1c2goLi4uZXIuZW1pdHRlZEZpbGVzKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihleHRlcm5zLCBlci5leHRlcm5zKTtcbiAgICBtb2R1bGVzTWFuaWZlc3QuYWRkTWFuaWZlc3QoZXIubW9kdWxlc01hbmlmZXN0KTtcbiAgfVxuICByZXR1cm4ge2RpYWdub3N0aWNzLCBlbWl0U2tpcHBlZCwgZW1pdHRlZEZpbGVzLCBleHRlcm5zLCBtb2R1bGVzTWFuaWZlc3R9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVtaXRSZXN1bHQgZXh0ZW5kcyB0cy5FbWl0UmVzdWx0IHtcbiAgLy8gVGhlIG1hbmlmZXN0IG9mIEpTIG1vZHVsZXMgb3V0cHV0IGJ5IHRoZSBjb21waWxlci5cbiAgbW9kdWxlc01hbmlmZXN0OiBNb2R1bGVzTWFuaWZlc3Q7XG4gIC8qKlxuICAgKiBleHRlcm5zLmpzIGZpbGVzIHByb2R1Y2VkIGJ5IHRzaWNrbGUsIGlmIGFueS4gbW9kdWxlIElEcyBhcmUgcmVsYXRpdmUgcGF0aHMgZnJvbVxuICAgKiBmaWxlTmFtZVRvTW9kdWxlSWQuXG4gICAqL1xuICBleHRlcm5zOiB7W21vZHVsZUlkOiBzdHJpbmddOiBzdHJpbmd9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVtaXRUcmFuc2Zvcm1lcnMge1xuICAvKiogQ3VzdG9tIHRyYW5zZm9ybWVycyB0byBldmFsdWF0ZSBiZWZvcmUgVHNpY2tsZSAuanMgdHJhbnNmb3JtYXRpb25zLiAqL1xuICBiZWZvcmVUc2lja2xlPzogdHMuQ3VzdG9tVHJhbnNmb3JtZXJzWydiZWZvcmUnXTtcbiAgLyoqIEN1c3RvbSB0cmFuc2Zvcm1lcnMgdG8gZXZhbHVhdGUgYmVmb3JlIGJ1aWx0LWluIC5qcyB0cmFuc2Zvcm1hdGlvbnMuICovXG4gIGJlZm9yZVRzPzogdHMuQ3VzdG9tVHJhbnNmb3JtZXJzWydiZWZvcmUnXTtcbiAgLyoqIEN1c3RvbSB0cmFuc2Zvcm1lcnMgdG8gZXZhbHVhdGUgYWZ0ZXIgYnVpbHQtaW4gLmpzIHRyYW5zZm9ybWF0aW9ucy4gKi9cbiAgYWZ0ZXJUcz86IHRzLkN1c3RvbVRyYW5zZm9ybWVyc1snYWZ0ZXInXTtcbiAgLyoqIEN1c3RvbSB0cmFuc2Zvcm1lcnMgdG8gZXZhbHVhdGUgYWZ0ZXIgYnVpbHQtaW4gLmQudHMgdHJhbnNmb3JtYXRpb25zLiAqL1xuICBhZnRlckRlY2xhcmF0aW9ucz86IHRzLkN1c3RvbVRyYW5zZm9ybWVyc1snYWZ0ZXJEZWNsYXJhdGlvbnMnXTtcbn1cblxuXG4vKiogQGRlcHJlY2F0ZWQgRXhwb3NlZCBmb3IgYmFja3dhcmQgY29tcGF0IHdpdGggQW5ndWxhci4gIFVzZSBlbWl0KCkgaW5zdGVhZC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbWl0V2l0aFRzaWNrbGUoXG4gICAgcHJvZ3JhbTogdHMuUHJvZ3JhbSwgaG9zdDogVHNpY2tsZUhvc3QsIHRzSG9zdDogdHMuQ29tcGlsZXJIb3N0LCB0c09wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyxcbiAgICB0YXJnZXRTb3VyY2VGaWxlPzogdHMuU291cmNlRmlsZSwgd3JpdGVGaWxlPzogdHMuV3JpdGVGaWxlQ2FsbGJhY2ssXG4gICAgY2FuY2VsbGF0aW9uVG9rZW4/OiB0cy5DYW5jZWxsYXRpb25Ub2tlbiwgZW1pdE9ubHlEdHNGaWxlcz86IGJvb2xlYW4sXG4gICAgY3VzdG9tVHJhbnNmb3JtZXJzOiBFbWl0VHJhbnNmb3JtZXJzID0ge30pOiBFbWl0UmVzdWx0IHtcbiAgcmV0dXJuIGVtaXQoXG4gICAgICBwcm9ncmFtLCBob3N0LCB3cml0ZUZpbGUgfHwgdHNIb3N0LndyaXRlRmlsZS5iaW5kKHRzSG9zdCksIHRhcmdldFNvdXJjZUZpbGUsXG4gICAgICBjYW5jZWxsYXRpb25Ub2tlbiwgZW1pdE9ubHlEdHNGaWxlcywgY3VzdG9tVHJhbnNmb3JtZXJzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXQoXG4gICAgcHJvZ3JhbTogdHMuUHJvZ3JhbSwgaG9zdDogVHNpY2tsZUhvc3QsIHdyaXRlRmlsZTogdHMuV3JpdGVGaWxlQ2FsbGJhY2ssXG4gICAgdGFyZ2V0U291cmNlRmlsZT86IHRzLlNvdXJjZUZpbGUsIGNhbmNlbGxhdGlvblRva2VuPzogdHMuQ2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgZW1pdE9ubHlEdHNGaWxlcz86IGJvb2xlYW4sIGN1c3RvbVRyYW5zZm9ybWVyczogRW1pdFRyYW5zZm9ybWVycyA9IHt9KTogRW1pdFJlc3VsdCB7XG4gIGZvciAoY29uc3Qgc2Ygb2YgcHJvZ3JhbS5nZXRTb3VyY2VGaWxlcygpKSB7XG4gICAgYXNzZXJ0QWJzb2x1dGUoc2YuZmlsZU5hbWUpO1xuICB9XG5cbiAgbGV0IHRzaWNrbGVEaWFnbm9zdGljczogdHMuRGlhZ25vc3RpY1tdID0gW107XG4gIGNvbnN0IHR5cGVDaGVja2VyID0gcHJvZ3JhbS5nZXRUeXBlQ2hlY2tlcigpO1xuICBjb25zdCB0c09wdGlvbnMgPSBwcm9ncmFtLmdldENvbXBpbGVyT3B0aW9ucygpO1xuICBjb25zdCB0c2lja2xlU291cmNlVHJhbnNmb3JtZXJzOiBBcnJheTx0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4+ID0gW107XG4gIGlmIChob3N0LnRyYW5zZm9ybVR5cGVzVG9DbG9zdXJlKSB7XG4gICAgLy8gT25seSBhZGQgQHN1cHByZXNzIHtjaGVja1R5cGVzfSBjb21tZW50cyB3aGVuIGFsc28gYWRkaW5nIHR5cGUgYW5ub3RhdGlvbnMuXG4gICAgdHNpY2tsZVNvdXJjZVRyYW5zZm9ybWVycy5wdXNoKFxuICAgICAgICB0cmFuc2Zvcm1GaWxlb3ZlcnZpZXdDb21tZW50RmFjdG9yeSh0c09wdGlvbnMsIHRzaWNrbGVEaWFnbm9zdGljcykpO1xuICAgIHRzaWNrbGVTb3VyY2VUcmFuc2Zvcm1lcnMucHVzaChcbiAgICAgICAganNkb2NUcmFuc2Zvcm1lcihob3N0LCB0c09wdGlvbnMsIHR5cGVDaGVja2VyLCB0c2lja2xlRGlhZ25vc3RpY3MpKTtcbiAgICB0c2lja2xlU291cmNlVHJhbnNmb3JtZXJzLnB1c2goZW51bVRyYW5zZm9ybWVyKHR5cGVDaGVja2VyLCB0c2lja2xlRGlhZ25vc3RpY3MpKTtcbiAgfVxuICBpZiAoaG9zdC50cmFuc2Zvcm1EZWNvcmF0b3JzKSB7XG4gICAgdHNpY2tsZVNvdXJjZVRyYW5zZm9ybWVycy5wdXNoKGRlY29yYXRvckRvd25sZXZlbFRyYW5zZm9ybWVyKHR5cGVDaGVja2VyLCB0c2lja2xlRGlhZ25vc3RpY3MpKTtcbiAgfVxuICBjb25zdCBtb2R1bGVzTWFuaWZlc3QgPSBuZXcgTW9kdWxlc01hbmlmZXN0KCk7XG4gIGNvbnN0IHRzVHJhbnNmb3JtZXJzOiB0cy5DdXN0b21UcmFuc2Zvcm1lcnMgPSB7XG4gICAgYmVmb3JlOiBbXG4gICAgICAuLi4oY3VzdG9tVHJhbnNmb3JtZXJzLmJlZm9yZVRzaWNrbGUgfHwgW10pLFxuICAgICAgLi4uKHRzaWNrbGVTb3VyY2VUcmFuc2Zvcm1lcnMgfHwgW10pLm1hcCh0ZiA9PiBza2lwVHJhbnNmb3JtRm9yU291cmNlRmlsZUlmTmVlZGVkKGhvc3QsIHRmKSksXG4gICAgICAuLi4oY3VzdG9tVHJhbnNmb3JtZXJzLmJlZm9yZVRzIHx8IFtdKSxcbiAgICBdLFxuICAgIGFmdGVyOiBbXG4gICAgICAuLi4oY3VzdG9tVHJhbnNmb3JtZXJzLmFmdGVyVHMgfHwgW10pLFxuICAgIF0sXG4gICAgYWZ0ZXJEZWNsYXJhdGlvbnM6IGN1c3RvbVRyYW5zZm9ybWVycy5hZnRlckRlY2xhcmF0aW9ucyxcbiAgfTtcbiAgaWYgKGhvc3QudHJhbnNmb3JtVHlwZXNUb0Nsb3N1cmUpIHtcbiAgICAvLyBTZWUgY29tbWVudCBvbiByZW1vdGVUeXBlQXNzZXJ0aW9ucy5cbiAgICB0c1RyYW5zZm9ybWVycy5iZWZvcmUhLnB1c2gocmVtb3ZlVHlwZUFzc2VydGlvbnMoKSk7XG4gIH1cbiAgaWYgKGhvc3QuZ29vZ21vZHVsZSkge1xuICAgIHRzVHJhbnNmb3JtZXJzLmFmdGVyIS5wdXNoKGdvb2dtb2R1bGUuY29tbW9uSnNUb0dvb2dtb2R1bGVUcmFuc2Zvcm1lcihcbiAgICAgICAgaG9zdCwgbW9kdWxlc01hbmlmZXN0LCB0eXBlQ2hlY2tlciwgdHNpY2tsZURpYWdub3N0aWNzKSk7XG4gICAgdHNUcmFuc2Zvcm1lcnMuYWZ0ZXIhLnB1c2goXG4gICAgICAgIHRyYW5zZm9ybURlY29yYXRvcnNPdXRwdXRGb3JDbG9zdXJlUHJvcGVydHlSZW5hbWluZyh0c2lja2xlRGlhZ25vc3RpY3MpKTtcbiAgfVxuXG4gIC8vIFdyYXAgdGhlIHdyaXRlRmlsZSBjYWxsYmFjayB0byBob29rIHdyaXRpbmcgb2YgdGhlIGR0cyBmaWxlLlxuICBjb25zdCB3cml0ZUZpbGVJbXBsOiB0cy5Xcml0ZUZpbGVDYWxsYmFjayA9XG4gICAgICAoZmlsZU5hbWUsIGNvbnRlbnQsIHdyaXRlQnl0ZU9yZGVyTWFyaywgb25FcnJvciwgc291cmNlRmlsZXMpID0+IHtcbiAgICAgICAgYXNzZXJ0QWJzb2x1dGUoZmlsZU5hbWUpO1xuICAgICAgICBpZiAoaG9zdC5hZGREdHNDbHV0ekFsaWFzZXMgJiYgaXNEdHNGaWxlTmFtZShmaWxlTmFtZSkgJiYgc291cmNlRmlsZXMpIHtcbiAgICAgICAgICAvLyBPbmx5IGJ1bmRsZSBlbWl0cyBwYXNzIG1vcmUgdGhhbiBvbmUgc291cmNlIGZpbGUgZm9yIC5kLnRzIHdyaXRlcy4gQnVuZGxlIGVtaXRzIGhvd2V2ZXJcbiAgICAgICAgICAvLyBhcmUgbm90IHN1cHBvcnRlZCBieSB0c2lja2xlLCBhcyB3ZSBjYW5ub3QgYW5ub3RhdGUgdGhlbSBmb3IgQ2xvc3VyZSBpbiBhbnkgbWVhbmluZ2Z1bFxuICAgICAgICAgIC8vIHdheSBhbnl3YXkuXG4gICAgICAgICAgaWYgKCFzb3VyY2VGaWxlcyB8fCBzb3VyY2VGaWxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIGV4YWN0bHkgb25lIHNvdXJjZSBmaWxlIGZvciAuZC50cyBlbWl0LCBnb3QgJHtcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWxlcy5tYXAoc2YgPT4gc2YuZmlsZU5hbWUpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFNvdXJjZSA9IHNvdXJjZUZpbGVzWzBdO1xuICAgICAgICAgIGNvbnRlbnQgPSBhZGRDbHV0ekFsaWFzZXMoY29udGVudCwgb3JpZ2luYWxTb3VyY2UsIHR5cGVDaGVja2VyLCBob3N0LCB0c09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlRmlsZShmaWxlTmFtZSwgY29udGVudCwgd3JpdGVCeXRlT3JkZXJNYXJrLCBvbkVycm9yLCBzb3VyY2VGaWxlcyk7XG4gICAgICB9O1xuXG4gIGNvbnN0IHtkaWFnbm9zdGljczogdHNEaWFnbm9zdGljcywgZW1pdFNraXBwZWQsIGVtaXR0ZWRGaWxlc30gPSBwcm9ncmFtLmVtaXQoXG4gICAgICB0YXJnZXRTb3VyY2VGaWxlLCB3cml0ZUZpbGVJbXBsLCBjYW5jZWxsYXRpb25Ub2tlbiwgZW1pdE9ubHlEdHNGaWxlcywgdHNUcmFuc2Zvcm1lcnMpO1xuXG4gIGNvbnN0IGV4dGVybnM6IHtbZmlsZU5hbWU6IHN0cmluZ106IHN0cmluZ30gPSB7fTtcbiAgaWYgKGhvc3QudHJhbnNmb3JtVHlwZXNUb0Nsb3N1cmUpIHtcbiAgICBjb25zdCBzb3VyY2VGaWxlcyA9IHRhcmdldFNvdXJjZUZpbGUgPyBbdGFyZ2V0U291cmNlRmlsZV0gOiBwcm9ncmFtLmdldFNvdXJjZUZpbGVzKCk7XG4gICAgZm9yIChjb25zdCBzb3VyY2VGaWxlIG9mIHNvdXJjZUZpbGVzKSB7XG4gICAgICBjb25zdCBpc0R0cyA9IGlzRHRzRmlsZU5hbWUoc291cmNlRmlsZS5maWxlTmFtZSk7XG4gICAgICBpZiAoaXNEdHMgJiYgaG9zdC5zaG91bGRTa2lwVHNpY2tsZVByb2Nlc3Npbmcoc291cmNlRmlsZS5maWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7b3V0cHV0LCBkaWFnbm9zdGljc30gPSBnZW5lcmF0ZUV4dGVybnMoXG4gICAgICAgICAgdHlwZUNoZWNrZXIsIHNvdXJjZUZpbGUsIGhvc3QsIGhvc3QubW9kdWxlUmVzb2x1dGlvbkhvc3QsIHByb2dyYW0uZ2V0Q29tcGlsZXJPcHRpb25zKCkpO1xuICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICBleHRlcm5zW3NvdXJjZUZpbGUuZmlsZU5hbWVdID0gb3V0cHV0O1xuICAgICAgfVxuICAgICAgaWYgKGRpYWdub3N0aWNzKSB7XG4gICAgICAgIHRzaWNrbGVEaWFnbm9zdGljcy5wdXNoKC4uLmRpYWdub3N0aWNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQWxsIGRpYWdub3N0aWNzIChpbmNsdWRpbmcgd2FybmluZ3MpIGFyZSB0cmVhdGVkIGFzIGVycm9ycy5cbiAgLy8gSWYgdGhlIGhvc3QgZGVjaWRlcyB0byBpZ25vcmUgd2FybmluZ3MsIGp1c3QgZGlzY2FyZCB0aGVtLlxuICAvLyBXYXJuaW5ncyBpbmNsdWRlIHN0dWZmIGxpa2UgXCJkb24ndCB1c2UgQHR5cGUgaW4geW91ciBqc2RvY1wiOyB0c2lja2xlXG4gIC8vIHdhcm5zIGFuZCB0aGVuIGZpeGVzIHVwIHRoZSBjb2RlIHRvIGJlIENsb3N1cmUtY29tcGF0aWJsZSBhbnl3YXkuXG4gIHRzaWNrbGVEaWFnbm9zdGljcyA9IHRzaWNrbGVEaWFnbm9zdGljcy5maWx0ZXIoXG4gICAgICBkID0+IGQuY2F0ZWdvcnkgPT09IHRzLkRpYWdub3N0aWNDYXRlZ29yeS5FcnJvciB8fFxuICAgICAgICAgICFob3N0LnNob3VsZElnbm9yZVdhcm5pbmdzRm9yUGF0aChkLmZpbGUhLmZpbGVOYW1lKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBtb2R1bGVzTWFuaWZlc3QsXG4gICAgZW1pdFNraXBwZWQsXG4gICAgZW1pdHRlZEZpbGVzOiBlbWl0dGVkRmlsZXMgfHwgW10sXG4gICAgZGlhZ25vc3RpY3M6IFsuLi50c0RpYWdub3N0aWNzLCAuLi50c2lja2xlRGlhZ25vc3RpY3NdLFxuICAgIGV4dGVybnNcbiAgfTtcbn1cblxuLyoqIENvbXBhcmVzIHR3byBzdHJpbmdzIGFuZCByZXR1cm5zIGEgbnVtYmVyIHN1aXRhYmxlIGZvciB1c2UgaW4gc29ydCgpLiAqL1xuZnVuY3Rpb24gc3RyaW5nQ29tcGFyZShhOiBzdHJpbmcsIGI6IHN0cmluZyk6IG51bWJlciB7XG4gIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBBIHRzaWNrbGUgcHJvZHVjZWQgZGVjbGFyYXRpb24gZmlsZSBtaWdodCBiZSBjb25zdW1lZCBiZSByZWZlcmVuY2VkIGJ5IENsdXR6XG4gKiBwcm9kdWNlZCAuZC50cyBmaWxlcywgd2hpY2ggdXNlIHN5bWJvbCBuYW1lcyBiYXNlZCBvbiBDbG9zdXJlJ3MgaW50ZXJuYWxcbiAqIG5hbWluZyBjb252ZW50aW9ucywgc28gd2UgbmVlZCB0byBwcm92aWRlIGFsaWFzZXMgZm9yIGFsbCB0aGUgZXhwb3J0ZWQgc3ltYm9sc1xuICogaW4gdGhlIENsdXR6IG5hbWluZyBjb252ZW50aW9uLlxuICovXG5mdW5jdGlvbiBhZGRDbHV0ekFsaWFzZXMoXG4gICAgZHRzRmlsZUNvbnRlbnQ6IHN0cmluZywgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSwgdHlwZUNoZWNrZXI6IHRzLlR5cGVDaGVja2VyLFxuICAgIGhvc3Q6IFRzaWNrbGVIb3N0LCBvcHRpb25zOiB0cy5Db21waWxlck9wdGlvbnMpOiBzdHJpbmcge1xuICBjb25zdCBtb2R1bGVTeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRTeW1ib2xBdExvY2F0aW9uKHNvdXJjZUZpbGUpO1xuICBjb25zdCBtb2R1bGVFeHBvcnRzID0gbW9kdWxlU3ltYm9sICYmIHR5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShtb2R1bGVTeW1ib2wpO1xuICBpZiAoIW1vZHVsZUV4cG9ydHMpIHJldHVybiBkdHNGaWxlQ29udGVudDtcblxuICAvLyAuZC50cyBmaWxlcyBjYW4gYmUgdHJhbnNmb3JtZWQsIHRvbywgc28gd2UgbmVlZCB0byBjb21wYXJlIHRoZSBvcmlnaW5hbCBub2RlIGJlbG93LlxuICBjb25zdCBvcmlnU291cmNlRmlsZSA9IHRzLmdldE9yaWdpbmFsTm9kZShzb3VyY2VGaWxlKTtcbiAgLy8gSW4gb3JkZXIgdG8gd3JpdGUgYWxpYXNlcywgdGhlIGV4cG9ydGVkIHN5bWJvbHMgbmVlZCB0byBiZSBhdmFpbGFibGUgaW4gdGhlXG4gIC8vIHRoZSBtb2R1bGUgc2NvcGUuIFRoYXQgaXMgbm90IGFsd2F5cyB0aGUgY2FzZTpcbiAgLy9cbiAgLy8gZXhwb3J0XG4gIC8vIDEpIGV4cG9ydCBjb25zdCBYOyAgICAgICAgICAgLy8gd29ya3NcbiAgLy9cbiAgLy8gcmVleHBvcnRcbiAgLy8gMikgZXhwb3J0IHtYfSBmcm9tICcuL2Zvbyc7ICAvLyBkb2Vzbid0XG4gIC8vXG4gIC8vIGltcG9ydGVkIHJlZXhwb3J0XG4gIC8vIDMpIGltcG9ydCB7WH0gZnJvbSAnLi9mb28nOyAgLy8gd29ya3NcbiAgLy8gICAgZXhwb3J0IHtYfSBmcm9tICcuL2Zvbyc7XG4gIC8vXG4gIC8vIGdldEV4cG9ydHNPZk1vZHVsZSByZXR1cm5zIGFsbCB0aHJlZSB0eXBlcywgYnV0IHdlIG5lZWQgdG8gc2VwYXJhdGUgMikuXG4gIC8vIEZvciBub3cgd2UgJ2ZpeCcgMikgYnkgc2ltcGx5IG5vdCBlbWl0dGluZyBhIGNsdXR6IGFsaWFzLCBzaW5jZSBjbHV0elxuICAvLyBpbnRlcm9wIGlzIHVzZWQgaW4gbWlub3JpdHkgb2Ygc2NlbmFyaW9zLlxuICAvL1xuICAvLyBUT0RPKHJhZG9raXJvdik6IGF0dGVtcHQgdG8gYWRkIGFwcHJvcHJpYXRlIGltcG9ydHMgZm9yIDIpIHNvIHRoYXRcbiAgLy8gY3VycmVudGx5IGZpbmRpbmcgb3V0IGxvY2FsIGFwcGVhcnMgZXZlbiBoYXJkZXIgdGhhbiBmaXhpbmcgZXhwb3J0cy5cbiAgY29uc3QgbG9jYWxFeHBvcnRzID0gbW9kdWxlRXhwb3J0cy5maWx0ZXIoZSA9PiB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlY2xhcmF0aW9ucywgYmUgY29uc2VydmF0aXZlIGFuZCBkb24ndCBlbWl0IHRoZSBhbGlhc2VzLlxuICAgIC8vIEkgZG9uJ3Qga25vdyBob3cgY2FuIHRoaXMgaGFwcGVuLCB3ZSBoYXZlIG5vIHRlc3RzIHRoYXQgZXhjZXJjaXNlIGl0LlxuICAgIGlmICghZS5kZWNsYXJhdGlvbnMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFNraXAgZGVmYXVsdCBleHBvcnRzLCB0aGV5IGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgICAvLyBkZWZhdWx0IGlzIGEga2V5d29yZCBpbiB0eXBlc2NyaXB0LCBzbyB0aGUgbmFtZSBvZiB0aGUgZXhwb3J0IGJlaW5nXG4gICAgLy8gZGVmYXVsdCBtZWFucyB0aGF0IGl0J3MgYSBkZWZhdWx0IGV4cG9ydC5cbiAgICBpZiAoZS5uYW1lID09PSAnZGVmYXVsdCcpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFVzZSB0aGUgZGVjbGFyYXRpb24gbG9jYXRpb24gdG8gZGV0ZXJtaW5lIHNlcGFyYXRlIGNhc2VzIGFib3ZlLlxuICAgIGZvciAoY29uc3QgZCBvZiBlLmRlY2xhcmF0aW9ucykge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSBmb3IgZXhwb3J0ICouIFRlY2huaWNhbGx5LCBpdCBpcyBvdXRzaWRlIHRoZVxuICAgICAgLy8gdGhyZWUgY2FzZXMgb3V0bGluZWQsIGJ1dCBhdCB0aGlzIHBvaW50IHdlIGhhdmUgcmV3cml0dGVuIGl0IHRvIGFcbiAgICAgIC8vIHJlZXhwb3J0IG9yIGFuIGltcG9ydGVkIHJlZXhwb3J0LiBIb3dldmVyLCBpdCBhcHBlYXJzIHRoYXQgdGhlXG4gICAgICAvLyByZXdyaXRpbmcgYWxzbyBoYXMgbWFkZSBpdCBiZWhhdmUgZGlmZmVyZW50IGZyb20gZXhwbGljaXQgbmFtZWQgZXhwb3J0XG4gICAgICAvLyBpbiB0aGUgc2Vuc2UgdGhhdCB0aGUgZGVjbGFyYXRpb24gYXBwZWFycyB0byBwb2ludCBhdCB0aGUgb3JpZ2luYWxcbiAgICAgIC8vIGxvY2F0aW9uIG5vdCB0aGUgcmVleHBvcnQgbG9jYXRpb24uICBTaW5jZSB3ZSBjYW4ndCBmaWd1cmUgb3V0IHdoZXRoZXJcbiAgICAgIC8vIHRoZXJlIGlzIGEgbG9jYWwgaW1wb3J0IGhlcmUsIHdlIGVyciBvbiB0aGUgc2lkZSBvZiBsZXNzIGVtaXQuXG4gICAgICBpZiAoZC5nZXRTb3VyY2VGaWxlKCkgIT09IG9yaWdTb3VyY2VGaWxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQGludGVybmFsIG1hcmtlZCBBUElzIGFyZSBub3QgZXhwb3J0ZWQsIHNvIG11c3Qgbm90IGdldCBhbGlhc2VzLlxuICAgICAgLy8gVGhpcyB1c2VzIGFuIGludGVybmFsIFRTIEFQSSwgYXNzdW1pbmcgdGhhdCBhY2Nlc3NpbmcgdGhpcyB3aWxsIGJlIG1vcmUgc3RhYmxlIGNvbXBhcmVkIHRvXG4gICAgICAvLyBpbXBsZW1lbnRpbmcgb3VyIG93biB2ZXJzaW9uLlxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1hbnlcbiAgICAgIGlmIChvcHRpb25zLnN0cmlwSW50ZXJuYWwgJiYgKHRzIGFzIGFueSlbJ2lzSW50ZXJuYWxEZWNsYXJhdGlvbiddKGQsIG9yaWdTb3VyY2VGaWxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHMuaXNFeHBvcnRTcGVjaWZpZXIoZCkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHB1cmUgZXhwb3J0IChjYXNlIDEpIHRodXMgc2FmZSB0byBlbWl0IGNsdXR6IGFsaWFzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGRlY2xhcmF0aW9uIGQgaXMgdXNlbGVzcyB0byBzZXBhcmF0ZSByZWV4cG9ydCBhbmQgaW1wb3J0LXJlZXhwb3J0XG4gICAgICAvLyBiZWNhdXNlIHRoZXkgYm90aCBwb2ludCB0byB0aGUgcmVleHBvcnRpbmcgZmlsZSBhbmQgbm90IHRvIHRoZSBvcmlnaW5hbFxuICAgICAgLy8gb25lLiAgSG93ZXZlciwgdGhlcmUgaXMgYW5vdGhlciB0cyBBUEkgdGhhdCBjYW4gZG8gYSBkZWVwZXIgcmVzb2x1dGlvbi5cbiAgICAgIGNvbnN0IGxvY2FsU3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0RXhwb3J0U3BlY2lmaWVyTG9jYWxUYXJnZXRTeW1ib2woZCk7XG4gICAgICAvLyBJIGRvbid0IGtub3cgaG93IGNhbiB0aGlzIGhhcHBlbiwgYnV0IGVyciBvbiB0aGUgc2lkZSBvZiBsZXNzIGVtaXQuXG4gICAgICBpZiAoIWxvY2FsU3ltYm9sKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBgZGVjbGFyYXRpb25zYCBpcyB1bmRlZmluZWQgZm9yIGJ1aWx0aW4gc3ltYm9scywgc3VjaCBhcyBgdW5rbm93bmAuXG4gICAgICBpZiAoIWxvY2FsU3ltYm9sLmRlY2xhcmF0aW9ucykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIG5vIGltcG9ydCB3ZSBlbmRlZCB1cCBpbiBhIGRlY2xhcmF0aW9uIGluIGZvby50cywgd2hpbGUgaW5cbiAgICAgIC8vIGNhc2Ugb2YgaGF2aW5nIGFuIGltcG9ydCBsb2NhbEQgaXMgc3RpbGwgaW4gdGhlIHJlZXhwb3JpbmcgZmlsZS5cbiAgICAgIGZvciAoY29uc3QgbG9jYWxEIG9mIGxvY2FsU3ltYm9sLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBpZiAobG9jYWxELmdldFNvdXJjZUZpbGUoKSAhPT0gb3JpZ1NvdXJjZUZpbGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICBpZiAoIWxvY2FsRXhwb3J0cy5sZW5ndGgpIHJldHVybiBkdHNGaWxlQ29udGVudDtcblxuICAvLyBUeXBlU2NyaXB0IDIuOCBhbmQgVHlwZVNjcmlwdCAyLjkgZGlmZmVyIG9uIHRoZSBvcmRlciBpbiB3aGljaCB0aGVcbiAgLy8gbW9kdWxlIHN5bWJvbHMgY29tZSBvdXQsIHNvIHNvcnQgaGVyZSB0byBtYWtlIHRoZSB0ZXN0cyBzdGFibGUuXG4gIGxvY2FsRXhwb3J0cy5zb3J0KChhLCBiKSA9PiBzdHJpbmdDb21wYXJlKGEubmFtZSwgYi5uYW1lKSk7XG5cbiAgY29uc3QgbW9kdWxlTmFtZSA9IGhvc3QucGF0aFRvTW9kdWxlTmFtZSgnJywgc291cmNlRmlsZS5maWxlTmFtZSk7XG4gIGNvbnN0IGNsdXR6TW9kdWxlTmFtZSA9IG1vZHVsZU5hbWUucmVwbGFjZSgvXFwuL2csICckJyk7XG5cbiAgLy8gQ2x1dHogbWlnaHQgcmVmZXIgdG8gdGhlIG5hbWUgaW4gdHdvIGRpZmZlcmVudCBmb3JtcyAoc3RlbW1pbmcgZnJvbSBnb29nLnByb3ZpZGUgYW5kXG4gIC8vIGdvb2cubW9kdWxlIHJlc3BlY3RpdmVseSkuXG4gIC8vIDEpIGdsb2JhbCBpbiBjbHV0ejogICDgsqBf4LKgLmNsdXR6Lm1vZHVsZSRjb250ZW50cyRwYXRoJHRvJG1vZHVsZV9TeW1ib2wuLi5cbiAgLy8gMikgbG9jYWwgaW4gYSBtb2R1bGU6IOCyoF/gsqAuY2x1dHoubW9kdWxlJGV4cG9ydHMkcGF0aCR0byRtb2R1bGUuU3ltYm9sIC4uXG4gIC8vIFNlZSBleGFtcGxlcyBhdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvY2x1dHovdHJlZS9tYXN0ZXIvc3JjL3Rlc3QvamF2YS9jb20vZ29vZ2xlL2phdmFzY3JpcHQvY2x1dHpcblxuICAvLyBDYXNlICgxKSBmcm9tIGFib3ZlLlxuICBsZXQgZ2xvYmFsU3ltYm9scyA9ICcnO1xuICAvLyBDYXNlICgyKSBmcm9tIGFib3ZlLlxuICBsZXQgbmVzdGVkU3ltYm9scyA9ICcnO1xuICBmb3IgKGNvbnN0IHN5bWJvbCBvZiBsb2NhbEV4cG9ydHMpIHtcbiAgICBsZXQgbG9jYWxOYW1lID0gc3ltYm9sLm5hbWU7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSBzeW1ib2wuZGVjbGFyYXRpb25zLmZpbmQoZCA9PiBkLmdldFNvdXJjZUZpbGUoKSA9PT0gb3JpZ1NvdXJjZUZpbGUpO1xuICAgIGlmIChkZWNsYXJhdGlvbiAmJiB0cy5pc0V4cG9ydFNwZWNpZmllcihkZWNsYXJhdGlvbikgJiYgZGVjbGFyYXRpb24ucHJvcGVydHlOYW1lKSB7XG4gICAgICAvLyBJZiBkZWNsYXJlZCBpbiBhbiBcImV4cG9ydCB7WCBhcyBZfTtcIiBleHBvcnQgc3BlY2lmaWVyLCB0aGVuIFggKHN0b3JlZCBpbiBwcm9wZXJ0eU5hbWUpIGlzXG4gICAgICAvLyB0aGUgbG9jYWwgbmFtZSB0aGF0IHJlc29sdmVzIHdpdGhpbiB0aGUgbW9kdWxlLCB3aGVyZWFzIFkgaXMgb25seSBhdmFpbGFibGUgb24gdGhlIGV4cG9ydHMsXG4gICAgICAvLyBpLmUuIHRoZSBuYW1lIHVzZWQgdG8gYWRkcmVzcyB0aGUgc3ltYm9sIGZyb20gb3V0c2lkZSB0aGUgbW9kdWxlLlxuICAgICAgLy8gVXNlIHRoZSBsb2NhbE5hbWUgZm9yIHRoZSBleHBvcnQgdGhlbiwgYnV0IHB1Ymxpc2ggdW5kZXIgdGhlIGV4dGVybmFsIG5hbWUuXG4gICAgICBsb2NhbE5hbWUgPSBkZWNsYXJhdGlvbi5wcm9wZXJ0eU5hbWUudGV4dDtcbiAgICB9XG4gICAgY29uc3QgbWFuZ2xlZE5hbWUgPSBgbW9kdWxlJGNvbnRlbnRzJCR7Y2x1dHpNb2R1bGVOYW1lfV8ke3N5bWJvbC5uYW1lfWA7XG4gICAgZ2xvYmFsU3ltYm9scyArPSBgXFx0XFx0ZXhwb3J0IHske2xvY2FsTmFtZX0gYXMgJHttYW5nbGVkTmFtZX19XFxuYDtcbiAgICAvLyBUT0RPKG1wcm9ic3QpOiBPbmNlIHRzaWNrbGUgaXMgb24gVFMzLjcsIHRoZSB0d28gbGluZXMgYmVsb3cgY2FuIGJlIHJlcGxhY2VkIHdpdGhcbiAgICAvLyBcImV4cG9ydCB7bG9jYWxOYW1lfTtcIi4gSG93ZXZlciBpbiBUUzMuNSwgbG9jYWxOYW1lIHJlc29sdmVzIHdpdGhpbiB0aGUgbW9kdWxlLCBzb1xuICAgIC8vIGV4cG9ydGluZyB7bG9jYWxOYW1lfSBjYXVzZXMgYSBjaXJjdWxhciBkZWZpbml0aW9uIGVycm9yLiBUaGUgd29ya2Fyb3VuZCBpcyB0byBpbXBvcnQgdGhlXG4gICAgLy8gbWFuZ2xlZCBuYW1lLlxuICAgIG5lc3RlZFN5bWJvbHMgKz0gYFxcdFxcdGltcG9ydCAke2xvY2FsTmFtZX0kY2x1dHogPSDgsqBf4LKgLmNsdXR6LiR7bWFuZ2xlZE5hbWV9O1xcbmA7XG4gICAgbmVzdGVkU3ltYm9scyArPSBgXFx0XFx0ZXhwb3J0IHske2xvY2FsTmFtZX0kY2x1dHogYXMgJHtzeW1ib2wubmFtZX19O1xcbmA7XG4gIH1cblxuICBkdHNGaWxlQ29udGVudCArPSAnZGVjbGFyZSBnbG9iYWwge1xcbic7XG4gIGR0c0ZpbGVDb250ZW50ICs9IGBcXHRuYW1lc3BhY2Ug4LKgX+CyoC5jbHV0eiB7XFxuYDtcbiAgZHRzRmlsZUNvbnRlbnQgKz0gZ2xvYmFsU3ltYm9scztcbiAgZHRzRmlsZUNvbnRlbnQgKz0gYFxcdH1cXG5gO1xuICBkdHNGaWxlQ29udGVudCArPSBgXFx0bmFtZXNwYWNlIOCyoF/gsqAuY2x1dHoubW9kdWxlJGV4cG9ydHMkJHtjbHV0ek1vZHVsZU5hbWV9IHtcXG5gO1xuICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IFNlZSBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM1Mzg1LCByZW1vdmUgb25jZSBmaXhlZFxuICBkdHNGaWxlQ29udGVudCArPSBgXFx0XFx0Y29uc3QgY2x1dHokd29ya2Fyb3VuZCR0aXNzdWUkMzUzODU6IG51bWJlcjtcXG5gO1xuICBkdHNGaWxlQ29udGVudCArPSBuZXN0ZWRTeW1ib2xzO1xuICBkdHNGaWxlQ29udGVudCArPSBgXFx0fVxcbmA7XG4gIGR0c0ZpbGVDb250ZW50ICs9ICd9XFxuJztcblxuICByZXR1cm4gZHRzRmlsZUNvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHNraXBUcmFuc2Zvcm1Gb3JTb3VyY2VGaWxlSWZOZWVkZWQoXG4gICAgaG9zdDogVHNpY2tsZUhvc3QsXG4gICAgZGVsZWdhdGVGYWN0b3J5OiB0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4pOiB0cy5UcmFuc2Zvcm1lckZhY3Rvcnk8dHMuU291cmNlRmlsZT4ge1xuICByZXR1cm4gKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCkgPT4ge1xuICAgIGNvbnN0IGRlbGVnYXRlID0gZGVsZWdhdGVGYWN0b3J5KGNvbnRleHQpO1xuICAgIHJldHVybiAoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSkgPT4ge1xuICAgICAgaWYgKGhvc3Quc2hvdWxkU2tpcFRzaWNrbGVQcm9jZXNzaW5nKHNvdXJjZUZpbGUuZmlsZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VGaWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGVnYXRlKHNvdXJjZUZpbGUpO1xuICAgIH07XG4gIH07XG59XG4iXX0=