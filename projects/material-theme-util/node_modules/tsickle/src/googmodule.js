/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/googmodule", ["require", "exports", "typescript", "tsickle/src/path", "tsickle/src/transformer_util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.commonJsToGoogmoduleTransformer = exports.resolveModuleName = exports.extractGoogNamespaceImport = void 0;
    const ts = require("typescript");
    const path = require("tsickle/src/path");
    const transformer_util_1 = require("tsickle/src/transformer_util");
    /**
     * Returns true if node is a property access of `child` on the identifier `parent`.
     */
    function isPropertyAccess(node, parent, child) {
        if (!ts.isPropertyAccessExpression(node))
            return false;
        return ts.isIdentifier(node.expression) && node.expression.escapedText === parent &&
            node.name.escapedText === child;
    }
    /** isUseStrict returns true if node is a "use strict"; statement. */
    function isUseStrict(node) {
        if (node.kind !== ts.SyntaxKind.ExpressionStatement)
            return false;
        const exprStmt = node;
        const expr = exprStmt.expression;
        if (expr.kind !== ts.SyntaxKind.StringLiteral)
            return false;
        const literal = expr;
        return literal.text === 'use strict';
    }
    /**
     * TypeScript inserts the following code to mark ES moduels in CommonJS:
     *   Object.defineProperty(exports, "__esModule", { value: true });
     * This matches that code snippet.
     */
    function isEsModuleProperty(stmt) {
        // We're matching the explicit source text generated by the TS compiler.
        // Object.defineProperty(exports, "__esModule", { value: true });
        const expr = stmt.expression;
        if (!ts.isCallExpression(expr))
            return false;
        if (!isPropertyAccess(expr.expression, 'Object', 'defineProperty'))
            return false;
        if (expr.arguments.length !== 3)
            return false;
        const [exp, esM, val] = expr.arguments;
        if (!ts.isIdentifier(exp) || exp.escapedText !== 'exports')
            return false;
        if (!ts.isStringLiteral(esM) || esM.text !== '__esModule')
            return false;
        if (!ts.isObjectLiteralExpression(val) || val.properties.length !== 1)
            return false;
        const prop = val.properties[0];
        if (!ts.isPropertyAssignment(prop))
            return false;
        const ident = prop.name;
        if (!ident || !ts.isIdentifier(ident) || ident.text !== 'value')
            return false;
        return prop.initializer.kind === ts.SyntaxKind.TrueKeyword;
    }
    /**
     * TypeScript defaults all exported values to `void 0` by adding a statement at
     * the top of the file that looks like:
     *
     * ```
     * exports.a = exports.b = exports.c = void 0;
     * ```
     *
     * This matches that code snippet.
     */
    function checkExportsVoid0Assignment(expr) {
        // Verify this looks something like `exports.abc = exports.xyz = void 0;`.
        if (!ts.isBinaryExpression(expr))
            return false;
        if (expr.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return false;
        // Verify the left side of the expression is an access on `exports`.
        if (!ts.isPropertyAccessExpression(expr.left))
            return false;
        if (!ts.isIdentifier(expr.left.expression))
            return false;
        if (expr.left.expression.escapedText !== 'exports')
            return false;
        // If the right side is another `exports.abc = ...` check that to see if we
        // eventually hit a `void 0`.
        if (ts.isBinaryExpression(expr.right)) {
            return checkExportsVoid0Assignment(expr.right);
        }
        // Verify the right side is exactly "void 0";
        if (!ts.isVoidExpression(expr.right))
            return false;
        if (!ts.isNumericLiteral(expr.right.expression))
            return false;
        if (expr.right.expression.text !== '0')
            return false;
        return true;
    }
    /**
     * Returns the string argument if call is of the form
     *   require('foo')
     */
    function extractRequire(call) {
        // Verify that the call is a call to require(...).
        if (call.expression.kind !== ts.SyntaxKind.Identifier)
            return null;
        const ident = call.expression;
        if (ident.escapedText !== 'require')
            return null;
        // Verify the call takes a single string argument and grab it.
        if (call.arguments.length !== 1)
            return null;
        const arg = call.arguments[0];
        if (arg.kind !== ts.SyntaxKind.StringLiteral)
            return null;
        return arg.text;
    }
    /** Creates a call expression corresponding to `goog.${methodName}(${literal})`. */
    function createGoogCall(methodName, literal) {
        return ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), methodName), undefined, [literal]);
    }
    /**
     * Extracts the namespace part of a goog: import URL, or returns null if the given import URL is not
     * a goog: import.
     *
     * For example, for `import 'goog:foo.Bar';`, returns `foo.Bar`.
     */
    function extractGoogNamespaceImport(tsImport) {
        if (tsImport.match(/^goog:/))
            return tsImport.substring('goog:'.length);
        return null;
    }
    exports.extractGoogNamespaceImport = extractGoogNamespaceImport;
    /**
     * Convert from implicit `import {} from 'pkg'` to a full resolved file name, including any `/index`
     * suffix and also resolving path mappings. TypeScript and many module loaders support the
     * shorthand, but `goog.module` does not, so tsickle needs to resolve the module name shorthand
     * before generating `goog.module` names.
     */
    function resolveModuleName({ options, moduleResolutionHost }, pathOfImportingFile, imported) {
        // The strategy taken here is to use ts.resolveModuleName() to resolve the import to
        // a specific path, which resolves any /index and path mappings.
        const resolved = ts.resolveModuleName(imported, pathOfImportingFile, options, moduleResolutionHost);
        if (!resolved || !resolved.resolvedModule)
            return imported;
        const resolvedModule = resolved.resolvedModule.resolvedFileName;
        // Check if the resolution went into node_modules.
        // Note that the ResolvedModule returned by resolveModuleName() has an
        // attribute isExternalLibraryImport that is documented with
        // "True if resolvedFileName comes from node_modules", but actually it is just
        // true if the absolute path includes node_modules, and is always true when
        // tsickle itself is under a directory named node_modules.
        const relativeResolved = path.relative(options.rootDir || '', resolvedModule);
        if (relativeResolved.indexOf('node_modules') !== -1) {
            // Imports into node_modules resolve through package.json and must be
            // specially handled by the loader anyway.  Return the input.
            return imported;
        }
        // Otherwise return the full resolved file name. This path will be turned into a module name using
        // AnnotatorHost#pathToModuleName, which also takes care of baseUrl and rootDirs.
        return resolved.resolvedModule.resolvedFileName;
    }
    exports.resolveModuleName = resolveModuleName;
    /**
     * importPathToGoogNamespace converts a TS/ES module './import/path' into a goog.module compatible
     * namespace, handling regular imports and `goog:` namespace imports.
     */
    function importPathToGoogNamespace(host, file, tsImport) {
        let modName;
        const nsImport = extractGoogNamespaceImport(tsImport);
        if (nsImport !== null) {
            // This is a namespace import, of the form "goog:foo.bar".
            // Fix it to just "foo.bar".
            modName = nsImport;
        }
        else {
            if (host.convertIndexImportShorthand) {
                tsImport = resolveModuleName(host, file.fileName, tsImport);
            }
            modName = host.pathToModuleName(file.fileName, tsImport);
        }
        return transformer_util_1.createSingleQuoteStringLiteral(modName);
    }
    /**
     * Replace "module.exports = ..." with just "exports = ...". Returns null if `expr` is not an
     * exports assignment.
     */
    function rewriteModuleExportsAssignment(expr) {
        if (!ts.isBinaryExpression(expr.expression))
            return null;
        if (expr.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
            return null;
        if (!isPropertyAccess(expr.expression.left, 'module', 'exports'))
            return null;
        return ts.setOriginalNode(ts.setTextRange(ts.createStatement(ts.createAssignment(ts.createIdentifier('exports'), expr.expression.right)), expr), expr);
    }
    /**
     * Convert a series of comma-separated expressions
     *   x = foo, y(), z.bar();
     * with statements
     *   x = foo; y(); z.bar();
     * This is for handling in particular the case where
     *   exports.x = ..., exports.y = ...;
     * which Closure rejects.
     *
     * @return An array of statements if it converted, or null otherwise.
     */
    function rewriteCommaExpressions(expr) {
        // There are two representation for comma expressions:
        // 1) a tree of "binary expressions" whose contents are comma operators
        const isBinaryCommaExpression = (expr) => ts.isBinaryExpression(expr) && expr.operatorToken.kind === ts.SyntaxKind.CommaToken;
        // or,
        // 2) a "comma list" expression, where the subexpressions are in one array
        const isCommaList = (expr) => expr.kind === ts.SyntaxKind.CommaListExpression;
        if (!isBinaryCommaExpression(expr) && !isCommaList(expr)) {
            return null;
        }
        // Recursively visit comma-separated subexpressions, and collect them all as
        // separate expression statements.
        return visit(expr);
        function visit(expr) {
            if (isBinaryCommaExpression(expr)) {
                return visit(expr.left).concat(visit(expr.right));
            }
            if (isCommaList(expr)) {
                // TODO(blickly): Simplify using flatMap once node 11 available
                return [].concat(...expr.elements.map(visit));
            }
            return [ts.setOriginalNode(ts.createExpressionStatement(expr), expr)];
        }
    }
    /**
     * commonJsToGoogmoduleTransformer returns a transformer factory that converts TypeScript's CommonJS
     * module emit to Closure Compiler compatible goog.module and goog.require statements.
     */
    function commonJsToGoogmoduleTransformer(host, modulesManifest, typeChecker, diagnostics) {
        return (context) => {
            // TS' CommonJS processing uses onSubstituteNode to, at the very end of processing, substitute
            // "modulename.default" for default imports. We intercept the substitution here, check if it's a
            // .default access, then check if the original node (and thus original import) was from a goog:
            // module, and if so, replace with just the module name.
            const previousOnSubstituteNode = context.onSubstituteNode;
            context.enableSubstitution(ts.SyntaxKind.PropertyAccessExpression);
            context.onSubstituteNode = (hint, node) => {
                node = previousOnSubstituteNode(hint, node);
                if (!ts.isPropertyAccessExpression(node))
                    return node;
                if (node.name.text !== 'default')
                    return node;
                if (!ts.isIdentifier(node.expression))
                    return node;
                // Find the import declaration this node comes from.
                // This may be the original node, if the identifier was transformed from it.
                const orig = ts.getOriginalNode(node.expression);
                let importExportDecl;
                if (ts.isImportDeclaration(orig) || ts.isExportDeclaration(orig)) {
                    importExportDecl = orig;
                }
                else {
                    // Alternatively, we can try to find the declaration of the symbol. This only works for
                    // user-written .default accesses, the generated ones do not have a symbol associated as
                    // they are only produced in the CommonJS transformation, after type checking.
                    const sym = typeChecker.getSymbolAtLocation(node.expression);
                    if (!sym)
                        return node;
                    const decls = sym.getDeclarations();
                    if (!decls || !decls.length)
                        return node;
                    const decl = decls[0];
                    if (decl.parent && decl.parent.parent && ts.isImportDeclaration(decl.parent.parent)) {
                        importExportDecl = decl.parent.parent;
                    }
                    else {
                        return node;
                    }
                }
                // If the import declaration's URL is a "goog:..." style namespace, then all ".default"
                // accesses on it should be replaced with the symbol itself.
                // This allows referring to the module-level export of a "goog.module" or "goog.provide" as if
                // it was an ES6 default export.
                if (extractGoogNamespaceImport(importExportDecl.moduleSpecifier.text)) {
                    // Substitute "foo.default" with just "foo".
                    return node.expression;
                }
                return node;
            };
            return (sf) => {
                // In TS2.9, transformers can receive Bundle objects, which this code cannot handle (given
                // that a bundle by definition cannot be a goog.module()). The cast through any is necessary
                // to remain compatible with earlier TS versions.
                // tslint:disable-next-line:no-any
                if (sf['kind'] !== ts.SyntaxKind.SourceFile)
                    return sf;
                // JS scripts (as opposed to modules), must not be rewritten to
                // goog.modules.
                if (host.isJsTranspilation && !isModule(sf)) {
                    return sf;
                }
                // TypeScript will create at most one `exports.abc = exports.def = void 0`
                // per file. We keep track of if we have already seen it here. If we have
                // seen it already that probably means there was some code like `export
                // const abc = void 0` that we don't want to erase.
                let didRewriteDefaultExportsAssignment = false;
                let moduleVarCounter = 1;
                /**
                 * Creates a new unique variable name for holding an imported module. This
                 * is used to split places where TS wants to codegen code like:
                 *   someExpression(require(...));
                 * which we then rewrite into
                 *   var x = require(...); someExpression(x);
                 */
                function nextModuleVar() {
                    return `tsickle_module_${moduleVarCounter++}_`;
                }
                /**
                 * Maps goog.require namespaces to the variable name they are assigned into. E.g.:
                 *     var $varName = goog.require('$namespace'));
                 */
                const namespaceToModuleVarName = new Map();
                /**
                 * maybeCreateGoogRequire returns a `goog.require()` call for the given
                 * CommonJS `require` call. Returns null if `call` is not a CommonJS
                 * require.
                 *
                 * @param newIdent The identifier to assign the result of the goog.require
                 *     to, or undefined if no assignment is needed.
                 */
                function maybeCreateGoogRequire(original, call, newIdent) {
                    const importedUrl = extractRequire(call);
                    if (!importedUrl)
                        return null;
                    const imp = importPathToGoogNamespace(host, sf, importedUrl);
                    modulesManifest.addReferencedModule(sf.fileName, imp.text);
                    const existingImport = namespaceToModuleVarName.get(imp.text);
                    let initializer;
                    if (!existingImport) {
                        if (newIdent)
                            namespaceToModuleVarName.set(imp.text, newIdent);
                        initializer = createGoogCall('require', imp);
                    }
                    else {
                        initializer = existingImport;
                    }
                    // In JS modules it's recommended that users get a handle on the
                    // goog namespace via:
                    //
                    //    import * as goog from 'google3/javascript/closure/goog.js';
                    //
                    // In a goog.module we just want to access the global `goog` value,
                    // so we skip emitting that import as a goog.require.
                    // We check the goog module name so that we also catch relative imports.
                    if (newIdent && newIdent.escapedText === 'goog' &&
                        imp.text === 'google3.javascript.closure.goog') {
                        return transformer_util_1.createNotEmittedStatementWithComments(sf, original);
                    }
                    if (newIdent) {
                        // Create a statement like one of:
                        //   var foo = goog.require('bar');
                        //   var foo = existingImport;
                        const varDecl = ts.createVariableDeclaration(newIdent, /* type */ undefined, initializer);
                        const newStmt = ts.createVariableStatement(
                        /* modifiers */ undefined, ts.createVariableDeclarationList([varDecl], 
                        // Use 'const' in ES6 mode so Closure properly forwards type
                        // aliases.
                        host.es5Mode ? undefined : ts.NodeFlags.Const));
                        return ts.setOriginalNode(ts.setTextRange(newStmt, original), original);
                    }
                    else if (!newIdent && !existingImport) {
                        // Create a statement like:
                        //   goog.require('bar');
                        const newStmt = ts.createExpressionStatement(initializer);
                        return ts.setOriginalNode(ts.setTextRange(newStmt, original), original);
                    }
                    return transformer_util_1.createNotEmittedStatementWithComments(sf, original);
                }
                /**
                 * Rewrite goog.declareModuleId to something that works in a goog.module.
                 *
                 * goog.declareModuleId exposes a JS module as a goog.module. After we
                 * convert the JS module to a goog.module, what we really want is to
                 * expose the current goog.module at two different module ids. This isn't
                 * possible with the public APIs, but we can make it work at runtime
                 * by writing a record to goog.loadedModules_.
                 *
                 * This only works at runtime, and would fail if compiled by closure
                 * compiler, but that's ok because we only transpile JS in development
                 * mode.
                 */
                function maybeRewriteDeclareModuleId(original, call) {
                    // Verify that the call is a call to goog.declareModuleId(...).
                    if (!ts.isPropertyAccessExpression(call.expression)) {
                        return null;
                    }
                    const propAccess = call.expression;
                    if (propAccess.name.escapedText !== 'declareModuleId') {
                        return null;
                    }
                    if (!ts.isIdentifier(propAccess.expression) ||
                        propAccess.expression.escapedText !== 'goog') {
                        return null;
                    }
                    // Verify the call takes a single string argument and grab it.
                    if (call.arguments.length !== 1) {
                        return null;
                    }
                    const arg = call.arguments[0];
                    if (!ts.isStringLiteral(arg)) {
                        return null;
                    }
                    const moduleId = arg.text;
                    // replace goog.declareModuleId['foo.bar'] with:
                    // goog.loadedModules_['foo.bar'] = {
                    //   exports: exports,
                    //   type: goog.ModuleType.GOOG,
                    //   moduleId: 'foo.bar'
                    // };
                    //
                    // For more info, see `goog.loadModule` in
                    // https://github.com/google/closure-library/blob/master/closure/goog/base.js
                    const newStmt = ts.createStatement(ts.createAssignment(ts.createElementAccess(ts.createPropertyAccess(ts.createIdentifier('goog'), ts.createIdentifier('loadedModules_')), transformer_util_1.createSingleQuoteStringLiteral(moduleId)), ts.createObjectLiteral([
                        ts.createPropertyAssignment('exports', ts.createIdentifier('exports')),
                        ts.createPropertyAssignment('type', ts.createPropertyAccess(ts.createPropertyAccess(ts.createIdentifier('goog'), ts.createIdentifier('ModuleType')), ts.createIdentifier('GOOG'))),
                        ts.createPropertyAssignment('moduleId', transformer_util_1.createSingleQuoteStringLiteral(moduleId)),
                    ])));
                    return ts.setOriginalNode(ts.setTextRange(newStmt, original), original);
                }
                /**
                 * maybeRewriteRequireTslib rewrites a require('tslib') calls to goog.require('tslib'). It
                 * returns the input statement untouched if it does not match.
                 */
                function maybeRewriteRequireTslib(stmt) {
                    if (!ts.isExpressionStatement(stmt))
                        return null;
                    if (!ts.isCallExpression(stmt.expression))
                        return null;
                    const callExpr = stmt.expression;
                    if (!ts.isIdentifier(callExpr.expression) || callExpr.expression.text !== 'require') {
                        return null;
                    }
                    if (callExpr.arguments.length !== 1)
                        return stmt;
                    const arg = callExpr.arguments[0];
                    if (!ts.isStringLiteral(arg) || arg.text !== 'tslib')
                        return null;
                    return ts.setOriginalNode(ts.setTextRange(ts.createStatement(createGoogCall('require', arg)), stmt), stmt);
                }
                /**
                 * Rewrites code generated by `export * as ns from 'ns'` to something like:
                 *
                 * ```
                 * const tsickle_module_n_ = goog.require('ns');
                 * exports.ns = tsickle_module_n_;
                 * ```
                 *
                 * Separating the `goog.require` and `exports.ns` assignment is required by Closure to
                 * correctly infer the type of the exported namespace.
                 */
                function maybeRewriteExportStarAsNs(stmt) {
                    // Ensure this looks something like `exports.ns = require('ns);`.
                    if (!ts.isExpressionStatement(stmt))
                        return null;
                    if (!ts.isBinaryExpression(stmt.expression))
                        return null;
                    if (stmt.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken)
                        return null;
                    // Ensure the left side of the expression is an access on `exports`.
                    if (!ts.isPropertyAccessExpression(stmt.expression.left))
                        return null;
                    if (!ts.isIdentifier(stmt.expression.left.expression))
                        return null;
                    if (stmt.expression.left.expression.escapedText !== 'exports')
                        return null;
                    // Grab the call to `require`, and exit early if not calling `require`.
                    if (!ts.isCallExpression(stmt.expression.right))
                        return null;
                    const ident = ts.createIdentifier(nextModuleVar());
                    const require = maybeCreateGoogRequire(stmt, stmt.expression.right, ident);
                    if (!require)
                        return null;
                    const exportedName = stmt.expression.left.name;
                    const exportStmt = ts.setOriginalNode(ts.setTextRange(ts.createExpressionStatement(ts.createAssignment(ts.createPropertyAccess(ts.createIdentifier('exports'), exportedName), ident)), stmt), stmt);
                    return [require, exportStmt];
                }
                /**
                 * When re-exporting an export from another module TypeScript will wrap it
                 * with an `Object.defineProperty` and getter function to emulate a live
                 * binding, per the ESM spec. goog.module doesn't allow for mutable
                 * exports and Closure Compiler doesn't allow `Object.defineProperty` to
                 * be used with `exports`, so we rewrite the live binding to look like a
                 * plain `exports` assignment. For example, this statement:
                 *
                 * ```
                 * Object.defineProperty(exports, "a", {
                 *   enumerable: true, get: function () { return a_1.a; }
                 * });
                 * ```
                 *
                 * will be transformed into:
                 *
                 * ```
                 * exports.a = a_1.a;
                 * ```
                 */
                function rewriteObjectDefinePropertyOnExports(stmt) {
                    // Verify this node is a function call.
                    if (!ts.isCallExpression(stmt.expression))
                        return null;
                    // Verify the node being called looks like `a.b`.
                    const callExpr = stmt.expression;
                    if (!ts.isPropertyAccessExpression(callExpr.expression))
                        return null;
                    // Verify that the `a.b`-ish thing is actully `Object.defineProperty`.
                    const propAccess = callExpr.expression;
                    if (!ts.isIdentifier(propAccess.expression))
                        return null;
                    if (propAccess.expression.text !== 'Object')
                        return null;
                    if (propAccess.name.text !== 'defineProperty')
                        return null;
                    // Grab each argument to `Object.defineProperty`, and verify that there
                    // are exactly three arguments. The first argument should be the global
                    // `exports` object, the second is the exported name as a string
                    // literal, and the third is a configuration object.
                    if (callExpr.arguments.length !== 3)
                        return null;
                    const [objDefArg1, objDefArg2, objDefArg3] = callExpr.arguments;
                    if (!ts.isIdentifier(objDefArg1))
                        return null;
                    if (objDefArg1.text !== 'exports')
                        return null;
                    if (!ts.isStringLiteral(objDefArg2))
                        return null;
                    if (!ts.isObjectLiteralExpression(objDefArg3))
                        return null;
                    // Returns a "finder" function to location an object property.
                    function findPropNamed(name) {
                        return (p) => {
                            return ts.isPropertyAssignment(p) && ts.isIdentifier(p.name) &&
                                p.name.text === name;
                        };
                    }
                    // Verify that the export is marked as enumerable. If it isn't then this
                    // was not generated by TypeScript.
                    const enumerableConfig = objDefArg3.properties.find(findPropNamed('enumerable'));
                    if (!enumerableConfig)
                        return null;
                    if (!ts.isPropertyAssignment(enumerableConfig))
                        return null;
                    if (enumerableConfig.initializer.kind !== ts.SyntaxKind.TrueKeyword) {
                        return null;
                    }
                    // Verify that the export has a getter function.
                    const getConfig = objDefArg3.properties.find(findPropNamed('get'));
                    if (!getConfig)
                        return null;
                    if (!ts.isPropertyAssignment(getConfig))
                        return null;
                    if (!ts.isFunctionExpression(getConfig.initializer))
                        return null;
                    // Verify that the getter function has exactly one statement that is a
                    // return statement. The node being returned is the real exported value.
                    const getterFunc = getConfig.initializer;
                    if (getterFunc.body.statements.length !== 1)
                        return null;
                    const getterReturn = getterFunc.body.statements[0];
                    if (!ts.isReturnStatement(getterReturn))
                        return null;
                    const realExportValue = getterReturn.expression;
                    if (!realExportValue)
                        return null;
                    // Create a new export statement using the exported name found as the
                    // second argument to `Object.defineProperty` with the value of the
                    // node returned by the getter function.
                    const exportStmt = ts.setOriginalNode(ts.setTextRange(ts.createExpressionStatement(ts.createAssignment(ts.createPropertyAccess(ts.createIdentifier('exports'), objDefArg2.text), realExportValue)), stmt), stmt);
                    return exportStmt;
                }
                /**
                 * visitTopLevelStatement implements the main CommonJS to goog.module conversion. It visits a
                 * SourceFile level statement and adds a (possibly) transformed representation of it into
                 * statements. It adds at least one node per statement to statements.
                 *
                 * visitTopLevelStatement:
                 * - converts require() calls to goog.require() calls, with or w/o var assignment
                 * - removes "use strict"; and "Object.defineProperty(__esModule)" statements
                 * - converts module.exports assignments to just exports assignments
                 * - splits __exportStar() calls into require and export (this needs two statements)
                 * - makes sure to only import each namespace exactly once, and use variables later on
                 */
                function visitTopLevelStatement(statements, sf, node) {
                    // Handle each particular case by adding node to statements, then return.
                    // For unhandled cases, break to jump to the default handling below.
                    // In JS transpilation mode, always rewrite `require('tslib')` to
                    // goog.require('tslib'), ignoring normal module resolution.
                    if (host.isJsTranspilation) {
                        const rewrittenTsLib = maybeRewriteRequireTslib(node);
                        if (rewrittenTsLib) {
                            statements.push(rewrittenTsLib);
                            return;
                        }
                    }
                    switch (node.kind) {
                        case ts.SyntaxKind.ExpressionStatement: {
                            const exprStmt = node;
                            // Check for "use strict" and certain Object.defineProperty and skip it if necessary.
                            if (isUseStrict(exprStmt) || isEsModuleProperty(exprStmt)) {
                                stmts.push(transformer_util_1.createNotEmittedStatementWithComments(sf, exprStmt));
                                return;
                            }
                            // If we have not already seen the defaulted export assignment 
                            // initializing all exports to `void 0`, skip the statement and mark
                            // that we have have now seen it.
                            if (!didRewriteDefaultExportsAssignment &&
                                checkExportsVoid0Assignment(exprStmt.expression)) {
                                didRewriteDefaultExportsAssignment = true;
                                stmts.push(transformer_util_1.createNotEmittedStatementWithComments(sf, exprStmt));
                                return;
                            }
                            // Check for:
                            //   module.exports = ...;
                            const modExports = rewriteModuleExportsAssignment(exprStmt);
                            if (modExports) {
                                stmts.push(modExports);
                                return;
                            }
                            // Check for use of the comma operator.
                            // This occurs in code like
                            //   exports.a = ..., exports.b = ...;
                            // which we want to change into multiple statements.
                            const commaExpanded = rewriteCommaExpressions(exprStmt.expression);
                            if (commaExpanded) {
                                stmts.push(...commaExpanded);
                                return;
                            }
                            // Check for:
                            //   exports.ns = require('...');
                            // which is generated by the `export * as ns from` syntax.
                            const exportStarAsNs = maybeRewriteExportStarAsNs(exprStmt);
                            if (exportStarAsNs) {
                                stmts.push(...exportStarAsNs);
                                return;
                            }
                            // Checks for:
                            //   Object.defineProperty(exports, 'a', {
                            //     enumerable: true, get: { return ...; }
                            //   })
                            // which is a live binding generated when re-exporting from another
                            // module.
                            const exportFromObjDefProp = rewriteObjectDefinePropertyOnExports(exprStmt);
                            if (exportFromObjDefProp) {
                                stmts.push(exportFromObjDefProp);
                                return;
                            }
                            // The rest of this block handles only some function call forms:
                            //   goog.declareModuleId(...);
                            //   require('foo');
                            //   __exportStar(require('foo'), ...);
                            const expr = exprStmt.expression;
                            if (!ts.isCallExpression(expr))
                                break;
                            let callExpr = expr;
                            // Check for declareModuleId.
                            const declaredModuleId = maybeRewriteDeclareModuleId(exprStmt, callExpr);
                            if (declaredModuleId) {
                                statements.push(declaredModuleId);
                                return;
                            }
                            // Check for __exportStar, the commonjs version of 'export *'.
                            // export * creates either a pure top-level '__export(require(...))'
                            // or the imported version, 'tslib.__exportStar(require(...))'. The
                            // imported version is only substituted later on though, so appears
                            // as a plain "__exportStar" on the top level here.
                            const isExportStar = ts.isIdentifier(expr.expression) &&
                                (expr.expression.text === '__exportStar' ||
                                    expr.expression.text === '__export');
                            let newIdent;
                            if (isExportStar) {
                                // Extract the goog.require() from the call. (It will be verified
                                // as a goog.require() below.)
                                callExpr = expr.arguments[0];
                                newIdent = ts.createIdentifier(nextModuleVar());
                            }
                            // Check whether the call is actually a require() and translate
                            // as appropriate.
                            const require = maybeCreateGoogRequire(exprStmt, callExpr, newIdent);
                            if (!require)
                                break;
                            statements.push(require);
                            // If this was an export star, split it up into the import (created
                            // by the maybe call above), and the export operation. This avoids a
                            // Closure complaint about non-top-level requires.
                            if (isExportStar) {
                                const args = [newIdent];
                                if (expr.arguments.length > 1)
                                    args.push(expr.arguments[1]);
                                statements.push(ts.createStatement(ts.createCall(expr.expression, undefined, args)));
                            }
                            return;
                        }
                        case ts.SyntaxKind.VariableStatement: {
                            // It's possibly of the form "var x = require(...);".
                            const varStmt = node;
                            // Verify it's a single decl (and not "var x = ..., y = ...;").
                            if (varStmt.declarationList.declarations.length !== 1)
                                break;
                            const decl = varStmt.declarationList.declarations[0];
                            // Grab the variable name (avoiding things like destructuring binds).
                            if (decl.name.kind !== ts.SyntaxKind.Identifier)
                                break;
                            if (!decl.initializer || !ts.isCallExpression(decl.initializer)) {
                                break;
                            }
                            const require = maybeCreateGoogRequire(varStmt, decl.initializer, decl.name);
                            if (!require)
                                break;
                            statements.push(require);
                            return;
                        }
                        default:
                            break;
                    }
                    statements.push(node);
                }
                const moduleName = host.pathToModuleName('', sf.fileName);
                // Register the namespace this file provides.
                modulesManifest.addModule(sf.fileName, moduleName);
                // Convert each top level statement to goog.module.
                const stmts = [];
                for (const stmt of sf.statements) {
                    visitTopLevelStatement(stmts, sf, stmt);
                }
                // Additional statements that will be prepended (goog.module call etc).
                const headerStmts = [];
                // Emit: goog.module('moduleName');
                const googModule = ts.createStatement(createGoogCall('module', transformer_util_1.createSingleQuoteStringLiteral(moduleName)));
                headerStmts.push(googModule);
                // Allow code to use `module.id` to discover its module URL, e.g. to resolve a template URL
                // against. Uses 'var', as this code is inserted in ES6 and ES5 modes. The following pattern
                // ensures closure doesn't throw an error in advanced optimizations mode.
                // var module = module || {id: 'path/to/module.ts'};
                const moduleId = host.fileNameToModuleId(sf.fileName);
                const moduleVarInitializer = ts.createBinary(ts.createIdentifier('module'), ts.SyntaxKind.BarBarToken, ts.createObjectLiteral([ts.createPropertyAssignment('id', transformer_util_1.createSingleQuoteStringLiteral(moduleId))]));
                const modAssign = ts.createVariableStatement(
                /* modifiers */ undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration('module', /* type */ undefined, moduleVarInitializer)]));
                headerStmts.push(modAssign);
                // Add `goog.require('tslib');` if not JS transpilation, and it hasn't already been required.
                // Rationale:
                // TS gets compiled to Development mode (ES5) and Closure mode (~ES6)
                // sources. Tooling generates module manifests from the Closure version.
                // These manifests are used both with the Closure version and the
                // Development mode version. 'tslib' is sometimes required by the
                // development version but not the Closure version. Inserting the import
                // below unconditionally makes sure that the module manifests are
                // identical between Closure and Development mode, avoiding breakages
                // caused by missing module dependencies.
                if (!host.isJsTranspilation) {
                    // Get a copy of the already resolved module names before calling
                    // resolveModuleName on 'tslib'. Otherwise, resolveModuleName will
                    // add 'tslib' to namespaceToModuleVarName and prevent checking whether
                    // 'tslib' has already been required.
                    const resolvedModuleNames = [...namespaceToModuleVarName.keys()];
                    const tslibModuleName = host.pathToModuleName(sf.fileName, resolveModuleName(host, sf.fileName, 'tslib'));
                    // Only add the extra require if it hasn't already been required
                    if (resolvedModuleNames.indexOf(tslibModuleName) === -1) {
                        const tslibImport = ts.createExpressionStatement(createGoogCall('require', transformer_util_1.createSingleQuoteStringLiteral(tslibModuleName)));
                        // Place the goog.require('tslib') statement right after the goog.module statements
                        headerStmts.push(tslibImport);
                    }
                }
                // Insert goog.module() etc after any leading comments in the source file. The comments have
                // been converted to NotEmittedStatements by transformer_util, which this depends on.
                const insertionIdx = stmts.findIndex(s => s.kind !== ts.SyntaxKind.NotEmittedStatement);
                if (insertionIdx === -1) {
                    stmts.push(...headerStmts);
                }
                else {
                    stmts.splice(insertionIdx, 0, ...headerStmts);
                }
                return ts.updateSourceFileNode(sf, ts.setTextRange(ts.createNodeArray(stmts), sf.statements));
            };
        };
    }
    exports.commonJsToGoogmoduleTransformer = commonJsToGoogmoduleTransformer;
    function isModule(sourceFile) {
        return Boolean(sourceFile.externalModuleIndicator);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ29vZ21vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9nb29nbW9kdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7OztJQUVILGlDQUFpQztJQUdqQyx5Q0FBK0I7SUFDL0IsbUVBQTBHO0lBeUIxRzs7T0FFRztJQUNILFNBQVMsZ0JBQWdCLENBQUMsSUFBYSxFQUFFLE1BQWMsRUFBRSxLQUFhO1FBQ3BFLElBQUksQ0FBQyxFQUFFLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDO1lBQUUsT0FBTyxLQUFLLENBQUM7UUFDdkQsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsS0FBSyxNQUFNO1lBQzdFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxLQUFLLEtBQUssQ0FBQztJQUN0QyxDQUFDO0lBRUQscUVBQXFFO0lBQ3JFLFNBQVMsV0FBVyxDQUFDLElBQWE7UUFDaEMsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsbUJBQW1CO1lBQUUsT0FBTyxLQUFLLENBQUM7UUFDbEUsTUFBTSxRQUFRLEdBQUcsSUFBOEIsQ0FBQztRQUNoRCxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDO1FBQ2pDLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGFBQWE7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUM1RCxNQUFNLE9BQU8sR0FBRyxJQUF3QixDQUFDO1FBQ3pDLE9BQU8sT0FBTyxDQUFDLElBQUksS0FBSyxZQUFZLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxTQUFTLGtCQUFrQixDQUFDLElBQTRCO1FBQ3RELHdFQUF3RTtRQUN4RSxpRUFBaUU7UUFDakUsTUFBTSxJQUFJLEdBQUcsSUFB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dkIsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFDO2lCQUM1QjtxQkFBTTtvQkFDTCxLQUFLLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsR0FBRyxXQUFXLENBQUMsQ0FBQztpQkFDL0M7Z0JBRUQsT0FBTyxFQUFFLENBQUMsb0JBQW9CLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNoRyxDQUFDLENBQUM7UUFDSixDQUFDLENBQUM7SUFDSixDQUFDO0lBaGxCRCwwRUFnbEJDO0lBRUQsU0FBUyxRQUFRLENBQUMsVUFBeUI7UUFNekMsT0FBTyxPQUFPLENBQUUsVUFBaUMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQzdFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmltcG9ydCAqIGFzIHRzIGZyb20gJ3R5cGVzY3JpcHQnO1xuXG5pbXBvcnQge01vZHVsZXNNYW5pZmVzdH0gZnJvbSAnLi9tb2R1bGVzX21hbmlmZXN0JztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAnLi9wYXRoJztcbmltcG9ydCB7Y3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudFdpdGhDb21tZW50cywgY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsLH0gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBHb29nTW9kdWxlUHJvY2Vzc29ySG9zdCB7XG4gIC8qKlxuICAgKiBUYWtlcyBhIGNvbnRleHQgKHRzLlNvdXJjZUZpbGUuZmlsZU5hbWUgb2YgdGhlIGN1cnJlbnQgZmlsZSkgYW5kIHRoZSBpbXBvcnQgVVJMIG9mIGFuIEVTNlxuICAgKiBpbXBvcnQgYW5kIGdlbmVyYXRlcyBhIGdvb2dtb2R1bGUgbW9kdWxlIG5hbWUgZm9yIHRoZSBpbXBvcnRlZCBtb2R1bGUuXG4gICAqL1xuICBwYXRoVG9Nb2R1bGVOYW1lKGNvbnRleHQ6IHN0cmluZywgaW1wb3J0UGF0aDogc3RyaW5nKTogc3RyaW5nO1xuICAvKipcbiAgICogSWYgd2UgZG8gZ29vZ21vZHVsZSBwcm9jZXNzaW5nLCB3ZSBwb2x5ZmlsbCBtb2R1bGUuaWQsIHNpbmNlIHRoYXQnc1xuICAgKiBwYXJ0IG9mIEVTNiBtb2R1bGVzLiAgVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHdoYXQgdGhlIG1vZHVsZS5pZCB3aWxsIGJlXG4gICAqIGZvciBlYWNoIGZpbGUuXG4gICAqL1xuICBmaWxlTmFtZVRvTW9kdWxlSWQoZmlsZU5hbWU6IHN0cmluZyk6IHN0cmluZztcbiAgLyoqIElkZW50aWZpZXMgd2hldGhlciB0aGlzIGZpbGUgaXMgdGhlIHJlc3VsdCBvZiBhIEpTIHRyYW5zcGlsYXRpb24uICovXG4gIGlzSnNUcmFuc3BpbGF0aW9uPzogYm9vbGVhbjtcbiAgLyoqIFdoZXRoZXIgdGhlIGVtaXQgdGFyZ2V0cyBFUzUgb3IgRVM2Ky4gKi9cbiAgZXM1TW9kZT86IGJvb2xlYW47XG4gIC8qKiBleHBhbmQgXCJpbXBvcnQgJ2Zvbyc7XCIgdG8gXCJpbXBvcnQgJ2Zvby9pbmRleCc7XCIgaWYgaXQgcG9pbnRzIHRvIGFuIGluZGV4IGZpbGUuICovXG4gIGNvbnZlcnRJbmRleEltcG9ydFNob3J0aGFuZD86IGJvb2xlYW47XG5cbiAgb3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zO1xuICBtb2R1bGVSZXNvbHV0aW9uSG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYSBwcm9wZXJ0eSBhY2Nlc3Mgb2YgYGNoaWxkYCBvbiB0aGUgaWRlbnRpZmllciBgcGFyZW50YC5cbiAqL1xuZnVuY3Rpb24gaXNQcm9wZXJ0eUFjY2Vzcyhub2RlOiB0cy5Ob2RlLCBwYXJlbnQ6IHN0cmluZywgY2hpbGQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIXRzLmlzUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cy5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uKSAmJiBub2RlLmV4cHJlc3Npb24uZXNjYXBlZFRleHQgPT09IHBhcmVudCAmJlxuICAgICAgbm9kZS5uYW1lLmVzY2FwZWRUZXh0ID09PSBjaGlsZDtcbn1cblxuLyoqIGlzVXNlU3RyaWN0IHJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGEgXCJ1c2Ugc3RyaWN0XCI7IHN0YXRlbWVudC4gKi9cbmZ1bmN0aW9uIGlzVXNlU3RyaWN0KG5vZGU6IHRzLk5vZGUpOiBib29sZWFuIHtcbiAgaWYgKG5vZGUua2luZCAhPT0gdHMuU3ludGF4S2luZC5FeHByZXNzaW9uU3RhdGVtZW50KSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGV4cHJTdG10ID0gbm9kZSBhcyB0cy5FeHByZXNzaW9uU3RhdGVtZW50O1xuICBjb25zdCBleHByID0gZXhwclN0bXQuZXhwcmVzc2lvbjtcbiAgaWYgKGV4cHIua2luZCAhPT0gdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGxpdGVyYWwgPSBleHByIGFzIHRzLlN0cmluZ0xpdGVyYWw7XG4gIHJldHVybiBsaXRlcmFsLnRleHQgPT09ICd1c2Ugc3RyaWN0Jztcbn1cblxuLyoqXG4gKiBUeXBlU2NyaXB0IGluc2VydHMgdGhlIGZvbGxvd2luZyBjb2RlIHRvIG1hcmsgRVMgbW9kdWVscyBpbiBDb21tb25KUzpcbiAqICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICogVGhpcyBtYXRjaGVzIHRoYXQgY29kZSBzbmlwcGV0LlxuICovXG5mdW5jdGlvbiBpc0VzTW9kdWxlUHJvcGVydHkoc3RtdDogdHMuRXhwcmVzc2lvblN0YXRlbWVudCk6IGJvb2xlYW4ge1xuICAvLyBXZSdyZSBtYXRjaGluZyB0aGUgZXhwbGljaXQgc291cmNlIHRleHQgZ2VuZXJhdGVkIGJ5IHRoZSBUUyBjb21waWxlci5cbiAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBjb25zdCBleHByID0gc3RtdC5leHByZXNzaW9uO1xuICBpZiAoIXRzLmlzQ2FsbEV4cHJlc3Npb24oZXhwcikpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc1Byb3BlcnR5QWNjZXNzKGV4cHIuZXhwcmVzc2lvbiwgJ09iamVjdCcsICdkZWZpbmVQcm9wZXJ0eScpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChleHByLmFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgW2V4cCwgZXNNLCB2YWxdID0gZXhwci5hcmd1bWVudHM7XG4gIGlmICghdHMuaXNJZGVudGlmaWVyKGV4cCkgfHwgZXhwLmVzY2FwZWRUZXh0ICE9PSAnZXhwb3J0cycpIHJldHVybiBmYWxzZTtcbiAgaWYgKCF0cy5pc1N0cmluZ0xpdGVyYWwoZXNNKSB8fCBlc00udGV4dCAhPT0gJ19fZXNNb2R1bGUnKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdHMuaXNPYmplY3RMaXRlcmFsRXhwcmVzc2lvbih2YWwpIHx8IHZhbC5wcm9wZXJ0aWVzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwcm9wID0gdmFsLnByb3BlcnRpZXNbMF07XG4gIGlmICghdHMuaXNQcm9wZXJ0eUFzc2lnbm1lbnQocHJvcCkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgaWRlbnQgPSBwcm9wLm5hbWU7XG4gIGlmICghaWRlbnQgfHwgIXRzLmlzSWRlbnRpZmllcihpZGVudCkgfHwgaWRlbnQudGV4dCAhPT0gJ3ZhbHVlJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gcHJvcC5pbml0aWFsaXplci5raW5kID09PSB0cy5TeW50YXhLaW5kLlRydWVLZXl3b3JkO1xufVxuXG4vKipcbiAqIFR5cGVTY3JpcHQgZGVmYXVsdHMgYWxsIGV4cG9ydGVkIHZhbHVlcyB0byBgdm9pZCAwYCBieSBhZGRpbmcgYSBzdGF0ZW1lbnQgYXRcbiAqIHRoZSB0b3Agb2YgdGhlIGZpbGUgdGhhdCBsb29rcyBsaWtlOlxuICpcbiAqIGBgYFxuICogZXhwb3J0cy5hID0gZXhwb3J0cy5iID0gZXhwb3J0cy5jID0gdm9pZCAwO1xuICogYGBgXG4gKlxuICogVGhpcyBtYXRjaGVzIHRoYXQgY29kZSBzbmlwcGV0LlxuICovXG5mdW5jdGlvbiBjaGVja0V4cG9ydHNWb2lkMEFzc2lnbm1lbnQoZXhwcjogdHMuRXhwcmVzc2lvbik6IGJvb2xlYW4ge1xuICAvLyBWZXJpZnkgdGhpcyBsb29rcyBzb21ldGhpbmcgbGlrZSBgZXhwb3J0cy5hYmMgPSBleHBvcnRzLnh5eiA9IHZvaWQgMDtgLlxuICBpZiAoIXRzLmlzQmluYXJ5RXhwcmVzc2lvbihleHByKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZXhwci5vcGVyYXRvclRva2VuLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuRXF1YWxzVG9rZW4pIHJldHVybiBmYWxzZTtcblxuICAvLyBWZXJpZnkgdGhlIGxlZnQgc2lkZSBvZiB0aGUgZXhwcmVzc2lvbiBpcyBhbiBhY2Nlc3Mgb24gYGV4cG9ydHNgLlxuICBpZiAoIXRzLmlzUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKGV4cHIubGVmdCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCF0cy5pc0lkZW50aWZpZXIoZXhwci5sZWZ0LmV4cHJlc3Npb24pKSByZXR1cm4gZmFsc2U7XG4gIGlmIChleHByLmxlZnQuZXhwcmVzc2lvbi5lc2NhcGVkVGV4dCAhPT0gJ2V4cG9ydHMnKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlIHJpZ2h0IHNpZGUgaXMgYW5vdGhlciBgZXhwb3J0cy5hYmMgPSAuLi5gIGNoZWNrIHRoYXQgdG8gc2VlIGlmIHdlXG4gIC8vIGV2ZW50dWFsbHkgaGl0IGEgYHZvaWQgMGAuXG4gIGlmICh0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwci5yaWdodCkpIHtcbiAgICByZXR1cm4gY2hlY2tFeHBvcnRzVm9pZDBBc3NpZ25tZW50KGV4cHIucmlnaHQpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoZSByaWdodCBzaWRlIGlzIGV4YWN0bHkgXCJ2b2lkIDBcIjtcbiAgaWYgKCF0cy5pc1ZvaWRFeHByZXNzaW9uKGV4cHIucmlnaHQpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdHMuaXNOdW1lcmljTGl0ZXJhbChleHByLnJpZ2h0LmV4cHJlc3Npb24pKSByZXR1cm4gZmFsc2U7XG4gIGlmIChleHByLnJpZ2h0LmV4cHJlc3Npb24udGV4dCAhPT0gJzAnKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyBhcmd1bWVudCBpZiBjYWxsIGlzIG9mIHRoZSBmb3JtXG4gKiAgIHJlcXVpcmUoJ2ZvbycpXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RSZXF1aXJlKGNhbGw6IHRzLkNhbGxFeHByZXNzaW9uKTogc3RyaW5nfG51bGwge1xuICAvLyBWZXJpZnkgdGhhdCB0aGUgY2FsbCBpcyBhIGNhbGwgdG8gcmVxdWlyZSguLi4pLlxuICBpZiAoY2FsbC5leHByZXNzaW9uLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGlkZW50ID0gY2FsbC5leHByZXNzaW9uIGFzIHRzLklkZW50aWZpZXI7XG4gIGlmIChpZGVudC5lc2NhcGVkVGV4dCAhPT0gJ3JlcXVpcmUnKSByZXR1cm4gbnVsbDtcblxuICAvLyBWZXJpZnkgdGhlIGNhbGwgdGFrZXMgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IGFuZCBncmFiIGl0LlxuICBpZiAoY2FsbC5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgYXJnID0gY2FsbC5hcmd1bWVudHNbMF07XG4gIGlmIChhcmcua2luZCAhPT0gdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIChhcmcgYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbn1cblxuLyoqIENyZWF0ZXMgYSBjYWxsIGV4cHJlc3Npb24gY29ycmVzcG9uZGluZyB0byBgZ29vZy4ke21ldGhvZE5hbWV9KCR7bGl0ZXJhbH0pYC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdvb2dDYWxsKG1ldGhvZE5hbWU6IHN0cmluZywgbGl0ZXJhbDogdHMuU3RyaW5nTGl0ZXJhbCk6IHRzLkNhbGxFeHByZXNzaW9uIHtcbiAgcmV0dXJuIHRzLmNyZWF0ZUNhbGwoXG4gICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2Vzcyh0cy5jcmVhdGVJZGVudGlmaWVyKCdnb29nJyksIG1ldGhvZE5hbWUpLCB1bmRlZmluZWQsIFtsaXRlcmFsXSk7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIG5hbWVzcGFjZSBwYXJ0IG9mIGEgZ29vZzogaW1wb3J0IFVSTCwgb3IgcmV0dXJucyBudWxsIGlmIHRoZSBnaXZlbiBpbXBvcnQgVVJMIGlzIG5vdFxuICogYSBnb29nOiBpbXBvcnQuXG4gKlxuICogRm9yIGV4YW1wbGUsIGZvciBgaW1wb3J0ICdnb29nOmZvby5CYXInO2AsIHJldHVybnMgYGZvby5CYXJgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQodHNJbXBvcnQ6IHN0cmluZyk6IHN0cmluZ3xudWxsIHtcbiAgaWYgKHRzSW1wb3J0Lm1hdGNoKC9eZ29vZzovKSkgcmV0dXJuIHRzSW1wb3J0LnN1YnN0cmluZygnZ29vZzonLmxlbmd0aCk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBpbXBsaWNpdCBgaW1wb3J0IHt9IGZyb20gJ3BrZydgIHRvIGEgZnVsbCByZXNvbHZlZCBmaWxlIG5hbWUsIGluY2x1ZGluZyBhbnkgYC9pbmRleGBcbiAqIHN1ZmZpeCBhbmQgYWxzbyByZXNvbHZpbmcgcGF0aCBtYXBwaW5ncy4gVHlwZVNjcmlwdCBhbmQgbWFueSBtb2R1bGUgbG9hZGVycyBzdXBwb3J0IHRoZVxuICogc2hvcnRoYW5kLCBidXQgYGdvb2cubW9kdWxlYCBkb2VzIG5vdCwgc28gdHNpY2tsZSBuZWVkcyB0byByZXNvbHZlIHRoZSBtb2R1bGUgbmFtZSBzaG9ydGhhbmRcbiAqIGJlZm9yZSBnZW5lcmF0aW5nIGBnb29nLm1vZHVsZWAgbmFtZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlTW9kdWxlTmFtZShcbiAgICB7b3B0aW9ucywgbW9kdWxlUmVzb2x1dGlvbkhvc3R9OlxuICAgICAgICB7b3B0aW9uczogdHMuQ29tcGlsZXJPcHRpb25zLCBtb2R1bGVSZXNvbHV0aW9uSG9zdDogdHMuTW9kdWxlUmVzb2x1dGlvbkhvc3R9LFxuICAgIHBhdGhPZkltcG9ydGluZ0ZpbGU6IHN0cmluZywgaW1wb3J0ZWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFRoZSBzdHJhdGVneSB0YWtlbiBoZXJlIGlzIHRvIHVzZSB0cy5yZXNvbHZlTW9kdWxlTmFtZSgpIHRvIHJlc29sdmUgdGhlIGltcG9ydCB0b1xuICAvLyBhIHNwZWNpZmljIHBhdGgsIHdoaWNoIHJlc29sdmVzIGFueSAvaW5kZXggYW5kIHBhdGggbWFwcGluZ3MuXG4gIGNvbnN0IHJlc29sdmVkID1cbiAgICAgIHRzLnJlc29sdmVNb2R1bGVOYW1lKGltcG9ydGVkLCBwYXRoT2ZJbXBvcnRpbmdGaWxlLCBvcHRpb25zLCBtb2R1bGVSZXNvbHV0aW9uSG9zdCk7XG4gIGlmICghcmVzb2x2ZWQgfHwgIXJlc29sdmVkLnJlc29sdmVkTW9kdWxlKSByZXR1cm4gaW1wb3J0ZWQ7XG4gIGNvbnN0IHJlc29sdmVkTW9kdWxlID0gcmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRGaWxlTmFtZTtcblxuICAvLyBDaGVjayBpZiB0aGUgcmVzb2x1dGlvbiB3ZW50IGludG8gbm9kZV9tb2R1bGVzLlxuICAvLyBOb3RlIHRoYXQgdGhlIFJlc29sdmVkTW9kdWxlIHJldHVybmVkIGJ5IHJlc29sdmVNb2R1bGVOYW1lKCkgaGFzIGFuXG4gIC8vIGF0dHJpYnV0ZSBpc0V4dGVybmFsTGlicmFyeUltcG9ydCB0aGF0IGlzIGRvY3VtZW50ZWQgd2l0aFxuICAvLyBcIlRydWUgaWYgcmVzb2x2ZWRGaWxlTmFtZSBjb21lcyBmcm9tIG5vZGVfbW9kdWxlc1wiLCBidXQgYWN0dWFsbHkgaXQgaXMganVzdFxuICAvLyB0cnVlIGlmIHRoZSBhYnNvbHV0ZSBwYXRoIGluY2x1ZGVzIG5vZGVfbW9kdWxlcywgYW5kIGlzIGFsd2F5cyB0cnVlIHdoZW5cbiAgLy8gdHNpY2tsZSBpdHNlbGYgaXMgdW5kZXIgYSBkaXJlY3RvcnkgbmFtZWQgbm9kZV9tb2R1bGVzLlxuICBjb25zdCByZWxhdGl2ZVJlc29sdmVkID0gcGF0aC5yZWxhdGl2ZShvcHRpb25zLnJvb3REaXIgfHwgJycsIHJlc29sdmVkTW9kdWxlKTtcbiAgaWYgKHJlbGF0aXZlUmVzb2x2ZWQuaW5kZXhPZignbm9kZV9tb2R1bGVzJykgIT09IC0xKSB7XG4gICAgLy8gSW1wb3J0cyBpbnRvIG5vZGVfbW9kdWxlcyByZXNvbHZlIHRocm91Z2ggcGFja2FnZS5qc29uIGFuZCBtdXN0IGJlXG4gICAgLy8gc3BlY2lhbGx5IGhhbmRsZWQgYnkgdGhlIGxvYWRlciBhbnl3YXkuICBSZXR1cm4gdGhlIGlucHV0LlxuICAgIHJldHVybiBpbXBvcnRlZDtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIGZ1bGwgcmVzb2x2ZWQgZmlsZSBuYW1lLiBUaGlzIHBhdGggd2lsbCBiZSB0dXJuZWQgaW50byBhIG1vZHVsZSBuYW1lIHVzaW5nXG4gIC8vIEFubm90YXRvckhvc3QjcGF0aFRvTW9kdWxlTmFtZSwgd2hpY2ggYWxzbyB0YWtlcyBjYXJlIG9mIGJhc2VVcmwgYW5kIHJvb3REaXJzLlxuICByZXR1cm4gcmVzb2x2ZWQucmVzb2x2ZWRNb2R1bGUucmVzb2x2ZWRGaWxlTmFtZTtcbn1cblxuLyoqXG4gKiBpbXBvcnRQYXRoVG9Hb29nTmFtZXNwYWNlIGNvbnZlcnRzIGEgVFMvRVMgbW9kdWxlICcuL2ltcG9ydC9wYXRoJyBpbnRvIGEgZ29vZy5tb2R1bGUgY29tcGF0aWJsZVxuICogbmFtZXNwYWNlLCBoYW5kbGluZyByZWd1bGFyIGltcG9ydHMgYW5kIGBnb29nOmAgbmFtZXNwYWNlIGltcG9ydHMuXG4gKi9cbmZ1bmN0aW9uIGltcG9ydFBhdGhUb0dvb2dOYW1lc3BhY2UoXG4gICAgaG9zdDogR29vZ01vZHVsZVByb2Nlc3Nvckhvc3QsIGZpbGU6IHRzLlNvdXJjZUZpbGUsIHRzSW1wb3J0OiBzdHJpbmcpOiB0cy5TdHJpbmdMaXRlcmFsIHtcbiAgbGV0IG1vZE5hbWU6IHN0cmluZztcbiAgY29uc3QgbnNJbXBvcnQgPSBleHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydCh0c0ltcG9ydCk7XG4gIGlmIChuc0ltcG9ydCAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSBuYW1lc3BhY2UgaW1wb3J0LCBvZiB0aGUgZm9ybSBcImdvb2c6Zm9vLmJhclwiLlxuICAgIC8vIEZpeCBpdCB0byBqdXN0IFwiZm9vLmJhclwiLlxuICAgIG1vZE5hbWUgPSBuc0ltcG9ydDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaG9zdC5jb252ZXJ0SW5kZXhJbXBvcnRTaG9ydGhhbmQpIHtcbiAgICAgIHRzSW1wb3J0ID0gcmVzb2x2ZU1vZHVsZU5hbWUoaG9zdCwgZmlsZS5maWxlTmFtZSwgdHNJbXBvcnQpO1xuICAgIH1cbiAgICBtb2ROYW1lID0gaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKGZpbGUuZmlsZU5hbWUsIHRzSW1wb3J0KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsKG1vZE5hbWUpO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgXCJtb2R1bGUuZXhwb3J0cyA9IC4uLlwiIHdpdGgganVzdCBcImV4cG9ydHMgPSAuLi5cIi4gUmV0dXJucyBudWxsIGlmIGBleHByYCBpcyBub3QgYW5cbiAqIGV4cG9ydHMgYXNzaWdubWVudC5cbiAqL1xuZnVuY3Rpb24gcmV3cml0ZU1vZHVsZUV4cG9ydHNBc3NpZ25tZW50KGV4cHI6IHRzLkV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgaWYgKCF0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwci5leHByZXNzaW9uKSkgcmV0dXJuIG51bGw7XG4gIGlmIChleHByLmV4cHJlc3Npb24ub3BlcmF0b3JUb2tlbi5raW5kICE9PSB0cy5TeW50YXhLaW5kLkVxdWFsc1Rva2VuKSByZXR1cm4gbnVsbDtcbiAgaWYgKCFpc1Byb3BlcnR5QWNjZXNzKGV4cHIuZXhwcmVzc2lvbi5sZWZ0LCAnbW9kdWxlJywgJ2V4cG9ydHMnKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB0cy5zZXRPcmlnaW5hbE5vZGUoXG4gICAgICB0cy5zZXRUZXh0UmFuZ2UoXG4gICAgICAgICAgdHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgICB0cy5jcmVhdGVBc3NpZ25tZW50KHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2V4cG9ydHMnKSwgZXhwci5leHByZXNzaW9uLnJpZ2h0KSksXG4gICAgICAgICAgZXhwciksXG4gICAgICBleHByKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc2VyaWVzIG9mIGNvbW1hLXNlcGFyYXRlZCBleHByZXNzaW9uc1xuICogICB4ID0gZm9vLCB5KCksIHouYmFyKCk7XG4gKiB3aXRoIHN0YXRlbWVudHNcbiAqICAgeCA9IGZvbzsgeSgpOyB6LmJhcigpO1xuICogVGhpcyBpcyBmb3IgaGFuZGxpbmcgaW4gcGFydGljdWxhciB0aGUgY2FzZSB3aGVyZVxuICogICBleHBvcnRzLnggPSAuLi4sIGV4cG9ydHMueSA9IC4uLjtcbiAqIHdoaWNoIENsb3N1cmUgcmVqZWN0cy5cbiAqXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIHN0YXRlbWVudHMgaWYgaXQgY29udmVydGVkLCBvciBudWxsIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gcmV3cml0ZUNvbW1hRXhwcmVzc2lvbnMoZXhwcjogdHMuRXhwcmVzc2lvbik6IHRzLlN0YXRlbWVudFtdfG51bGwge1xuICAvLyBUaGVyZSBhcmUgdHdvIHJlcHJlc2VudGF0aW9uIGZvciBjb21tYSBleHByZXNzaW9uczpcbiAgLy8gMSkgYSB0cmVlIG9mIFwiYmluYXJ5IGV4cHJlc3Npb25zXCIgd2hvc2UgY29udGVudHMgYXJlIGNvbW1hIG9wZXJhdG9yc1xuICBjb25zdCBpc0JpbmFyeUNvbW1hRXhwcmVzc2lvbiA9IChleHByOiB0cy5FeHByZXNzaW9uKTogZXhwciBpcyB0cy5CaW5hcnlFeHByZXNzaW9uID0+XG4gICAgICB0cy5pc0JpbmFyeUV4cHJlc3Npb24oZXhwcikgJiYgZXhwci5vcGVyYXRvclRva2VuLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29tbWFUb2tlbjtcbiAgLy8gb3IsXG4gIC8vIDIpIGEgXCJjb21tYSBsaXN0XCIgZXhwcmVzc2lvbiwgd2hlcmUgdGhlIHN1YmV4cHJlc3Npb25zIGFyZSBpbiBvbmUgYXJyYXlcbiAgY29uc3QgaXNDb21tYUxpc3QgPSAoZXhwcjogdHMuRXhwcmVzc2lvbik6IGV4cHIgaXMgdHMuQ29tbWFMaXN0RXhwcmVzc2lvbiA9PlxuICAgICAgZXhwci5raW5kID09PSB0cy5TeW50YXhLaW5kLkNvbW1hTGlzdEV4cHJlc3Npb247XG5cbiAgaWYgKCFpc0JpbmFyeUNvbW1hRXhwcmVzc2lvbihleHByKSAmJiAhaXNDb21tYUxpc3QoZXhwcikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IHZpc2l0IGNvbW1hLXNlcGFyYXRlZCBzdWJleHByZXNzaW9ucywgYW5kIGNvbGxlY3QgdGhlbSBhbGwgYXNcbiAgLy8gc2VwYXJhdGUgZXhwcmVzc2lvbiBzdGF0ZW1lbnRzLlxuICByZXR1cm4gdmlzaXQoZXhwcik7XG5cbiAgZnVuY3Rpb24gdmlzaXQoZXhwcjogdHMuRXhwcmVzc2lvbik6IHRzLlN0YXRlbWVudFtdIHtcbiAgICBpZiAoaXNCaW5hcnlDb21tYUV4cHJlc3Npb24oZXhwcikpIHtcbiAgICAgIHJldHVybiB2aXNpdChleHByLmxlZnQpLmNvbmNhdCh2aXNpdChleHByLnJpZ2h0KSk7XG4gICAgfVxuICAgIGlmIChpc0NvbW1hTGlzdChleHByKSkge1xuICAgICAgLy8gVE9ETyhibGlja2x5KTogU2ltcGxpZnkgdXNpbmcgZmxhdE1hcCBvbmNlIG5vZGUgMTEgYXZhaWxhYmxlXG4gICAgICByZXR1cm4gKFtdIGFzIHRzLlN0YXRlbWVudFtdKS5jb25jYXQoLi4uZXhwci5lbGVtZW50cy5tYXAodmlzaXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0cy5zZXRPcmlnaW5hbE5vZGUodHMuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChleHByKSwgZXhwcildO1xuICB9XG59XG5cbi8qKlxuICogY29tbW9uSnNUb0dvb2dtb2R1bGVUcmFuc2Zvcm1lciByZXR1cm5zIGEgdHJhbnNmb3JtZXIgZmFjdG9yeSB0aGF0IGNvbnZlcnRzIFR5cGVTY3JpcHQncyBDb21tb25KU1xuICogbW9kdWxlIGVtaXQgdG8gQ2xvc3VyZSBDb21waWxlciBjb21wYXRpYmxlIGdvb2cubW9kdWxlIGFuZCBnb29nLnJlcXVpcmUgc3RhdGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vbkpzVG9Hb29nbW9kdWxlVHJhbnNmb3JtZXIoXG4gICAgaG9zdDogR29vZ01vZHVsZVByb2Nlc3Nvckhvc3QsIG1vZHVsZXNNYW5pZmVzdDogTW9kdWxlc01hbmlmZXN0LCB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXSk6IChjb250ZXh0OiB0cy5UcmFuc2Zvcm1hdGlvbkNvbnRleHQpID0+XG4gICAgdHMuVHJhbnNmb3JtZXI8dHMuU291cmNlRmlsZT4ge1xuICByZXR1cm4gKGNvbnRleHQ6IHRzLlRyYW5zZm9ybWF0aW9uQ29udGV4dCk6IHRzLlRyYW5zZm9ybWVyPHRzLlNvdXJjZUZpbGU+ID0+IHtcbiAgICAvLyBUUycgQ29tbW9uSlMgcHJvY2Vzc2luZyB1c2VzIG9uU3Vic3RpdHV0ZU5vZGUgdG8sIGF0IHRoZSB2ZXJ5IGVuZCBvZiBwcm9jZXNzaW5nLCBzdWJzdGl0dXRlXG4gICAgLy8gXCJtb2R1bGVuYW1lLmRlZmF1bHRcIiBmb3IgZGVmYXVsdCBpbXBvcnRzLiBXZSBpbnRlcmNlcHQgdGhlIHN1YnN0aXR1dGlvbiBoZXJlLCBjaGVjayBpZiBpdCdzIGFcbiAgICAvLyAuZGVmYXVsdCBhY2Nlc3MsIHRoZW4gY2hlY2sgaWYgdGhlIG9yaWdpbmFsIG5vZGUgKGFuZCB0aHVzIG9yaWdpbmFsIGltcG9ydCkgd2FzIGZyb20gYSBnb29nOlxuICAgIC8vIG1vZHVsZSwgYW5kIGlmIHNvLCByZXBsYWNlIHdpdGgganVzdCB0aGUgbW9kdWxlIG5hbWUuXG4gICAgY29uc3QgcHJldmlvdXNPblN1YnN0aXR1dGVOb2RlID0gY29udGV4dC5vblN1YnN0aXR1dGVOb2RlO1xuICAgIGNvbnRleHQuZW5hYmxlU3Vic3RpdHV0aW9uKHRzLlN5bnRheEtpbmQuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKTtcbiAgICBjb250ZXh0Lm9uU3Vic3RpdHV0ZU5vZGUgPSAoaGludCwgbm9kZTogdHMuTm9kZSk6IHRzLk5vZGUgPT4ge1xuICAgICAgbm9kZSA9IHByZXZpb3VzT25TdWJzdGl0dXRlTm9kZShoaW50LCBub2RlKTtcbiAgICAgIGlmICghdHMuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24obm9kZSkpIHJldHVybiBub2RlO1xuICAgICAgaWYgKG5vZGUubmFtZS50ZXh0ICE9PSAnZGVmYXVsdCcpIHJldHVybiBub2RlO1xuICAgICAgaWYgKCF0cy5pc0lkZW50aWZpZXIobm9kZS5leHByZXNzaW9uKSkgcmV0dXJuIG5vZGU7XG4gICAgICAvLyBGaW5kIHRoZSBpbXBvcnQgZGVjbGFyYXRpb24gdGhpcyBub2RlIGNvbWVzIGZyb20uXG4gICAgICAvLyBUaGlzIG1heSBiZSB0aGUgb3JpZ2luYWwgbm9kZSwgaWYgdGhlIGlkZW50aWZpZXIgd2FzIHRyYW5zZm9ybWVkIGZyb20gaXQuXG4gICAgICBjb25zdCBvcmlnID0gdHMuZ2V0T3JpZ2luYWxOb2RlKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICBsZXQgaW1wb3J0RXhwb3J0RGVjbDogdHMuSW1wb3J0RGVjbGFyYXRpb258dHMuRXhwb3J0RGVjbGFyYXRpb247XG4gICAgICBpZiAodHMuaXNJbXBvcnREZWNsYXJhdGlvbihvcmlnKSB8fCB0cy5pc0V4cG9ydERlY2xhcmF0aW9uKG9yaWcpKSB7XG4gICAgICAgIGltcG9ydEV4cG9ydERlY2wgPSBvcmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIHRyeSB0byBmaW5kIHRoZSBkZWNsYXJhdGlvbiBvZiB0aGUgc3ltYm9sLiBUaGlzIG9ubHkgd29ya3MgZm9yXG4gICAgICAgIC8vIHVzZXItd3JpdHRlbiAuZGVmYXVsdCBhY2Nlc3NlcywgdGhlIGdlbmVyYXRlZCBvbmVzIGRvIG5vdCBoYXZlIGEgc3ltYm9sIGFzc29jaWF0ZWQgYXNcbiAgICAgICAgLy8gdGhleSBhcmUgb25seSBwcm9kdWNlZCBpbiB0aGUgQ29tbW9uSlMgdHJhbnNmb3JtYXRpb24sIGFmdGVyIHR5cGUgY2hlY2tpbmcuXG4gICAgICAgIGNvbnN0IHN5bSA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZS5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKCFzeW0pIHJldHVybiBub2RlO1xuICAgICAgICBjb25zdCBkZWNscyA9IHN5bS5nZXREZWNsYXJhdGlvbnMoKTtcbiAgICAgICAgaWYgKCFkZWNscyB8fCAhZGVjbHMubGVuZ3RoKSByZXR1cm4gbm9kZTtcbiAgICAgICAgY29uc3QgZGVjbCA9IGRlY2xzWzBdO1xuICAgICAgICBpZiAoZGVjbC5wYXJlbnQgJiYgZGVjbC5wYXJlbnQucGFyZW50ICYmIHRzLmlzSW1wb3J0RGVjbGFyYXRpb24oZGVjbC5wYXJlbnQucGFyZW50KSkge1xuICAgICAgICAgIGltcG9ydEV4cG9ydERlY2wgPSBkZWNsLnBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBpbXBvcnQgZGVjbGFyYXRpb24ncyBVUkwgaXMgYSBcImdvb2c6Li4uXCIgc3R5bGUgbmFtZXNwYWNlLCB0aGVuIGFsbCBcIi5kZWZhdWx0XCJcbiAgICAgIC8vIGFjY2Vzc2VzIG9uIGl0IHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIHRoZSBzeW1ib2wgaXRzZWxmLlxuICAgICAgLy8gVGhpcyBhbGxvd3MgcmVmZXJyaW5nIHRvIHRoZSBtb2R1bGUtbGV2ZWwgZXhwb3J0IG9mIGEgXCJnb29nLm1vZHVsZVwiIG9yIFwiZ29vZy5wcm92aWRlXCIgYXMgaWZcbiAgICAgIC8vIGl0IHdhcyBhbiBFUzYgZGVmYXVsdCBleHBvcnQuXG4gICAgICBpZiAoZXh0cmFjdEdvb2dOYW1lc3BhY2VJbXBvcnQoKGltcG9ydEV4cG9ydERlY2wubW9kdWxlU3BlY2lmaWVyIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQpKSB7XG4gICAgICAgIC8vIFN1YnN0aXR1dGUgXCJmb28uZGVmYXVsdFwiIHdpdGgganVzdCBcImZvb1wiLlxuICAgICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIHJldHVybiAoc2Y6IHRzLlNvdXJjZUZpbGUpOiB0cy5Tb3VyY2VGaWxlID0+IHtcbiAgICAgIC8vIEluIFRTMi45LCB0cmFuc2Zvcm1lcnMgY2FuIHJlY2VpdmUgQnVuZGxlIG9iamVjdHMsIHdoaWNoIHRoaXMgY29kZSBjYW5ub3QgaGFuZGxlIChnaXZlblxuICAgICAgLy8gdGhhdCBhIGJ1bmRsZSBieSBkZWZpbml0aW9uIGNhbm5vdCBiZSBhIGdvb2cubW9kdWxlKCkpLiBUaGUgY2FzdCB0aHJvdWdoIGFueSBpcyBuZWNlc3NhcnlcbiAgICAgIC8vIHRvIHJlbWFpbiBjb21wYXRpYmxlIHdpdGggZWFybGllciBUUyB2ZXJzaW9ucy5cbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgIGlmICgoc2YgYXMgYW55KVsna2luZCddICE9PSB0cy5TeW50YXhLaW5kLlNvdXJjZUZpbGUpIHJldHVybiBzZjtcblxuICAgICAgLy8gSlMgc2NyaXB0cyAoYXMgb3Bwb3NlZCB0byBtb2R1bGVzKSwgbXVzdCBub3QgYmUgcmV3cml0dGVuIHRvXG4gICAgICAvLyBnb29nLm1vZHVsZXMuXG4gICAgICBpZiAoaG9zdC5pc0pzVHJhbnNwaWxhdGlvbiAmJiAhaXNNb2R1bGUoc2YpKSB7XG4gICAgICAgIHJldHVybiBzZjtcbiAgICAgIH1cblxuICAgICAgLy8gVHlwZVNjcmlwdCB3aWxsIGNyZWF0ZSBhdCBtb3N0IG9uZSBgZXhwb3J0cy5hYmMgPSBleHBvcnRzLmRlZiA9IHZvaWQgMGBcbiAgICAgIC8vIHBlciBmaWxlLiBXZSBrZWVwIHRyYWNrIG9mIGlmIHdlIGhhdmUgYWxyZWFkeSBzZWVuIGl0IGhlcmUuIElmIHdlIGhhdmVcbiAgICAgIC8vIHNlZW4gaXQgYWxyZWFkeSB0aGF0IHByb2JhYmx5IG1lYW5zIHRoZXJlIHdhcyBzb21lIGNvZGUgbGlrZSBgZXhwb3J0XG4gICAgICAvLyBjb25zdCBhYmMgPSB2b2lkIDBgIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBlcmFzZS5cbiAgICAgIGxldCBkaWRSZXdyaXRlRGVmYXVsdEV4cG9ydHNBc3NpZ25tZW50ID0gZmFsc2U7XG5cbiAgICAgIGxldCBtb2R1bGVWYXJDb3VudGVyID0gMTtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIG5ldyB1bmlxdWUgdmFyaWFibGUgbmFtZSBmb3IgaG9sZGluZyBhbiBpbXBvcnRlZCBtb2R1bGUuIFRoaXNcbiAgICAgICAqIGlzIHVzZWQgdG8gc3BsaXQgcGxhY2VzIHdoZXJlIFRTIHdhbnRzIHRvIGNvZGVnZW4gY29kZSBsaWtlOlxuICAgICAgICogICBzb21lRXhwcmVzc2lvbihyZXF1aXJlKC4uLikpO1xuICAgICAgICogd2hpY2ggd2UgdGhlbiByZXdyaXRlIGludG9cbiAgICAgICAqICAgdmFyIHggPSByZXF1aXJlKC4uLik7IHNvbWVFeHByZXNzaW9uKHgpO1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBuZXh0TW9kdWxlVmFyKCkge1xuICAgICAgICByZXR1cm4gYHRzaWNrbGVfbW9kdWxlXyR7bW9kdWxlVmFyQ291bnRlcisrfV9gO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1hcHMgZ29vZy5yZXF1aXJlIG5hbWVzcGFjZXMgdG8gdGhlIHZhcmlhYmxlIG5hbWUgdGhleSBhcmUgYXNzaWduZWQgaW50by4gRS5nLjpcbiAgICAgICAqICAgICB2YXIgJHZhck5hbWUgPSBnb29nLnJlcXVpcmUoJyRuYW1lc3BhY2UnKSk7XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IG5hbWVzcGFjZVRvTW9kdWxlVmFyTmFtZSA9IG5ldyBNYXA8c3RyaW5nLCB0cy5JZGVudGlmaWVyPigpO1xuXG4gICAgICAvKipcbiAgICAgICAqIG1heWJlQ3JlYXRlR29vZ1JlcXVpcmUgcmV0dXJucyBhIGBnb29nLnJlcXVpcmUoKWAgY2FsbCBmb3IgdGhlIGdpdmVuXG4gICAgICAgKiBDb21tb25KUyBgcmVxdWlyZWAgY2FsbC4gUmV0dXJucyBudWxsIGlmIGBjYWxsYCBpcyBub3QgYSBDb21tb25KU1xuICAgICAgICogcmVxdWlyZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0gbmV3SWRlbnQgVGhlIGlkZW50aWZpZXIgdG8gYXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGdvb2cucmVxdWlyZVxuICAgICAgICogICAgIHRvLCBvciB1bmRlZmluZWQgaWYgbm8gYXNzaWdubWVudCBpcyBuZWVkZWQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG1heWJlQ3JlYXRlR29vZ1JlcXVpcmUoXG4gICAgICAgICAgb3JpZ2luYWw6IHRzLlN0YXRlbWVudCwgY2FsbDogdHMuQ2FsbEV4cHJlc3Npb24sXG4gICAgICAgICAgbmV3SWRlbnQ6IHRzLklkZW50aWZpZXJ8dW5kZWZpbmVkKTogdHMuU3RhdGVtZW50fG51bGwge1xuICAgICAgICBjb25zdCBpbXBvcnRlZFVybCA9IGV4dHJhY3RSZXF1aXJlKGNhbGwpO1xuICAgICAgICBpZiAoIWltcG9ydGVkVXJsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgaW1wID0gaW1wb3J0UGF0aFRvR29vZ05hbWVzcGFjZShob3N0LCBzZiwgaW1wb3J0ZWRVcmwpO1xuICAgICAgICBtb2R1bGVzTWFuaWZlc3QuYWRkUmVmZXJlbmNlZE1vZHVsZShzZi5maWxlTmFtZSwgaW1wLnRleHQpO1xuICAgICAgICBjb25zdCBleGlzdGluZ0ltcG9ydDogdHMuSWRlbnRpZmllcnx1bmRlZmluZWQgPVxuICAgICAgICAgICAgbmFtZXNwYWNlVG9Nb2R1bGVWYXJOYW1lLmdldChpbXAudGV4dCk7XG4gICAgICAgIGxldCBpbml0aWFsaXplcjogdHMuRXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFleGlzdGluZ0ltcG9ydCkge1xuICAgICAgICAgIGlmIChuZXdJZGVudCkgbmFtZXNwYWNlVG9Nb2R1bGVWYXJOYW1lLnNldChpbXAudGV4dCwgbmV3SWRlbnQpO1xuICAgICAgICAgIGluaXRpYWxpemVyID0gY3JlYXRlR29vZ0NhbGwoJ3JlcXVpcmUnLCBpbXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXRpYWxpemVyID0gZXhpc3RpbmdJbXBvcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiBKUyBtb2R1bGVzIGl0J3MgcmVjb21tZW5kZWQgdGhhdCB1c2VycyBnZXQgYSBoYW5kbGUgb24gdGhlXG4gICAgICAgIC8vIGdvb2cgbmFtZXNwYWNlIHZpYTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgaW1wb3J0ICogYXMgZ29vZyBmcm9tICdnb29nbGUzL2phdmFzY3JpcHQvY2xvc3VyZS9nb29nLmpzJztcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gYSBnb29nLm1vZHVsZSB3ZSBqdXN0IHdhbnQgdG8gYWNjZXNzIHRoZSBnbG9iYWwgYGdvb2dgIHZhbHVlLFxuICAgICAgICAvLyBzbyB3ZSBza2lwIGVtaXR0aW5nIHRoYXQgaW1wb3J0IGFzIGEgZ29vZy5yZXF1aXJlLlxuICAgICAgICAvLyBXZSBjaGVjayB0aGUgZ29vZyBtb2R1bGUgbmFtZSBzbyB0aGF0IHdlIGFsc28gY2F0Y2ggcmVsYXRpdmUgaW1wb3J0cy5cbiAgICAgICAgaWYgKG5ld0lkZW50ICYmIG5ld0lkZW50LmVzY2FwZWRUZXh0ID09PSAnZ29vZycgJiZcbiAgICAgICAgICAgIGltcC50ZXh0ID09PSAnZ29vZ2xlMy5qYXZhc2NyaXB0LmNsb3N1cmUuZ29vZycpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTm90RW1pdHRlZFN0YXRlbWVudFdpdGhDb21tZW50cyhzZiwgb3JpZ2luYWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0lkZW50KSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgc3RhdGVtZW50IGxpa2Ugb25lIG9mOlxuICAgICAgICAgIC8vICAgdmFyIGZvbyA9IGdvb2cucmVxdWlyZSgnYmFyJyk7XG4gICAgICAgICAgLy8gICB2YXIgZm9vID0gZXhpc3RpbmdJbXBvcnQ7XG4gICAgICAgICAgY29uc3QgdmFyRGVjbCA9IHRzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb24oXG4gICAgICAgICAgICAgIG5ld0lkZW50LCAvKiB0eXBlICovIHVuZGVmaW5lZCwgaW5pdGlhbGl6ZXIpO1xuICAgICAgICAgIGNvbnN0IG5ld1N0bXQgPSB0cy5jcmVhdGVWYXJpYWJsZVN0YXRlbWVudChcbiAgICAgICAgICAgICAgLyogbW9kaWZpZXJzICovIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoXG4gICAgICAgICAgICAgICAgICBbdmFyRGVjbF0sXG4gICAgICAgICAgICAgICAgICAvLyBVc2UgJ2NvbnN0JyBpbiBFUzYgbW9kZSBzbyBDbG9zdXJlIHByb3Blcmx5IGZvcndhcmRzIHR5cGVcbiAgICAgICAgICAgICAgICAgIC8vIGFsaWFzZXMuXG4gICAgICAgICAgICAgICAgICBob3N0LmVzNU1vZGUgPyB1bmRlZmluZWQgOiB0cy5Ob2RlRmxhZ3MuQ29uc3QpKTtcbiAgICAgICAgICByZXR1cm4gdHMuc2V0T3JpZ2luYWxOb2RlKFxuICAgICAgICAgICAgICB0cy5zZXRUZXh0UmFuZ2UobmV3U3RtdCwgb3JpZ2luYWwpLCBvcmlnaW5hbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld0lkZW50ICYmICFleGlzdGluZ0ltcG9ydCkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIHN0YXRlbWVudCBsaWtlOlxuICAgICAgICAgIC8vICAgZ29vZy5yZXF1aXJlKCdiYXInKTtcbiAgICAgICAgICBjb25zdCBuZXdTdG10ID0gdHMuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChpbml0aWFsaXplcik7XG4gICAgICAgICAgcmV0dXJuIHRzLnNldE9yaWdpbmFsTm9kZShcbiAgICAgICAgICAgICAgdHMuc2V0VGV4dFJhbmdlKG5ld1N0bXQsIG9yaWdpbmFsKSwgb3JpZ2luYWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50V2l0aENvbW1lbnRzKHNmLCBvcmlnaW5hbCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmV3cml0ZSBnb29nLmRlY2xhcmVNb2R1bGVJZCB0byBzb21ldGhpbmcgdGhhdCB3b3JrcyBpbiBhIGdvb2cubW9kdWxlLlxuICAgICAgICpcbiAgICAgICAqIGdvb2cuZGVjbGFyZU1vZHVsZUlkIGV4cG9zZXMgYSBKUyBtb2R1bGUgYXMgYSBnb29nLm1vZHVsZS4gQWZ0ZXIgd2VcbiAgICAgICAqIGNvbnZlcnQgdGhlIEpTIG1vZHVsZSB0byBhIGdvb2cubW9kdWxlLCB3aGF0IHdlIHJlYWxseSB3YW50IGlzIHRvXG4gICAgICAgKiBleHBvc2UgdGhlIGN1cnJlbnQgZ29vZy5tb2R1bGUgYXQgdHdvIGRpZmZlcmVudCBtb2R1bGUgaWRzLiBUaGlzIGlzbid0XG4gICAgICAgKiBwb3NzaWJsZSB3aXRoIHRoZSBwdWJsaWMgQVBJcywgYnV0IHdlIGNhbiBtYWtlIGl0IHdvcmsgYXQgcnVudGltZVxuICAgICAgICogYnkgd3JpdGluZyBhIHJlY29yZCB0byBnb29nLmxvYWRlZE1vZHVsZXNfLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgb25seSB3b3JrcyBhdCBydW50aW1lLCBhbmQgd291bGQgZmFpbCBpZiBjb21waWxlZCBieSBjbG9zdXJlXG4gICAgICAgKiBjb21waWxlciwgYnV0IHRoYXQncyBvayBiZWNhdXNlIHdlIG9ubHkgdHJhbnNwaWxlIEpTIGluIGRldmVsb3BtZW50XG4gICAgICAgKiBtb2RlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBtYXliZVJld3JpdGVEZWNsYXJlTW9kdWxlSWQoXG4gICAgICAgICAgb3JpZ2luYWw6IHRzLlN0YXRlbWVudCwgY2FsbDogdHMuQ2FsbEV4cHJlc3Npb24pOiB0cy5TdGF0ZW1lbnR8bnVsbCB7XG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjYWxsIGlzIGEgY2FsbCB0byBnb29nLmRlY2xhcmVNb2R1bGVJZCguLi4pLlxuICAgICAgICBpZiAoIXRzLmlzUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uKGNhbGwuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wQWNjZXNzID0gY2FsbC5leHByZXNzaW9uO1xuICAgICAgICBpZiAocHJvcEFjY2Vzcy5uYW1lLmVzY2FwZWRUZXh0ICE9PSAnZGVjbGFyZU1vZHVsZUlkJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHMuaXNJZGVudGlmaWVyKHByb3BBY2Nlc3MuZXhwcmVzc2lvbikgfHxcbiAgICAgICAgICAgIHByb3BBY2Nlc3MuZXhwcmVzc2lvbi5lc2NhcGVkVGV4dCAhPT0gJ2dvb2cnKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgdGhlIGNhbGwgdGFrZXMgYSBzaW5nbGUgc3RyaW5nIGFyZ3VtZW50IGFuZCBncmFiIGl0LlxuICAgICAgICBpZiAoY2FsbC5hcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJnID0gY2FsbC5hcmd1bWVudHNbMF07XG4gICAgICAgIGlmICghdHMuaXNTdHJpbmdMaXRlcmFsKGFyZykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2R1bGVJZCA9IGFyZy50ZXh0O1xuICAgICAgICAvLyByZXBsYWNlIGdvb2cuZGVjbGFyZU1vZHVsZUlkWydmb28uYmFyJ10gd2l0aDpcbiAgICAgICAgLy8gZ29vZy5sb2FkZWRNb2R1bGVzX1snZm9vLmJhciddID0ge1xuICAgICAgICAvLyAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgIC8vICAgdHlwZTogZ29vZy5Nb2R1bGVUeXBlLkdPT0csXG4gICAgICAgIC8vICAgbW9kdWxlSWQ6ICdmb28uYmFyJ1xuICAgICAgICAvLyB9O1xuICAgICAgICAvL1xuICAgICAgICAvLyBGb3IgbW9yZSBpbmZvLCBzZWUgYGdvb2cubG9hZE1vZHVsZWAgaW5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL2Jhc2UuanNcbiAgICAgICAgY29uc3QgbmV3U3RtdCA9IHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVBc3NpZ25tZW50KFxuICAgICAgICAgICAgdHMuY3JlYXRlRWxlbWVudEFjY2VzcyhcbiAgICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignZ29vZycpLCB0cy5jcmVhdGVJZGVudGlmaWVyKCdsb2FkZWRNb2R1bGVzXycpKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwobW9kdWxlSWQpKSxcbiAgICAgICAgICAgIHRzLmNyZWF0ZU9iamVjdExpdGVyYWwoW1xuICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQoJ2V4cG9ydHMnLCB0cy5jcmVhdGVJZGVudGlmaWVyKCdleHBvcnRzJykpLFxuICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQoXG4gICAgICAgICAgICAgICAgICAndHlwZScsXG4gICAgICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFjY2VzcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignZ29vZycpLCB0cy5jcmVhdGVJZGVudGlmaWVyKCdNb2R1bGVUeXBlJykpLFxuICAgICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUlkZW50aWZpZXIoJ0dPT0cnKSkpLFxuICAgICAgICAgICAgICB0cy5jcmVhdGVQcm9wZXJ0eUFzc2lnbm1lbnQoJ21vZHVsZUlkJywgY3JlYXRlU2luZ2xlUXVvdGVTdHJpbmdMaXRlcmFsKG1vZHVsZUlkKSksXG4gICAgICAgICAgICBdKSkpO1xuICAgICAgICByZXR1cm4gdHMuc2V0T3JpZ2luYWxOb2RlKHRzLnNldFRleHRSYW5nZShuZXdTdG10LCBvcmlnaW5hbCksIG9yaWdpbmFsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBtYXliZVJld3JpdGVSZXF1aXJlVHNsaWIgcmV3cml0ZXMgYSByZXF1aXJlKCd0c2xpYicpIGNhbGxzIHRvIGdvb2cucmVxdWlyZSgndHNsaWInKS4gSXRcbiAgICAgICAqIHJldHVybnMgdGhlIGlucHV0IHN0YXRlbWVudCB1bnRvdWNoZWQgaWYgaXQgZG9lcyBub3QgbWF0Y2guXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIG1heWJlUmV3cml0ZVJlcXVpcmVUc2xpYihzdG10OiB0cy5TdGF0ZW1lbnQpOiB0cy5TdGF0ZW1lbnR8bnVsbCB7XG4gICAgICAgIGlmICghdHMuaXNFeHByZXNzaW9uU3RhdGVtZW50KHN0bXQpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCF0cy5pc0NhbGxFeHByZXNzaW9uKHN0bXQuZXhwcmVzc2lvbikpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBjYWxsRXhwciA9IHN0bXQuZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCF0cy5pc0lkZW50aWZpZXIoY2FsbEV4cHIuZXhwcmVzc2lvbikgfHwgY2FsbEV4cHIuZXhwcmVzc2lvbi50ZXh0ICE9PSAncmVxdWlyZScpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbEV4cHIuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIHN0bXQ7XG4gICAgICAgIGNvbnN0IGFyZyA9IGNhbGxFeHByLmFyZ3VtZW50c1swXTtcbiAgICAgICAgaWYgKCF0cy5pc1N0cmluZ0xpdGVyYWwoYXJnKSB8fCBhcmcudGV4dCAhPT0gJ3RzbGliJykgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0cy5zZXRPcmlnaW5hbE5vZGUoXG4gICAgICAgICAgICB0cy5zZXRUZXh0UmFuZ2UodHMuY3JlYXRlU3RhdGVtZW50KGNyZWF0ZUdvb2dDYWxsKCdyZXF1aXJlJywgYXJnKSksIHN0bXQpLCBzdG10KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXdyaXRlcyBjb2RlIGdlbmVyYXRlZCBieSBgZXhwb3J0ICogYXMgbnMgZnJvbSAnbnMnYCB0byBzb21ldGhpbmcgbGlrZTpcbiAgICAgICAqXG4gICAgICAgKiBgYGBcbiAgICAgICAqIGNvbnN0IHRzaWNrbGVfbW9kdWxlX25fID0gZ29vZy5yZXF1aXJlKCducycpO1xuICAgICAgICogZXhwb3J0cy5ucyA9IHRzaWNrbGVfbW9kdWxlX25fO1xuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogU2VwYXJhdGluZyB0aGUgYGdvb2cucmVxdWlyZWAgYW5kIGBleHBvcnRzLm5zYCBhc3NpZ25tZW50IGlzIHJlcXVpcmVkIGJ5IENsb3N1cmUgdG9cbiAgICAgICAqIGNvcnJlY3RseSBpbmZlciB0aGUgdHlwZSBvZiB0aGUgZXhwb3J0ZWQgbmFtZXNwYWNlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBtYXliZVJld3JpdGVFeHBvcnRTdGFyQXNOcyhzdG10OiB0cy5TdGF0ZW1lbnQpOiB0cy5TdGF0ZW1lbnRbXXxudWxsIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoaXMgbG9va3Mgc29tZXRoaW5nIGxpa2UgYGV4cG9ydHMubnMgPSByZXF1aXJlKCducyk7YC5cbiAgICAgICAgaWYgKCF0cy5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoc3RtdCkpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIXRzLmlzQmluYXJ5RXhwcmVzc2lvbihzdG10LmV4cHJlc3Npb24pKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHN0bXQuZXhwcmVzc2lvbi5vcGVyYXRvclRva2VuLmtpbmQgIT09IHRzLlN5bnRheEtpbmQuRXF1YWxzVG9rZW4pIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgbGVmdCBzaWRlIG9mIHRoZSBleHByZXNzaW9uIGlzIGFuIGFjY2VzcyBvbiBgZXhwb3J0c2AuXG4gICAgICAgIGlmICghdHMuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24oc3RtdC5leHByZXNzaW9uLmxlZnQpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCF0cy5pc0lkZW50aWZpZXIoc3RtdC5leHByZXNzaW9uLmxlZnQuZXhwcmVzc2lvbikpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoc3RtdC5leHByZXNzaW9uLmxlZnQuZXhwcmVzc2lvbi5lc2NhcGVkVGV4dCAhPT0gJ2V4cG9ydHMnKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBHcmFiIHRoZSBjYWxsIHRvIGByZXF1aXJlYCwgYW5kIGV4aXQgZWFybHkgaWYgbm90IGNhbGxpbmcgYHJlcXVpcmVgLlxuICAgICAgICBpZiAoIXRzLmlzQ2FsbEV4cHJlc3Npb24oc3RtdC5leHByZXNzaW9uLnJpZ2h0KSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGlkZW50ID0gdHMuY3JlYXRlSWRlbnRpZmllcihuZXh0TW9kdWxlVmFyKCkpO1xuICAgICAgICBjb25zdCByZXF1aXJlID0gbWF5YmVDcmVhdGVHb29nUmVxdWlyZShzdG10LCBzdG10LmV4cHJlc3Npb24ucmlnaHQsIGlkZW50KTtcbiAgICAgICAgaWYgKCFyZXF1aXJlKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBleHBvcnRlZE5hbWUgPSBzdG10LmV4cHJlc3Npb24ubGVmdC5uYW1lO1xuICAgICAgICBjb25zdCBleHBvcnRTdG10ID0gdHMuc2V0T3JpZ2luYWxOb2RlKFxuICAgICAgICAgICAgdHMuc2V0VGV4dFJhbmdlKFxuICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUV4cHJlc3Npb25TdGF0ZW1lbnQodHMuY3JlYXRlQXNzaWdubWVudChcbiAgICAgICAgICAgICAgICAgICAgdHMuY3JlYXRlUHJvcGVydHlBY2Nlc3ModHMuY3JlYXRlSWRlbnRpZmllcignZXhwb3J0cycpLCBleHBvcnRlZE5hbWUpLCBpZGVudCkpLFxuICAgICAgICAgICAgICAgIHN0bXQpLFxuICAgICAgICAgICAgc3RtdCk7XG5cbiAgICAgICAgcmV0dXJuIFtyZXF1aXJlLCBleHBvcnRTdG10XTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHJlLWV4cG9ydGluZyBhbiBleHBvcnQgZnJvbSBhbm90aGVyIG1vZHVsZSBUeXBlU2NyaXB0IHdpbGwgd3JhcCBpdFxuICAgICAgICogd2l0aCBhbiBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBhbmQgZ2V0dGVyIGZ1bmN0aW9uIHRvIGVtdWxhdGUgYSBsaXZlXG4gICAgICAgKiBiaW5kaW5nLCBwZXIgdGhlIEVTTSBzcGVjLiBnb29nLm1vZHVsZSBkb2Vzbid0IGFsbG93IGZvciBtdXRhYmxlXG4gICAgICAgKiBleHBvcnRzIGFuZCBDbG9zdXJlIENvbXBpbGVyIGRvZXNuJ3QgYWxsb3cgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgdG9cbiAgICAgICAqIGJlIHVzZWQgd2l0aCBgZXhwb3J0c2AsIHNvIHdlIHJld3JpdGUgdGhlIGxpdmUgYmluZGluZyB0byBsb29rIGxpa2UgYVxuICAgICAgICogcGxhaW4gYGV4cG9ydHNgIGFzc2lnbm1lbnQuIEZvciBleGFtcGxlLCB0aGlzIHN0YXRlbWVudDpcbiAgICAgICAqXG4gICAgICAgKiBgYGBcbiAgICAgICAqIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFcIiwge1xuICAgICAgICogICBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFfMS5hOyB9XG4gICAgICAgKiB9KTtcbiAgICAgICAqIGBgYFxuICAgICAgICpcbiAgICAgICAqIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50bzpcbiAgICAgICAqXG4gICAgICAgKiBgYGBcbiAgICAgICAqIGV4cG9ydHMuYSA9IGFfMS5hO1xuICAgICAgICogYGBgXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJld3JpdGVPYmplY3REZWZpbmVQcm9wZXJ0eU9uRXhwb3J0cyhcbiAgICAgICAgICBzdG10OiB0cy5FeHByZXNzaW9uU3RhdGVtZW50KTogdHMuU3RhdGVtZW50fG51bGwge1xuICAgICAgICAvLyBWZXJpZnkgdGhpcyBub2RlIGlzIGEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgaWYgKCF0cy5pc0NhbGxFeHByZXNzaW9uKHN0bXQuZXhwcmVzc2lvbikpIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIFZlcmlmeSB0aGUgbm9kZSBiZWluZyBjYWxsZWQgbG9va3MgbGlrZSBgYS5iYC5cbiAgICAgICAgY29uc3QgY2FsbEV4cHIgPSBzdG10LmV4cHJlc3Npb247XG4gICAgICAgIGlmICghdHMuaXNQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24oY2FsbEV4cHIuZXhwcmVzc2lvbikpIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBgYS5iYC1pc2ggdGhpbmcgaXMgYWN0dWxseSBgT2JqZWN0LmRlZmluZVByb3BlcnR5YC5cbiAgICAgICAgY29uc3QgcHJvcEFjY2VzcyA9IGNhbGxFeHByLmV4cHJlc3Npb247XG4gICAgICAgIGlmICghdHMuaXNJZGVudGlmaWVyKHByb3BBY2Nlc3MuZXhwcmVzc2lvbikpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAocHJvcEFjY2Vzcy5leHByZXNzaW9uLnRleHQgIT09ICdPYmplY3QnKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHByb3BBY2Nlc3MubmFtZS50ZXh0ICE9PSAnZGVmaW5lUHJvcGVydHknKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBHcmFiIGVhY2ggYXJndW1lbnQgdG8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAsIGFuZCB2ZXJpZnkgdGhhdCB0aGVyZVxuICAgICAgICAvLyBhcmUgZXhhY3RseSB0aHJlZSBhcmd1bWVudHMuIFRoZSBmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGdsb2JhbFxuICAgICAgICAvLyBgZXhwb3J0c2Agb2JqZWN0LCB0aGUgc2Vjb25kIGlzIHRoZSBleHBvcnRlZCBuYW1lIGFzIGEgc3RyaW5nXG4gICAgICAgIC8vIGxpdGVyYWwsIGFuZCB0aGUgdGhpcmQgaXMgYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgICAgaWYgKGNhbGxFeHByLmFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBbb2JqRGVmQXJnMSwgb2JqRGVmQXJnMiwgb2JqRGVmQXJnM10gPSBjYWxsRXhwci5hcmd1bWVudHM7XG4gICAgICAgIGlmICghdHMuaXNJZGVudGlmaWVyKG9iakRlZkFyZzEpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG9iakRlZkFyZzEudGV4dCAhPT0gJ2V4cG9ydHMnKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCF0cy5pc1N0cmluZ0xpdGVyYWwob2JqRGVmQXJnMikpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIXRzLmlzT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24ob2JqRGVmQXJnMykpIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIFJldHVybnMgYSBcImZpbmRlclwiIGZ1bmN0aW9uIHRvIGxvY2F0aW9uIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAgICAgICAgZnVuY3Rpb24gZmluZFByb3BOYW1lZChuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gKHA6IHRzLk9iamVjdExpdGVyYWxFbGVtZW50TGlrZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRzLmlzUHJvcGVydHlBc3NpZ25tZW50KHApICYmIHRzLmlzSWRlbnRpZmllcihwLm5hbWUpICYmXG4gICAgICAgICAgICAgICAgcC5uYW1lLnRleHQgPT09IG5hbWU7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBleHBvcnQgaXMgbWFya2VkIGFzIGVudW1lcmFibGUuIElmIGl0IGlzbid0IHRoZW4gdGhpc1xuICAgICAgICAvLyB3YXMgbm90IGdlbmVyYXRlZCBieSBUeXBlU2NyaXB0LlxuICAgICAgICBjb25zdCBlbnVtZXJhYmxlQ29uZmlnID1cbiAgICAgICAgICAgIG9iakRlZkFyZzMucHJvcGVydGllcy5maW5kKGZpbmRQcm9wTmFtZWQoJ2VudW1lcmFibGUnKSk7XG4gICAgICAgIGlmICghZW51bWVyYWJsZUNvbmZpZykgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghdHMuaXNQcm9wZXJ0eUFzc2lnbm1lbnQoZW51bWVyYWJsZUNvbmZpZykpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZW51bWVyYWJsZUNvbmZpZy5pbml0aWFsaXplci5raW5kICE9PSB0cy5TeW50YXhLaW5kLlRydWVLZXl3b3JkKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgZXhwb3J0IGhhcyBhIGdldHRlciBmdW5jdGlvbi5cbiAgICAgICAgY29uc3QgZ2V0Q29uZmlnID0gb2JqRGVmQXJnMy5wcm9wZXJ0aWVzLmZpbmQoZmluZFByb3BOYW1lZCgnZ2V0JykpO1xuICAgICAgICBpZiAoIWdldENvbmZpZykgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghdHMuaXNQcm9wZXJ0eUFzc2lnbm1lbnQoZ2V0Q29uZmlnKSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghdHMuaXNGdW5jdGlvbkV4cHJlc3Npb24oZ2V0Q29uZmlnLmluaXRpYWxpemVyKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGdldHRlciBmdW5jdGlvbiBoYXMgZXhhY3RseSBvbmUgc3RhdGVtZW50IHRoYXQgaXMgYVxuICAgICAgICAvLyByZXR1cm4gc3RhdGVtZW50LiBUaGUgbm9kZSBiZWluZyByZXR1cm5lZCBpcyB0aGUgcmVhbCBleHBvcnRlZCB2YWx1ZS5cbiAgICAgICAgY29uc3QgZ2V0dGVyRnVuYyA9IGdldENvbmZpZy5pbml0aWFsaXplcjtcbiAgICAgICAgaWYgKGdldHRlckZ1bmMuYm9keS5zdGF0ZW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGdldHRlclJldHVybiA9IGdldHRlckZ1bmMuYm9keS5zdGF0ZW1lbnRzWzBdO1xuICAgICAgICBpZiAoIXRzLmlzUmV0dXJuU3RhdGVtZW50KGdldHRlclJldHVybikpIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCByZWFsRXhwb3J0VmFsdWUgPSBnZXR0ZXJSZXR1cm4uZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFyZWFsRXhwb3J0VmFsdWUpIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBleHBvcnQgc3RhdGVtZW50IHVzaW5nIHRoZSBleHBvcnRlZCBuYW1lIGZvdW5kIGFzIHRoZVxuICAgICAgICAvLyBzZWNvbmQgYXJndW1lbnQgdG8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgd2l0aCB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgIC8vIG5vZGUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbi5cbiAgICAgICAgY29uc3QgZXhwb3J0U3RtdCA9IHRzLnNldE9yaWdpbmFsTm9kZShcbiAgICAgICAgICAgIHRzLnNldFRleHRSYW5nZShcbiAgICAgICAgICAgICAgICB0cy5jcmVhdGVFeHByZXNzaW9uU3RhdGVtZW50KHRzLmNyZWF0ZUFzc2lnbm1lbnQoXG4gICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignZXhwb3J0cycpLCBvYmpEZWZBcmcyLnRleHQpLFxuICAgICAgICAgICAgICAgICAgICByZWFsRXhwb3J0VmFsdWUpKSxcbiAgICAgICAgICAgICAgICBzdG10KSxcbiAgICAgICAgICAgIHN0bXQpO1xuXG4gICAgICAgIHJldHVybiBleHBvcnRTdG10O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHZpc2l0VG9wTGV2ZWxTdGF0ZW1lbnQgaW1wbGVtZW50cyB0aGUgbWFpbiBDb21tb25KUyB0byBnb29nLm1vZHVsZSBjb252ZXJzaW9uLiBJdCB2aXNpdHMgYVxuICAgICAgICogU291cmNlRmlsZSBsZXZlbCBzdGF0ZW1lbnQgYW5kIGFkZHMgYSAocG9zc2libHkpIHRyYW5zZm9ybWVkIHJlcHJlc2VudGF0aW9uIG9mIGl0IGludG9cbiAgICAgICAqIHN0YXRlbWVudHMuIEl0IGFkZHMgYXQgbGVhc3Qgb25lIG5vZGUgcGVyIHN0YXRlbWVudCB0byBzdGF0ZW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIHZpc2l0VG9wTGV2ZWxTdGF0ZW1lbnQ6XG4gICAgICAgKiAtIGNvbnZlcnRzIHJlcXVpcmUoKSBjYWxscyB0byBnb29nLnJlcXVpcmUoKSBjYWxscywgd2l0aCBvciB3L28gdmFyIGFzc2lnbm1lbnRcbiAgICAgICAqIC0gcmVtb3ZlcyBcInVzZSBzdHJpY3RcIjsgYW5kIFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fZXNNb2R1bGUpXCIgc3RhdGVtZW50c1xuICAgICAgICogLSBjb252ZXJ0cyBtb2R1bGUuZXhwb3J0cyBhc3NpZ25tZW50cyB0byBqdXN0IGV4cG9ydHMgYXNzaWdubWVudHNcbiAgICAgICAqIC0gc3BsaXRzIF9fZXhwb3J0U3RhcigpIGNhbGxzIGludG8gcmVxdWlyZSBhbmQgZXhwb3J0ICh0aGlzIG5lZWRzIHR3byBzdGF0ZW1lbnRzKVxuICAgICAgICogLSBtYWtlcyBzdXJlIHRvIG9ubHkgaW1wb3J0IGVhY2ggbmFtZXNwYWNlIGV4YWN0bHkgb25jZSwgYW5kIHVzZSB2YXJpYWJsZXMgbGF0ZXIgb25cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gdmlzaXRUb3BMZXZlbFN0YXRlbWVudChcbiAgICAgICAgICBzdGF0ZW1lbnRzOiB0cy5TdGF0ZW1lbnRbXSwgc2Y6IHRzLlNvdXJjZUZpbGUsIG5vZGU6IHRzLlN0YXRlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBIYW5kbGUgZWFjaCBwYXJ0aWN1bGFyIGNhc2UgYnkgYWRkaW5nIG5vZGUgdG8gc3RhdGVtZW50cywgdGhlbiByZXR1cm4uXG4gICAgICAgIC8vIEZvciB1bmhhbmRsZWQgY2FzZXMsIGJyZWFrIHRvIGp1bXAgdG8gdGhlIGRlZmF1bHQgaGFuZGxpbmcgYmVsb3cuXG5cbiAgICAgICAgLy8gSW4gSlMgdHJhbnNwaWxhdGlvbiBtb2RlLCBhbHdheXMgcmV3cml0ZSBgcmVxdWlyZSgndHNsaWInKWAgdG9cbiAgICAgICAgLy8gZ29vZy5yZXF1aXJlKCd0c2xpYicpLCBpZ25vcmluZyBub3JtYWwgbW9kdWxlIHJlc29sdXRpb24uXG4gICAgICAgIGlmIChob3N0LmlzSnNUcmFuc3BpbGF0aW9uKSB7XG4gICAgICAgICAgY29uc3QgcmV3cml0dGVuVHNMaWIgPSBtYXliZVJld3JpdGVSZXF1aXJlVHNsaWIobm9kZSk7XG4gICAgICAgICAgaWYgKHJld3JpdHRlblRzTGliKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmV3cml0dGVuVHNMaWIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkV4cHJlc3Npb25TdGF0ZW1lbnQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJTdG10ID0gbm9kZSBhcyB0cy5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIFwidXNlIHN0cmljdFwiIGFuZCBjZXJ0YWluIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhbmQgc2tpcCBpdCBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoaXNVc2VTdHJpY3QoZXhwclN0bXQpIHx8IGlzRXNNb2R1bGVQcm9wZXJ0eShleHByU3RtdCkpIHtcbiAgICAgICAgICAgICAgc3RtdHMucHVzaChjcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50V2l0aENvbW1lbnRzKHNmLCBleHByU3RtdCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbm90IGFscmVhZHkgc2VlbiB0aGUgZGVmYXVsdGVkIGV4cG9ydCBhc3NpZ25tZW50IFxuICAgICAgICAgICAgLy8gaW5pdGlhbGl6aW5nIGFsbCBleHBvcnRzIHRvIGB2b2lkIDBgLCBza2lwIHRoZSBzdGF0ZW1lbnQgYW5kIG1hcmtcbiAgICAgICAgICAgIC8vIHRoYXQgd2UgaGF2ZSBoYXZlIG5vdyBzZWVuIGl0LlxuICAgICAgICAgICAgaWYgKCFkaWRSZXdyaXRlRGVmYXVsdEV4cG9ydHNBc3NpZ25tZW50ICYmXG4gICAgICAgICAgICAgIGNoZWNrRXhwb3J0c1ZvaWQwQXNzaWdubWVudChleHByU3RtdC5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICBkaWRSZXdyaXRlRGVmYXVsdEV4cG9ydHNBc3NpZ25tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc3RtdHMucHVzaChjcmVhdGVOb3RFbWl0dGVkU3RhdGVtZW50V2l0aENvbW1lbnRzKHNmLCBleHByU3RtdCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvcjpcbiAgICAgICAgICAgIC8vICAgbW9kdWxlLmV4cG9ydHMgPSAuLi47XG4gICAgICAgICAgICBjb25zdCBtb2RFeHBvcnRzID0gcmV3cml0ZU1vZHVsZUV4cG9ydHNBc3NpZ25tZW50KGV4cHJTdG10KTtcbiAgICAgICAgICAgIGlmIChtb2RFeHBvcnRzKSB7XG4gICAgICAgICAgICAgIHN0bXRzLnB1c2gobW9kRXhwb3J0cyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB1c2Ugb2YgdGhlIGNvbW1hIG9wZXJhdG9yLlxuICAgICAgICAgICAgLy8gVGhpcyBvY2N1cnMgaW4gY29kZSBsaWtlXG4gICAgICAgICAgICAvLyAgIGV4cG9ydHMuYSA9IC4uLiwgZXhwb3J0cy5iID0gLi4uO1xuICAgICAgICAgICAgLy8gd2hpY2ggd2Ugd2FudCB0byBjaGFuZ2UgaW50byBtdWx0aXBsZSBzdGF0ZW1lbnRzLlxuICAgICAgICAgICAgY29uc3QgY29tbWFFeHBhbmRlZCA9IHJld3JpdGVDb21tYUV4cHJlc3Npb25zKGV4cHJTdG10LmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKGNvbW1hRXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgc3RtdHMucHVzaCguLi5jb21tYUV4cGFuZGVkKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yOlxuICAgICAgICAgICAgLy8gICBleHBvcnRzLm5zID0gcmVxdWlyZSgnLi4uJyk7XG4gICAgICAgICAgICAvLyB3aGljaCBpcyBnZW5lcmF0ZWQgYnkgdGhlIGBleHBvcnQgKiBhcyBucyBmcm9tYCBzeW50YXguXG4gICAgICAgICAgICBjb25zdCBleHBvcnRTdGFyQXNOcyA9IG1heWJlUmV3cml0ZUV4cG9ydFN0YXJBc05zKGV4cHJTdG10KTtcbiAgICAgICAgICAgIGlmIChleHBvcnRTdGFyQXNOcykge1xuICAgICAgICAgICAgICBzdG10cy5wdXNoKC4uLmV4cG9ydFN0YXJBc05zKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVja3MgZm9yOlxuICAgICAgICAgICAgLy8gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2EnLCB7XG4gICAgICAgICAgICAvLyAgICAgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiB7IHJldHVybiAuLi47IH1cbiAgICAgICAgICAgIC8vICAgfSlcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgbGl2ZSBiaW5kaW5nIGdlbmVyYXRlZCB3aGVuIHJlLWV4cG9ydGluZyBmcm9tIGFub3RoZXJcbiAgICAgICAgICAgIC8vIG1vZHVsZS5cbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydEZyb21PYmpEZWZQcm9wID1cbiAgICAgICAgICAgICAgICByZXdyaXRlT2JqZWN0RGVmaW5lUHJvcGVydHlPbkV4cG9ydHMoZXhwclN0bXQpO1xuICAgICAgICAgICAgaWYgKGV4cG9ydEZyb21PYmpEZWZQcm9wKSB7XG4gICAgICAgICAgICAgIHN0bXRzLnB1c2goZXhwb3J0RnJvbU9iakRlZlByb3ApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSByZXN0IG9mIHRoaXMgYmxvY2sgaGFuZGxlcyBvbmx5IHNvbWUgZnVuY3Rpb24gY2FsbCBmb3JtczpcbiAgICAgICAgICAgIC8vICAgZ29vZy5kZWNsYXJlTW9kdWxlSWQoLi4uKTtcbiAgICAgICAgICAgIC8vICAgcmVxdWlyZSgnZm9vJyk7XG4gICAgICAgICAgICAvLyAgIF9fZXhwb3J0U3RhcihyZXF1aXJlKCdmb28nKSwgLi4uKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBleHByU3RtdC5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKCF0cy5pc0NhbGxFeHByZXNzaW9uKGV4cHIpKSBicmVhaztcbiAgICAgICAgICAgIGxldCBjYWxsRXhwciA9IGV4cHI7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkZWNsYXJlTW9kdWxlSWQuXG4gICAgICAgICAgICBjb25zdCBkZWNsYXJlZE1vZHVsZUlkID0gbWF5YmVSZXdyaXRlRGVjbGFyZU1vZHVsZUlkKGV4cHJTdG10LCBjYWxsRXhwcik7XG4gICAgICAgICAgICBpZiAoZGVjbGFyZWRNb2R1bGVJZCkge1xuICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goZGVjbGFyZWRNb2R1bGVJZCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIF9fZXhwb3J0U3RhciwgdGhlIGNvbW1vbmpzIHZlcnNpb24gb2YgJ2V4cG9ydCAqJy5cbiAgICAgICAgICAgIC8vIGV4cG9ydCAqIGNyZWF0ZXMgZWl0aGVyIGEgcHVyZSB0b3AtbGV2ZWwgJ19fZXhwb3J0KHJlcXVpcmUoLi4uKSknXG4gICAgICAgICAgICAvLyBvciB0aGUgaW1wb3J0ZWQgdmVyc2lvbiwgJ3RzbGliLl9fZXhwb3J0U3RhcihyZXF1aXJlKC4uLikpJy4gVGhlXG4gICAgICAgICAgICAvLyBpbXBvcnRlZCB2ZXJzaW9uIGlzIG9ubHkgc3Vic3RpdHV0ZWQgbGF0ZXIgb24gdGhvdWdoLCBzbyBhcHBlYXJzXG4gICAgICAgICAgICAvLyBhcyBhIHBsYWluIFwiX19leHBvcnRTdGFyXCIgb24gdGhlIHRvcCBsZXZlbCBoZXJlLlxuICAgICAgICAgICAgY29uc3QgaXNFeHBvcnRTdGFyID0gdHMuaXNJZGVudGlmaWVyKGV4cHIuZXhwcmVzc2lvbikgJiZcbiAgICAgICAgICAgICAgICAoZXhwci5leHByZXNzaW9uLnRleHQgPT09ICdfX2V4cG9ydFN0YXInIHx8XG4gICAgICAgICAgICAgICAgIGV4cHIuZXhwcmVzc2lvbi50ZXh0ID09PSAnX19leHBvcnQnKTtcbiAgICAgICAgICAgIGxldCBuZXdJZGVudDogdHMuSWRlbnRpZmllcnx1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXNFeHBvcnRTdGFyKSB7XG4gICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGdvb2cucmVxdWlyZSgpIGZyb20gdGhlIGNhbGwuIChJdCB3aWxsIGJlIHZlcmlmaWVkXG4gICAgICAgICAgICAgIC8vIGFzIGEgZ29vZy5yZXF1aXJlKCkgYmVsb3cuKVxuICAgICAgICAgICAgICBjYWxsRXhwciA9IGV4cHIuYXJndW1lbnRzWzBdIGFzIHRzLkNhbGxFeHByZXNzaW9uO1xuICAgICAgICAgICAgICBuZXdJZGVudCA9IHRzLmNyZWF0ZUlkZW50aWZpZXIobmV4dE1vZHVsZVZhcigpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgY2FsbCBpcyBhY3R1YWxseSBhIHJlcXVpcmUoKSBhbmQgdHJhbnNsYXRlXG4gICAgICAgICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmUgPVxuICAgICAgICAgICAgICAgIG1heWJlQ3JlYXRlR29vZ1JlcXVpcmUoZXhwclN0bXQsIGNhbGxFeHByLCBuZXdJZGVudCk7XG4gICAgICAgICAgICBpZiAoIXJlcXVpcmUpIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHJlcXVpcmUpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhbiBleHBvcnQgc3Rhciwgc3BsaXQgaXQgdXAgaW50byB0aGUgaW1wb3J0IChjcmVhdGVkXG4gICAgICAgICAgICAvLyBieSB0aGUgbWF5YmUgY2FsbCBhYm92ZSksIGFuZCB0aGUgZXhwb3J0IG9wZXJhdGlvbi4gVGhpcyBhdm9pZHMgYVxuICAgICAgICAgICAgLy8gQ2xvc3VyZSBjb21wbGFpbnQgYWJvdXQgbm9uLXRvcC1sZXZlbCByZXF1aXJlcy5cbiAgICAgICAgICAgIGlmIChpc0V4cG9ydFN0YXIpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXJnczogdHMuRXhwcmVzc2lvbltdID0gW25ld0lkZW50IV07XG4gICAgICAgICAgICAgIGlmIChleHByLmFyZ3VtZW50cy5sZW5ndGggPiAxKSBhcmdzLnB1c2goZXhwci5hcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2godHMuY3JlYXRlU3RhdGVtZW50KFxuICAgICAgICAgICAgICAgICAgdHMuY3JlYXRlQ2FsbChleHByLmV4cHJlc3Npb24sIHVuZGVmaW5lZCwgYXJncykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlZhcmlhYmxlU3RhdGVtZW50OiB7XG4gICAgICAgICAgICAvLyBJdCdzIHBvc3NpYmx5IG9mIHRoZSBmb3JtIFwidmFyIHggPSByZXF1aXJlKC4uLik7XCIuXG4gICAgICAgICAgICBjb25zdCB2YXJTdG10ID0gbm9kZSBhcyB0cy5WYXJpYWJsZVN0YXRlbWVudDtcbiAgICAgICAgICAgIC8vIFZlcmlmeSBpdCdzIGEgc2luZ2xlIGRlY2wgKGFuZCBub3QgXCJ2YXIgeCA9IC4uLiwgeSA9IC4uLjtcIikuXG4gICAgICAgICAgICBpZiAodmFyU3RtdC5kZWNsYXJhdGlvbkxpc3QuZGVjbGFyYXRpb25zLmxlbmd0aCAhPT0gMSkgYnJlYWs7XG4gICAgICAgICAgICBjb25zdCBkZWNsID0gdmFyU3RtdC5kZWNsYXJhdGlvbkxpc3QuZGVjbGFyYXRpb25zWzBdO1xuXG4gICAgICAgICAgICAvLyBHcmFiIHRoZSB2YXJpYWJsZSBuYW1lIChhdm9pZGluZyB0aGluZ3MgbGlrZSBkZXN0cnVjdHVyaW5nIGJpbmRzKS5cbiAgICAgICAgICAgIGlmIChkZWNsLm5hbWUua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSBicmVhaztcbiAgICAgICAgICAgIGlmICghZGVjbC5pbml0aWFsaXplciB8fCAhdHMuaXNDYWxsRXhwcmVzc2lvbihkZWNsLmluaXRpYWxpemVyKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmUgPSBtYXliZUNyZWF0ZUdvb2dSZXF1aXJlKHZhclN0bXQsIGRlY2wuaW5pdGlhbGl6ZXIsIGRlY2wubmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlcXVpcmUpIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHJlcXVpcmUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb2R1bGVOYW1lID0gaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKCcnLCBzZi5maWxlTmFtZSk7XG4gICAgICAvLyBSZWdpc3RlciB0aGUgbmFtZXNwYWNlIHRoaXMgZmlsZSBwcm92aWRlcy5cbiAgICAgIG1vZHVsZXNNYW5pZmVzdC5hZGRNb2R1bGUoc2YuZmlsZU5hbWUsIG1vZHVsZU5hbWUpO1xuXG4gICAgICAvLyBDb252ZXJ0IGVhY2ggdG9wIGxldmVsIHN0YXRlbWVudCB0byBnb29nLm1vZHVsZS5cbiAgICAgIGNvbnN0IHN0bXRzOiB0cy5TdGF0ZW1lbnRbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzdG10IG9mIHNmLnN0YXRlbWVudHMpIHtcbiAgICAgICAgdmlzaXRUb3BMZXZlbFN0YXRlbWVudChzdG10cywgc2YsIHN0bXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGRpdGlvbmFsIHN0YXRlbWVudHMgdGhhdCB3aWxsIGJlIHByZXBlbmRlZCAoZ29vZy5tb2R1bGUgY2FsbCBldGMpLlxuICAgICAgY29uc3QgaGVhZGVyU3RtdHM6IHRzLlN0YXRlbWVudFtdID0gW107XG5cbiAgICAgIC8vIEVtaXQ6IGdvb2cubW9kdWxlKCdtb2R1bGVOYW1lJyk7XG4gICAgICBjb25zdCBnb29nTW9kdWxlID1cbiAgICAgICAgICB0cy5jcmVhdGVTdGF0ZW1lbnQoY3JlYXRlR29vZ0NhbGwoJ21vZHVsZScsIGNyZWF0ZVNpbmdsZVF1b3RlU3RyaW5nTGl0ZXJhbChtb2R1bGVOYW1lKSkpO1xuICAgICAgaGVhZGVyU3RtdHMucHVzaChnb29nTW9kdWxlKTtcblxuICAgICAgLy8gQWxsb3cgY29kZSB0byB1c2UgYG1vZHVsZS5pZGAgdG8gZGlzY292ZXIgaXRzIG1vZHVsZSBVUkwsIGUuZy4gdG8gcmVzb2x2ZSBhIHRlbXBsYXRlIFVSTFxuICAgICAgLy8gYWdhaW5zdC4gVXNlcyAndmFyJywgYXMgdGhpcyBjb2RlIGlzIGluc2VydGVkIGluIEVTNiBhbmQgRVM1IG1vZGVzLiBUaGUgZm9sbG93aW5nIHBhdHRlcm5cbiAgICAgIC8vIGVuc3VyZXMgY2xvc3VyZSBkb2Vzbid0IHRocm93IGFuIGVycm9yIGluIGFkdmFuY2VkIG9wdGltaXphdGlvbnMgbW9kZS5cbiAgICAgIC8vIHZhciBtb2R1bGUgPSBtb2R1bGUgfHwge2lkOiAncGF0aC90by9tb2R1bGUudHMnfTtcbiAgICAgIGNvbnN0IG1vZHVsZUlkID0gaG9zdC5maWxlTmFtZVRvTW9kdWxlSWQoc2YuZmlsZU5hbWUpO1xuICAgICAgY29uc3QgbW9kdWxlVmFySW5pdGlhbGl6ZXIgPSB0cy5jcmVhdGVCaW5hcnkoXG4gICAgICAgICAgdHMuY3JlYXRlSWRlbnRpZmllcignbW9kdWxlJyksIHRzLlN5bnRheEtpbmQuQmFyQmFyVG9rZW4sXG4gICAgICAgICAgdHMuY3JlYXRlT2JqZWN0TGl0ZXJhbChcbiAgICAgICAgICAgICAgW3RzLmNyZWF0ZVByb3BlcnR5QXNzaWdubWVudCgnaWQnLCBjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwobW9kdWxlSWQpKV0pKTtcbiAgICAgIGNvbnN0IG1vZEFzc2lnbiA9IHRzLmNyZWF0ZVZhcmlhYmxlU3RhdGVtZW50KFxuICAgICAgICAgIC8qIG1vZGlmaWVycyAqLyB1bmRlZmluZWQsIHRzLmNyZWF0ZVZhcmlhYmxlRGVjbGFyYXRpb25MaXN0KFt0cy5jcmVhdGVWYXJpYWJsZURlY2xhcmF0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbW9kdWxlJywgLyogdHlwZSAqLyB1bmRlZmluZWQsIG1vZHVsZVZhckluaXRpYWxpemVyKV0pKTtcbiAgICAgIGhlYWRlclN0bXRzLnB1c2gobW9kQXNzaWduKTtcblxuICAgICAgLy8gQWRkIGBnb29nLnJlcXVpcmUoJ3RzbGliJyk7YCBpZiBub3QgSlMgdHJhbnNwaWxhdGlvbiwgYW5kIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVxdWlyZWQuXG4gICAgICAvLyBSYXRpb25hbGU6XG4gICAgICAvLyBUUyBnZXRzIGNvbXBpbGVkIHRvIERldmVsb3BtZW50IG1vZGUgKEVTNSkgYW5kIENsb3N1cmUgbW9kZSAofkVTNilcbiAgICAgIC8vIHNvdXJjZXMuIFRvb2xpbmcgZ2VuZXJhdGVzIG1vZHVsZSBtYW5pZmVzdHMgZnJvbSB0aGUgQ2xvc3VyZSB2ZXJzaW9uLlxuICAgICAgLy8gVGhlc2UgbWFuaWZlc3RzIGFyZSB1c2VkIGJvdGggd2l0aCB0aGUgQ2xvc3VyZSB2ZXJzaW9uIGFuZCB0aGVcbiAgICAgIC8vIERldmVsb3BtZW50IG1vZGUgdmVyc2lvbi4gJ3RzbGliJyBpcyBzb21ldGltZXMgcmVxdWlyZWQgYnkgdGhlXG4gICAgICAvLyBkZXZlbG9wbWVudCB2ZXJzaW9uIGJ1dCBub3QgdGhlIENsb3N1cmUgdmVyc2lvbi4gSW5zZXJ0aW5nIHRoZSBpbXBvcnRcbiAgICAgIC8vIGJlbG93IHVuY29uZGl0aW9uYWxseSBtYWtlcyBzdXJlIHRoYXQgdGhlIG1vZHVsZSBtYW5pZmVzdHMgYXJlXG4gICAgICAvLyBpZGVudGljYWwgYmV0d2VlbiBDbG9zdXJlIGFuZCBEZXZlbG9wbWVudCBtb2RlLCBhdm9pZGluZyBicmVha2FnZXNcbiAgICAgIC8vIGNhdXNlZCBieSBtaXNzaW5nIG1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAgICBpZiAoIWhvc3QuaXNKc1RyYW5zcGlsYXRpb24pIHtcbiAgICAgICAgLy8gR2V0IGEgY29weSBvZiB0aGUgYWxyZWFkeSByZXNvbHZlZCBtb2R1bGUgbmFtZXMgYmVmb3JlIGNhbGxpbmdcbiAgICAgICAgLy8gcmVzb2x2ZU1vZHVsZU5hbWUgb24gJ3RzbGliJy4gT3RoZXJ3aXNlLCByZXNvbHZlTW9kdWxlTmFtZSB3aWxsXG4gICAgICAgIC8vIGFkZCAndHNsaWInIHRvIG5hbWVzcGFjZVRvTW9kdWxlVmFyTmFtZSBhbmQgcHJldmVudCBjaGVja2luZyB3aGV0aGVyXG4gICAgICAgIC8vICd0c2xpYicgaGFzIGFscmVhZHkgYmVlbiByZXF1aXJlZC5cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRNb2R1bGVOYW1lcyA9IFsuLi5uYW1lc3BhY2VUb01vZHVsZVZhck5hbWUua2V5cygpXTtcblxuICAgICAgICBjb25zdCB0c2xpYk1vZHVsZU5hbWUgPVxuICAgICAgICAgICAgaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKHNmLmZpbGVOYW1lLCByZXNvbHZlTW9kdWxlTmFtZShob3N0LCBzZi5maWxlTmFtZSwgJ3RzbGliJykpO1xuXG4gICAgICAgIC8vIE9ubHkgYWRkIHRoZSBleHRyYSByZXF1aXJlIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVxdWlyZWRcbiAgICAgICAgaWYgKHJlc29sdmVkTW9kdWxlTmFtZXMuaW5kZXhPZih0c2xpYk1vZHVsZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHRzbGliSW1wb3J0ID0gdHMuY3JlYXRlRXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICAgICAgY3JlYXRlR29vZ0NhbGwoJ3JlcXVpcmUnLCBjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwodHNsaWJNb2R1bGVOYW1lKSkpO1xuXG4gICAgICAgICAgLy8gUGxhY2UgdGhlIGdvb2cucmVxdWlyZSgndHNsaWInKSBzdGF0ZW1lbnQgcmlnaHQgYWZ0ZXIgdGhlIGdvb2cubW9kdWxlIHN0YXRlbWVudHNcbiAgICAgICAgICBoZWFkZXJTdG10cy5wdXNoKHRzbGliSW1wb3J0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSW5zZXJ0IGdvb2cubW9kdWxlKCkgZXRjIGFmdGVyIGFueSBsZWFkaW5nIGNvbW1lbnRzIGluIHRoZSBzb3VyY2UgZmlsZS4gVGhlIGNvbW1lbnRzIGhhdmVcbiAgICAgIC8vIGJlZW4gY29udmVydGVkIHRvIE5vdEVtaXR0ZWRTdGF0ZW1lbnRzIGJ5IHRyYW5zZm9ybWVyX3V0aWwsIHdoaWNoIHRoaXMgZGVwZW5kcyBvbi5cbiAgICAgIGNvbnN0IGluc2VydGlvbklkeCA9IHN0bXRzLmZpbmRJbmRleChzID0+IHMua2luZCAhPT0gdHMuU3ludGF4S2luZC5Ob3RFbWl0dGVkU3RhdGVtZW50KTtcbiAgICAgIGlmIChpbnNlcnRpb25JZHggPT09IC0xKSB7XG4gICAgICAgIHN0bXRzLnB1c2goLi4uaGVhZGVyU3RtdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RtdHMuc3BsaWNlKGluc2VydGlvbklkeCwgMCwgLi4uaGVhZGVyU3RtdHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHMudXBkYXRlU291cmNlRmlsZU5vZGUoc2YsIHRzLnNldFRleHRSYW5nZSh0cy5jcmVhdGVOb2RlQXJyYXkoc3RtdHMpLCBzZi5zdGF0ZW1lbnRzKSk7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNNb2R1bGUoc291cmNlRmlsZTogdHMuU291cmNlRmlsZSk6IGJvb2xlYW4ge1xuICBpbnRlcmZhY2UgSW50ZXJuYWxTb3VyY2VGaWxlIGV4dGVuZHMgdHMuU291cmNlRmlsZSB7XG4gICAgLy8gQW4gaW50ZXJuYWwgcHJvcGVydHkgdGhhdCB3ZSB1c2UgaGVyZSB0byBjaGVjayB3aGV0aGVyIGEgZmlsZSBpc1xuICAgIC8vIHN5bnRhY3RpY2FsbHkgYSBtb2R1bGUgb3IgYSBzY3JpcHQuXG4gICAgZXh0ZXJuYWxNb2R1bGVJbmRpY2F0b3I/OiB0cy5Ob2RlO1xuICB9XG4gIHJldHVybiBCb29sZWFuKChzb3VyY2VGaWxlIGFzIEludGVybmFsU291cmNlRmlsZSkuZXh0ZXJuYWxNb2R1bGVJbmRpY2F0b3IpO1xufVxuIl19