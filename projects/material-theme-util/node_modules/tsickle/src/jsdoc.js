/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/jsdoc", ["require", "exports", "typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = exports.toString = exports.toStringWithoutStartEnd = exports.toSynthesizedComment = exports.suppressLeadingCommentsRecursively = exports.getLeadingCommentRangesSynthesized = exports.synthesizeLeadingComments = exports.TAGS_CONFLICTING_WITH_TYPE = exports.parseContents = exports.normalizeLineEndings = exports.parse = void 0;
    const ts = require("typescript");
    /**
     * A list of all JSDoc tags allowed by the Closure compiler.
     * All tags other than these are escaped before emitting.
     *
     * Note that some of these tags are also rejected by tsickle when seen in
     * the user-provided source, but also that tsickle itself may generate some of these.
     * This whitelist is just used for controlling the output.
     *
     * The public Closure docs don't list all the tags it allows; this list comes
     * from the compiler source itself.
     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/Annotation.java
     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/ParserConfig.properties
     */
    const JSDOC_TAGS_OUTPUT_WHITELIST = new Set([
        'abstract',
        'argument',
        'author',
        'const',
        'constant',
        'constructor',
        'copyright',
        'define',
        'deprecated',
        'desc',
        'dict',
        'disposes',
        'enhance',
        'enhanceable',
        'enum',
        'export',
        'expose',
        'extends',
        'externs',
        'fileoverview',
        'final',
        'hassoydelcall',
        'hassoydeltemplate',
        'hidden',
        'id',
        'idGenerator',
        'ignore',
        'implements',
        'implicitCast',
        'inheritDoc',
        'interface',
        'jaggerInject',
        'jaggerModule',
        'jaggerProvide',
        'jaggerProvidePromise',
        'lends',
        'license',
        'link',
        'meaning',
        'modifies',
        'modName',
        'mods',
        'ngInject',
        'noalias',
        'nocollapse',
        'nocompile',
        'nosideeffects',
        'override',
        'owner',
        'package',
        'param',
        'pintomodule',
        'polymer',
        'polymerBehavior',
        'preserve',
        'preserveTry',
        'private',
        'protected',
        'public',
        'record',
        'requirecss',
        'requires',
        'return',
        'returns',
        'see',
        'struct',
        'suppress',
        'template',
        'this',
        'throws',
        'type',
        'typedef',
        'unrestricted',
        'version',
        'wizaction',
        'wizmodule',
    ]);
    /**
     * A list of JSDoc @tags that are never allowed in TypeScript source. These are Closure tags that
     * can be expressed in the TypeScript surface syntax. As tsickle's emit will mangle type names,
     * these will cause Closure Compiler issues and should not be used.
     * Note: 'template' is special-cased below; see where this set is queried.
     */
    const JSDOC_TAGS_INPUT_BLACKLIST = new Set([
        'augments', 'class', 'constructs', 'constructor', 'enum', 'extends', 'field',
        'function', 'implements', 'interface', 'lends', 'namespace', 'private', 'protected',
        'public', 'record', 'static', 'template', 'this', 'type', 'typedef',
    ]);
    /**
     * JSDoc \@tags that might include a {type} after them. Specifying a type is forbidden, since it
     * would collide with TypeScript's type information. If a type *is* given, the entire tag will be
     * ignored.
     */
    const JSDOC_TAGS_WITH_TYPES = new Set([
        'const',
        'define',
        'export',
        'param',
        'return',
    ]);
    /**
     * parse parses JSDoc out of a comment string.
     * Returns null if comment is not JSDoc.
     */
    // TODO(martinprobst): representing JSDoc as a list of tags is too simplistic. We need functionality
    // such as merging (below), de-duplicating certain tags (@deprecated), and special treatment for
    // others (e.g. @suppress). We should introduce a proper model class with a more suitable data
    // strucure (e.g. a Map<TagName, Values[]>).
    function parse(comment) {
        // TODO(evanm): this is a pile of hacky regexes for now, because we
        // would rather use the better TypeScript implementation of JSDoc
        // parsing.  https://github.com/Microsoft/TypeScript/issues/7393
        if (comment.kind !== ts.SyntaxKind.MultiLineCommentTrivia)
            return null;
        // comment.text does not include /* and */, so must start with '*' for JSDoc.
        if (comment.text[0] !== '*')
            return null;
        const text = comment.text.substring(1).trim();
        return parseContents(text);
    }
    exports.parse = parse;
    /**
     * Returns the input string with line endings normalized to '\n'.
     */
    function normalizeLineEndings(input) {
        return input.replace(/\r\n/g, '\n');
    }
    exports.normalizeLineEndings = normalizeLineEndings;
    /**
     * parseContents parses JSDoc out of a comment text.
     * Returns null if comment is not JSDoc.
     *
     * @param commentText a comment's text content, i.e. the comment w/o /* and * /.
     */
    function parseContents(commentText) {
        // Make sure we have proper line endings before parsing on Windows.
        commentText = normalizeLineEndings(commentText);
        // Strip all the " * " bits from the front of each line.
        commentText = commentText.replace(/^\s*\*? ?/gm, '');
        const lines = commentText.split('\n');
        const tags = [];
        const warnings = [];
        for (const line of lines) {
            let match = line.match(/^\s*@(\S+) *(.*)/);
            if (match) {
                let [_, tagName, text] = match;
                if (tagName === 'returns') {
                    // A synonym for 'return'.
                    tagName = 'return';
                }
                let type;
                if (JSDOC_TAGS_INPUT_BLACKLIST.has(tagName)) {
                    if (tagName !== 'template') {
                        // Tell the user to not write blacklisted tags, because there is TS
                        // syntax available for them.
                        warnings.push(`@${tagName} annotations are redundant with TypeScript equivalents`);
                        continue; // Drop the tag so Closure won't process it.
                    }
                    else {
                        // But @template in particular is special: it's ok for the user to
                        // write it for documentation purposes, but we don't want the
                        // user-written one making it into the output because Closure interprets
                        // it as well.
                        // Drop it without any warning.  (We also don't ensure its correctness.)
                        continue;
                    }
                }
                else if (JSDOC_TAGS_WITH_TYPES.has(tagName)) {
                    if (text[0] === '{') {
                        warnings.push(`the type annotation on @${tagName} is redundant with its TypeScript type, ` +
                            `remove the {...} part`);
                        continue;
                    }
                }
                else if (tagName === 'suppress') {
                    const typeMatch = text.match(/^\{(.*)\}(.*)$/);
                    if (typeMatch) {
                        [, type, text] = typeMatch;
                    }
                    else {
                        warnings.push(`malformed @${tagName} tag: "${text}"`);
                    }
                }
                else if (tagName === 'dict') {
                    warnings.push('use index signatures (`[k: string]: type`) instead of @dict');
                    continue;
                }
                // Grab the parameter name from @param tags.
                let parameterName;
                if (tagName === 'param') {
                    match = text.match(/^(\S+) ?(.*)/);
                    if (match)
                        [_, parameterName, text] = match;
                }
                const tag = { tagName };
                if (parameterName)
                    tag.parameterName = parameterName;
                if (text)
                    tag.text = text;
                if (type)
                    tag.type = type;
                tags.push(tag);
            }
            else {
                // Text without a preceding @tag on it is either the plain text
                // documentation or a continuation of a previous tag.
                if (tags.length === 0) {
                    tags.push({ tagName: '', text: line });
                }
                else {
                    const lastTag = tags[tags.length - 1];
                    lastTag.text = (lastTag.text || '') + '\n' + line;
                }
            }
        }
        if (warnings.length > 0) {
            return { tags, warnings };
        }
        return { tags };
    }
    exports.parseContents = parseContents;
    /**
     * Serializes a Tag into a string usable in a comment.
     * Returns a string like " @foo {bar} baz" (note the whitespace).
     */
    function tagToString(tag, escapeExtraTags = new Set()) {
        let out = '';
        if (tag.tagName) {
            if (!JSDOC_TAGS_OUTPUT_WHITELIST.has(tag.tagName) || escapeExtraTags.has(tag.tagName)) {
                // Escape tags we don't understand.  This is a subtle
                // compromise between multiple issues.
                // 1) If we pass through these non-Closure tags, the user will
                //    get a warning from Closure, and the point of tsickle is
                //    to insulate the user from Closure.
                // 2) The output of tsickle is for Closure but also may be read
                //    by humans, for example non-TypeScript users of Angular.
                // 3) Finally, we don't want to warn because users should be
                //    free to add whichever JSDoc they feel like.  If the user
                //    wants help ensuring they didn't typo a tag, that is the
                //    responsibility of a linter.
                out += ` \\@${tag.tagName}`;
            }
            else {
                out += ` @${tag.tagName}`;
            }
        }
        if (tag.type) {
            out += ' {';
            if (tag.restParam) {
                out += '...';
            }
            out += tag.type;
            if (tag.optional) {
                out += '=';
            }
            out += '}';
        }
        if (tag.parameterName) {
            out += ' ' + tag.parameterName;
        }
        if (tag.text) {
            out += ' ' + tag.text.replace(/@/g, '\\@');
        }
        return out;
    }
    /** Tags that must only occur onces in a comment (filtered below). */
    const SINGLETON_TAGS = new Set(['deprecated']);
    /** Tags that conflict with \@type in Closure Compiler (e.g. \@param). */
    exports.TAGS_CONFLICTING_WITH_TYPE = new Set(['param', 'return']);
    /**
     * synthesizeLeadingComments parses the leading comments of node, converts them
     * to synthetic comments, and makes sure the original text comments do not get
     * emitted by TypeScript.
     */
    function synthesizeLeadingComments(node) {
        const existing = ts.getSyntheticLeadingComments(node);
        if (existing)
            return existing;
        const text = node.getFullText();
        const synthComments = getLeadingCommentRangesSynthesized(text, node.getFullStart());
        if (synthComments.length) {
            ts.setSyntheticLeadingComments(node, synthComments);
            suppressLeadingCommentsRecursively(node);
        }
        return synthComments;
    }
    exports.synthesizeLeadingComments = synthesizeLeadingComments;
    /**
     * parseLeadingCommentRangesSynthesized parses the leading comment ranges out of the given text and
     * converts them to SynthesizedComments.
     * @param offset the offset of text in the source file, e.g. node.getFullStart().
     */
    // VisibleForTesting
    function getLeadingCommentRangesSynthesized(text, offset = 0) {
        const comments = ts.getLeadingCommentRanges(text, 0) || [];
        return comments.map((cr) => {
            // Confusingly, CommentRange in TypeScript includes start and end markers, but
            // SynthesizedComments do not.
            const commentText = cr.kind === ts.SyntaxKind.SingleLineCommentTrivia ?
                text.substring(cr.pos + 2, cr.end) :
                text.substring(cr.pos + 2, cr.end - 2);
            return Object.assign(Object.assign({}, cr), { text: commentText, pos: -1, end: -1, originalRange: { pos: cr.pos + offset, end: cr.end + offset } });
        });
    }
    exports.getLeadingCommentRangesSynthesized = getLeadingCommentRangesSynthesized;
    /**
     * suppressCommentsRecursively prevents emit of leading comments on node, and any recursive nodes
     * underneath it that start at the same offset.
     */
    function suppressLeadingCommentsRecursively(node) {
        // TypeScript emits leading comments on a node, unless:
        // - the comment was emitted by the parent node
        // - the node has the NoLeadingComments emit flag.
        // However, transformation steps sometimes copy nodes without keeping their emit flags, so just
        // setting NoLeadingComments recursively is not enough, we must also set the text range to avoid
        // the copied node to have comments emitted.
        const originalStart = node.getFullStart();
        const actualStart = node.getStart();
        function suppressCommentsInternal(node) {
            ts.setEmitFlags(node, ts.EmitFlags.NoLeadingComments);
            return !!ts.forEachChild(node, (child) => {
                if (child.pos !== originalStart)
                    return true;
                return suppressCommentsInternal(child);
            });
        }
        suppressCommentsInternal(node);
    }
    exports.suppressLeadingCommentsRecursively = suppressLeadingCommentsRecursively;
    function toSynthesizedComment(tags, escapeExtraTags) {
        return {
            kind: ts.SyntaxKind.MultiLineCommentTrivia,
            text: toStringWithoutStartEnd(tags, escapeExtraTags),
            pos: -1,
            end: -1,
            hasTrailingNewLine: true,
        };
    }
    exports.toSynthesizedComment = toSynthesizedComment;
    /** Serializes a Comment out to a string, but does not include the start and end comment tokens. */
    function toStringWithoutStartEnd(tags, escapeExtraTags = new Set()) {
        return serialize(tags, false, escapeExtraTags);
    }
    exports.toStringWithoutStartEnd = toStringWithoutStartEnd;
    /** Serializes a Comment out to a string usable in source code. */
    function toString(tags, escapeExtraTags = new Set()) {
        return serialize(tags, true, escapeExtraTags);
    }
    exports.toString = toString;
    function serialize(tags, includeStartEnd, escapeExtraTags = new Set()) {
        if (tags.length === 0)
            return '';
        if (tags.length === 1) {
            const tag = tags[0];
            if ((tag.tagName === 'type' || tag.tagName === 'typedef' || tag.tagName === 'nocollapse') &&
                (!tag.text || !tag.text.match('\n'))) {
                // Special-case one-liner "type" and "nocollapse" tags to fit on one line, e.g.
                //   /** @type {foo} */
                const text = tagToString(tag, escapeExtraTags);
                return includeStartEnd ? `/**${text} */` : `*${text} `;
            }
            // Otherwise, fall through to the multi-line output.
        }
        let out = includeStartEnd ? '/**\n' : '*\n';
        const emitted = new Set();
        for (const tag of tags) {
            if (emitted.has(tag.tagName) && SINGLETON_TAGS.has(tag.tagName)) {
                continue;
            }
            emitted.add(tag.tagName);
            out += ' *';
            // If the tagToString is multi-line, insert " * " prefixes on subsequent lines.
            out += tagToString(tag, escapeExtraTags).split('\n').join('\n * ');
            out += '\n';
        }
        out += includeStartEnd ? ' */\n' : ' ';
        return out;
    }
    /** Merges multiple tags (of the same tagName type) into a single unified tag. */
    function merge(tags) {
        const tagNames = new Set();
        const parameterNames = new Set();
        const types = new Set();
        const texts = new Set();
        // If any of the tags are optional/rest, then the merged output is optional/rest.
        let optional = false;
        let restParam = false;
        for (const tag of tags) {
            tagNames.add(tag.tagName);
            if (tag.parameterName !== undefined)
                parameterNames.add(tag.parameterName);
            if (tag.type !== undefined)
                types.add(tag.type);
            if (tag.text !== undefined)
                texts.add(tag.text);
            if (tag.optional)
                optional = true;
            if (tag.restParam)
                restParam = true;
        }
        if (tagNames.size !== 1) {
            throw new Error(`cannot merge differing tags: ${JSON.stringify(tags)}`);
        }
        const tagName = tagNames.values().next().value;
        const parameterName = parameterNames.size > 0 ? Array.from(parameterNames).join('_or_') : undefined;
        const type = types.size > 0 ? Array.from(types).join('|') : undefined;
        // @template uses text (not type!) to declare its type parameters, with ','-separated text.
        const isTemplateTag = tagName === 'template';
        const text = texts.size > 0 ? Array.from(texts).join(isTemplateTag ? ',' : ' / ') : undefined;
        const tag = { tagName, parameterName, type, text };
        // Note: a param can either be optional or a rest param; if we merged an
        // optional and rest param together, prefer marking it as a rest param.
        if (restParam) {
            tag.restParam = true;
        }
        else if (optional) {
            tag.optional = true;
        }
        return tag;
    }
    exports.merge = merge;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNkb2MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvanNkb2MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7O0lBRUgsaUNBQWlDO0lBc0NqQzs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxNQUFNLDJCQUEyQixHQUFHLElBQUksR0FBRyxDQUFDO1FBQzFDLFVBQVU7UUFDVixVQUFVO1FBQ1YsUUFBUTtRQUNSLE9BQU87UUFDUCxVQUFVO1FBQ1YsYUFBYTtRQUNiLFdBQVc7UUFDWCxRQUFRO1FBQ1IsWUFBWTtRQUNaLE1BQU07UUFDTixNQUFNO1FBQ04sVUFBVTtRQUNWLFNBQVM7UUFDVCxhQUFhO1FBQ2IsTUFBTTtRQUNOLFFBQVE7UUFDUixRQUFRO1FBQ1IsU0FBUztRQUNULFNBQVM7UUFDVCxjQUFjO1FBQ2QsT0FBTztRQUNQLGVBQWU7UUFDZixtQkFBbUI7UUFDbkIsUUFBUTtRQUNSLElBQUk7UUFDSixhQUFhO1FBQ2IsUUFBUTtRQUNSLFlBQVk7UUFDWixjQUFjO1FBQ2QsWUFBWTtRQUNaLFdBQVc7UUFDWCxjQUFjO1FBQ2QsY0FBYztRQUNkLGVBQWU7UUFDZixzQkFBc0I7UUFDdEIsT0FBTztRQUNQLFNBQVM7UUFDVCxNQUFNO1FBQ04sU0FBUztRQUNULFVBQVU7UUFDVixTQUFTO1FBQ1QsTUFBTTtRQUNOLFVBQVU7UUFDVixTQUFTO1FBQ1QsWUFBWTtRQUNaLFdBQVc7UUFDWCxlQUFlO1FBQ2YsVUFBVTtRQUNWLE9BQU87UUFDUCxTQUFTO1FBQ1QsT0FBTztRQUNQLGFBQWE7UUFDYixTQUFTO1FBQ1QsaUJBQWlCO1FBQ2pCLFVBQVU7UUFDVixhQUFhO1FBQ2IsU0FBUztRQUNULFdBQVc7UUFDWCxRQUFRO1FBQ1IsUUFBUTtRQUNSLFlBQVk7UUFDWixVQUFVO1FBQ1YsUUFBUTtRQUNSLFNBQVM7UUFDVCxLQUFLO1FBQ0wsUUFBUTtRQUNSLFVBQVU7UUFDVixVQUFVO1FB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QUFHLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBQ3RFLDJGQUEyRjtRQUMzRixNQUFNLGFBQWEsR0FBRyxPQUFPLEtBQUssVUFBVSxDQUFDO1FBQzdDLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUM5RixNQUFNLEdBQUcsR0FBUSxFQUFDLE9BQU8sRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBQyxDQUFDO1FBQ3RELHdFQUF3RTtRQUN4RSx1RUFBdUU7UUFDdkUsSUFBSSxTQUFTLEVBQUU7WUFDYixHQUFHLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztTQUN0QjthQUFNLElBQUksUUFBUSxFQUFFO1lBQ25CLEdBQUcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1NBQ3JCO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBcENELHNCQW9DQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5cbi8qKlxuICogVHlwZVNjcmlwdCBoYXMgYW4gQVBJIGZvciBKU0RvYyBhbHJlYWR5LCBidXQgaXQncyBub3QgZXhwb3NlZC5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNzM5M1xuICogRm9yIG5vdyB3ZSBjcmVhdGUgdHlwZXMgdGhhdCBhcmUgc2ltaWxhciB0byB0aGVpcnMgc28gdGhhdCBtaWdyYXRpbmdcbiAqIHRvIHRoZWlyIEFQSSB3aWxsIGJlIGVhc2llci4gIFNlZSBlLmcuIHRzLkpTRG9jVGFnIGFuZCB0cy5KU0RvY0NvbW1lbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFnIHtcbiAgLyoqXG4gICAqIHRhZ05hbWUgaXMgZS5nLiBcInBhcmFtXCIgaW4gYW4gQHBhcmFtIGRlY2xhcmF0aW9uLiAgSXQgaXMgdGhlIGVtcHR5IHN0cmluZ1xuICAgKiBmb3IgdGhlIHBsYWluIHRleHQgZG9jdW1lbnRhdGlvbiB0aGF0IG9jY3VycyBiZWZvcmUgYW55IEBmb28gbGluZXMuXG4gICAqL1xuICB0YWdOYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBwYXJhbWV0ZXJOYW1lIGlzIHRoZSB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gcGFyYW1ldGVyLCBlLmcuIFwiZm9vXCJcbiAgICogaW4gYFxcQHBhcmFtIGZvbyBUaGUgZm9vIHBhcmFtYFxuICAgKi9cbiAgcGFyYW1ldGVyTmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGEgSlNEb2MgXFxAcGFyYW0sIFxcQHR5cGUgZXRjIHRhZywgcmVuZGVyZWQgaW4gY3VybHkgYnJhY2VzLlxuICAgKiBDYW4gYWxzbyBob2xkIHRoZSB0eXBlIG9mIGFuIFxcQHN1cHByZXNzLlxuICAgKi9cbiAgdHlwZT86IHN0cmluZztcbiAgLyoqIG9wdGlvbmFsIGlzIHRydWUgZm9yIG9wdGlvbmFsIGZ1bmN0aW9uIHBhcmFtZXRlcnMuICovXG4gIG9wdGlvbmFsPzogYm9vbGVhbjtcbiAgLyoqIHJlc3RQYXJhbSBpcyB0cnVlIGZvciBcIi4uLng6IGZvb1tdXCIgZnVuY3Rpb24gcGFyYW1ldGVycy4gKi9cbiAgcmVzdFBhcmFtPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIGRlc3RydWN0dXJpbmcgaXMgdHJ1ZSBmb3IgZGVzdHJ1Y3R1cmluZyBiaW5kIHBhcmFtZXRlcnMsIHdoaWNoIHJlcXVpcmVcbiAgICogbm9uLW51bGwgYXJndW1lbnRzIG9uIHRoZSBDbG9zdXJlIHNpZGUuICBDYW4gbGlrZWx5IHJlbW92ZSB0aGlzXG4gICAqIG9uY2UgVHlwZVNjcmlwdCBudWxsYWJsZSB0eXBlcyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgZGVzdHJ1Y3R1cmluZz86IGJvb2xlYW47XG4gIC8qKiBBbnkgcmVtYWluaW5nIHRleHQgb24gdGhlIHRhZywgZS5nLiB0aGUgZGVzY3JpcHRpb24uICovXG4gIHRleHQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGFsbCBKU0RvYyB0YWdzIGFsbG93ZWQgYnkgdGhlIENsb3N1cmUgY29tcGlsZXIuXG4gKiBBbGwgdGFncyBvdGhlciB0aGFuIHRoZXNlIGFyZSBlc2NhcGVkIGJlZm9yZSBlbWl0dGluZy5cbiAqXG4gKiBOb3RlIHRoYXQgc29tZSBvZiB0aGVzZSB0YWdzIGFyZSBhbHNvIHJlamVjdGVkIGJ5IHRzaWNrbGUgd2hlbiBzZWVuIGluXG4gKiB0aGUgdXNlci1wcm92aWRlZCBzb3VyY2UsIGJ1dCBhbHNvIHRoYXQgdHNpY2tsZSBpdHNlbGYgbWF5IGdlbmVyYXRlIHNvbWUgb2YgdGhlc2UuXG4gKiBUaGlzIHdoaXRlbGlzdCBpcyBqdXN0IHVzZWQgZm9yIGNvbnRyb2xsaW5nIHRoZSBvdXRwdXQuXG4gKlxuICogVGhlIHB1YmxpYyBDbG9zdXJlIGRvY3MgZG9uJ3QgbGlzdCBhbGwgdGhlIHRhZ3MgaXQgYWxsb3dzOyB0aGlzIGxpc3QgY29tZXNcbiAqIGZyb20gdGhlIGNvbXBpbGVyIHNvdXJjZSBpdHNlbGYuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvYmxvYi9tYXN0ZXIvc3JjL2NvbS9nb29nbGUvamF2YXNjcmlwdC9qc2NvbXAvcGFyc2luZy9Bbm5vdGF0aW9uLmphdmFcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9ibG9iL21hc3Rlci9zcmMvY29tL2dvb2dsZS9qYXZhc2NyaXB0L2pzY29tcC9wYXJzaW5nL1BhcnNlckNvbmZpZy5wcm9wZXJ0aWVzXG4gKi9cbmNvbnN0IEpTRE9DX1RBR1NfT1VUUFVUX1dISVRFTElTVCA9IG5ldyBTZXQoW1xuICAnYWJzdHJhY3QnLFxuICAnYXJndW1lbnQnLFxuICAnYXV0aG9yJyxcbiAgJ2NvbnN0JyxcbiAgJ2NvbnN0YW50JyxcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2NvcHlyaWdodCcsXG4gICdkZWZpbmUnLFxuICAnZGVwcmVjYXRlZCcsXG4gICdkZXNjJyxcbiAgJ2RpY3QnLFxuICAnZGlzcG9zZXMnLFxuICAnZW5oYW5jZScsXG4gICdlbmhhbmNlYWJsZScsXG4gICdlbnVtJyxcbiAgJ2V4cG9ydCcsXG4gICdleHBvc2UnLFxuICAnZXh0ZW5kcycsXG4gICdleHRlcm5zJyxcbiAgJ2ZpbGVvdmVydmlldycsXG4gICdmaW5hbCcsXG4gICdoYXNzb3lkZWxjYWxsJyxcbiAgJ2hhc3NveWRlbHRlbXBsYXRlJyxcbiAgJ2hpZGRlbicsXG4gICdpZCcsXG4gICdpZEdlbmVyYXRvcicsXG4gICdpZ25vcmUnLFxuICAnaW1wbGVtZW50cycsXG4gICdpbXBsaWNpdENhc3QnLFxuICAnaW5oZXJpdERvYycsXG4gICdpbnRlcmZhY2UnLFxuICAnamFnZ2VySW5qZWN0JyxcbiAgJ2phZ2dlck1vZHVsZScsXG4gICdqYWdnZXJQcm92aWRlJyxcbiAgJ2phZ2dlclByb3ZpZGVQcm9taXNlJyxcbiAgJ2xlbmRzJyxcbiAgJ2xpY2Vuc2UnLFxuICAnbGluaycsXG4gICdtZWFuaW5nJyxcbiAgJ21vZGlmaWVzJyxcbiAgJ21vZE5hbWUnLFxuICAnbW9kcycsXG4gICduZ0luamVjdCcsXG4gICdub2FsaWFzJyxcbiAgJ25vY29sbGFwc2UnLFxuICAnbm9jb21waWxlJyxcbiAgJ25vc2lkZWVmZmVjdHMnLFxuICAnb3ZlcnJpZGUnLFxuICAnb3duZXInLFxuICAncGFja2FnZScsXG4gICdwYXJhbScsXG4gICdwaW50b21vZHVsZScsXG4gICdwb2x5bWVyJyxcbiAgJ3BvbHltZXJCZWhhdmlvcicsXG4gICdwcmVzZXJ2ZScsXG4gICdwcmVzZXJ2ZVRyeScsXG4gICdwcml2YXRlJyxcbiAgJ3Byb3RlY3RlZCcsXG4gICdwdWJsaWMnLFxuICAncmVjb3JkJyxcbiAgJ3JlcXVpcmVjc3MnLFxuICAncmVxdWlyZXMnLFxuICAncmV0dXJuJyxcbiAgJ3JldHVybnMnLFxuICAnc2VlJyxcbiAgJ3N0cnVjdCcsXG4gICdzdXBwcmVzcycsXG4gICd0ZW1wbGF0ZScsXG4gICd0aGlzJyxcbiAgJ3Rocm93cycsXG4gICd0eXBlJyxcbiAgJ3R5cGVkZWYnLFxuICAndW5yZXN0cmljdGVkJyxcbiAgJ3ZlcnNpb24nLFxuICAnd2l6YWN0aW9uJyxcbiAgJ3dpem1vZHVsZScsXG5dKTtcblxuLyoqXG4gKiBBIGxpc3Qgb2YgSlNEb2MgQHRhZ3MgdGhhdCBhcmUgbmV2ZXIgYWxsb3dlZCBpbiBUeXBlU2NyaXB0IHNvdXJjZS4gVGhlc2UgYXJlIENsb3N1cmUgdGFncyB0aGF0XG4gKiBjYW4gYmUgZXhwcmVzc2VkIGluIHRoZSBUeXBlU2NyaXB0IHN1cmZhY2Ugc3ludGF4LiBBcyB0c2lja2xlJ3MgZW1pdCB3aWxsIG1hbmdsZSB0eXBlIG5hbWVzLFxuICogdGhlc2Ugd2lsbCBjYXVzZSBDbG9zdXJlIENvbXBpbGVyIGlzc3VlcyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogTm90ZTogJ3RlbXBsYXRlJyBpcyBzcGVjaWFsLWNhc2VkIGJlbG93OyBzZWUgd2hlcmUgdGhpcyBzZXQgaXMgcXVlcmllZC5cbiAqL1xuY29uc3QgSlNET0NfVEFHU19JTlBVVF9CTEFDS0xJU1QgPSBuZXcgU2V0KFtcbiAgJ2F1Z21lbnRzJywgJ2NsYXNzJywgICAgICAnY29uc3RydWN0cycsICdjb25zdHJ1Y3RvcicsICdlbnVtJywgICAgICAnZXh0ZW5kcycsICdmaWVsZCcsXG4gICdmdW5jdGlvbicsICdpbXBsZW1lbnRzJywgJ2ludGVyZmFjZScsICAnbGVuZHMnLCAgICAgICAnbmFtZXNwYWNlJywgJ3ByaXZhdGUnLCAncHJvdGVjdGVkJyxcbiAgJ3B1YmxpYycsICAgJ3JlY29yZCcsICAgICAnc3RhdGljJywgICAgICd0ZW1wbGF0ZScsICAgICd0aGlzJywgICAgICAndHlwZScsICAgICd0eXBlZGVmJyxcbl0pO1xuXG4vKipcbiAqIEpTRG9jIFxcQHRhZ3MgdGhhdCBtaWdodCBpbmNsdWRlIGEge3R5cGV9IGFmdGVyIHRoZW0uIFNwZWNpZnlpbmcgYSB0eXBlIGlzIGZvcmJpZGRlbiwgc2luY2UgaXRcbiAqIHdvdWxkIGNvbGxpZGUgd2l0aCBUeXBlU2NyaXB0J3MgdHlwZSBpbmZvcm1hdGlvbi4gSWYgYSB0eXBlICppcyogZ2l2ZW4sIHRoZSBlbnRpcmUgdGFnIHdpbGwgYmVcbiAqIGlnbm9yZWQuXG4gKi9cbmNvbnN0IEpTRE9DX1RBR1NfV0lUSF9UWVBFUyA9IG5ldyBTZXQoW1xuICAnY29uc3QnLFxuICAnZGVmaW5lJyxcbiAgJ2V4cG9ydCcsXG4gICdwYXJhbScsXG4gICdyZXR1cm4nLFxuXSk7XG5cbi8qKlxuICogUmVzdWx0IG9mIHBhcnNpbmcgYSBKU0RvYyBjb21tZW50LiBTdWNoIGNvbW1lbnRzIGVzc2VudGlhbGx5IGFyZSBidWlsdCBvZiBhIGxpc3Qgb2YgdGFncy5cbiAqIEluIGFkZGl0aW9uIHRvIHRoZSB0YWdzLCB0aGlzIG1pZ2h0IGFsc28gY29udGFpbiB3YXJuaW5ncyB0byBpbmRpY2F0ZSBub24tZmF0YWwgcHJvYmxlbXNcbiAqIHdoaWxlIGZpbmRpbmcgdGhlIHRhZ3MuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkSlNEb2NDb21tZW50IHtcbiAgdGFnczogVGFnW107XG4gIHdhcm5pbmdzPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogcGFyc2UgcGFyc2VzIEpTRG9jIG91dCBvZiBhIGNvbW1lbnQgc3RyaW5nLlxuICogUmV0dXJucyBudWxsIGlmIGNvbW1lbnQgaXMgbm90IEpTRG9jLlxuICovXG4vLyBUT0RPKG1hcnRpbnByb2JzdCk6IHJlcHJlc2VudGluZyBKU0RvYyBhcyBhIGxpc3Qgb2YgdGFncyBpcyB0b28gc2ltcGxpc3RpYy4gV2UgbmVlZCBmdW5jdGlvbmFsaXR5XG4vLyBzdWNoIGFzIG1lcmdpbmcgKGJlbG93KSwgZGUtZHVwbGljYXRpbmcgY2VydGFpbiB0YWdzIChAZGVwcmVjYXRlZCksIGFuZCBzcGVjaWFsIHRyZWF0bWVudCBmb3Jcbi8vIG90aGVycyAoZS5nLiBAc3VwcHJlc3MpLiBXZSBzaG91bGQgaW50cm9kdWNlIGEgcHJvcGVyIG1vZGVsIGNsYXNzIHdpdGggYSBtb3JlIHN1aXRhYmxlIGRhdGFcbi8vIHN0cnVjdXJlIChlLmcuIGEgTWFwPFRhZ05hbWUsIFZhbHVlc1tdPikuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoY29tbWVudDogdHMuU3ludGhlc2l6ZWRDb21tZW50KTogUGFyc2VkSlNEb2NDb21tZW50fG51bGwge1xuICAvLyBUT0RPKGV2YW5tKTogdGhpcyBpcyBhIHBpbGUgb2YgaGFja3kgcmVnZXhlcyBmb3Igbm93LCBiZWNhdXNlIHdlXG4gIC8vIHdvdWxkIHJhdGhlciB1c2UgdGhlIGJldHRlciBUeXBlU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEpTRG9jXG4gIC8vIHBhcnNpbmcuICBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzczOTNcbiAgaWYgKGNvbW1lbnQua2luZCAhPT0gdHMuU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhKSByZXR1cm4gbnVsbDtcbiAgLy8gY29tbWVudC50ZXh0IGRvZXMgbm90IGluY2x1ZGUgLyogYW5kICovLCBzbyBtdXN0IHN0YXJ0IHdpdGggJyonIGZvciBKU0RvYy5cbiAgaWYgKGNvbW1lbnQudGV4dFswXSAhPT0gJyonKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgdGV4dCA9IGNvbW1lbnQudGV4dC5zdWJzdHJpbmcoMSkudHJpbSgpO1xuICByZXR1cm4gcGFyc2VDb250ZW50cyh0ZXh0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgd2l0aCBsaW5lIGVuZGluZ3Mgbm9ybWFsaXplZCB0byAnXFxuJy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmVFbmRpbmdzKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbn1cblxuLyoqXG4gKiBwYXJzZUNvbnRlbnRzIHBhcnNlcyBKU0RvYyBvdXQgb2YgYSBjb21tZW50IHRleHQuXG4gKiBSZXR1cm5zIG51bGwgaWYgY29tbWVudCBpcyBub3QgSlNEb2MuXG4gKlxuICogQHBhcmFtIGNvbW1lbnRUZXh0IGEgY29tbWVudCdzIHRleHQgY29udGVudCwgaS5lLiB0aGUgY29tbWVudCB3L28gLyogYW5kICogLy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudHMoY29tbWVudFRleHQ6IHN0cmluZyk6IFBhcnNlZEpTRG9jQ29tbWVudHxudWxsIHtcbiAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgcHJvcGVyIGxpbmUgZW5kaW5ncyBiZWZvcmUgcGFyc2luZyBvbiBXaW5kb3dzLlxuICBjb21tZW50VGV4dCA9IG5vcm1hbGl6ZUxpbmVFbmRpbmdzKGNvbW1lbnRUZXh0KTtcbiAgLy8gU3RyaXAgYWxsIHRoZSBcIiAqIFwiIGJpdHMgZnJvbSB0aGUgZnJvbnQgb2YgZWFjaCBsaW5lLlxuICBjb21tZW50VGV4dCA9IGNvbW1lbnRUZXh0LnJlcGxhY2UoL15cXHMqXFwqPyA/L2dtLCAnJyk7XG4gIGNvbnN0IGxpbmVzID0gY29tbWVudFRleHQuc3BsaXQoJ1xcbicpO1xuICBjb25zdCB0YWdzOiBUYWdbXSA9IFtdO1xuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgbGV0IG1hdGNoID0gbGluZS5tYXRjaCgvXlxccypAKFxcUyspICooLiopLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBsZXQgW18sIHRhZ05hbWUsIHRleHRdID0gbWF0Y2g7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gJ3JldHVybnMnKSB7XG4gICAgICAgIC8vIEEgc3lub255bSBmb3IgJ3JldHVybicuXG4gICAgICAgIHRhZ05hbWUgPSAncmV0dXJuJztcbiAgICAgIH1cbiAgICAgIGxldCB0eXBlOiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgICAgaWYgKEpTRE9DX1RBR1NfSU5QVVRfQkxBQ0tMSVNULmhhcyh0YWdOYW1lKSkge1xuICAgICAgICBpZiAodGFnTmFtZSAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIC8vIFRlbGwgdGhlIHVzZXIgdG8gbm90IHdyaXRlIGJsYWNrbGlzdGVkIHRhZ3MsIGJlY2F1c2UgdGhlcmUgaXMgVFNcbiAgICAgICAgICAvLyBzeW50YXggYXZhaWxhYmxlIGZvciB0aGVtLlxuICAgICAgICAgIHdhcm5pbmdzLnB1c2goYEAke3RhZ05hbWV9IGFubm90YXRpb25zIGFyZSByZWR1bmRhbnQgd2l0aCBUeXBlU2NyaXB0IGVxdWl2YWxlbnRzYCk7XG4gICAgICAgICAgY29udGludWU7ICAvLyBEcm9wIHRoZSB0YWcgc28gQ2xvc3VyZSB3b24ndCBwcm9jZXNzIGl0LlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEJ1dCBAdGVtcGxhdGUgaW4gcGFydGljdWxhciBpcyBzcGVjaWFsOiBpdCdzIG9rIGZvciB0aGUgdXNlciB0b1xuICAgICAgICAgIC8vIHdyaXRlIGl0IGZvciBkb2N1bWVudGF0aW9uIHB1cnBvc2VzLCBidXQgd2UgZG9uJ3Qgd2FudCB0aGVcbiAgICAgICAgICAvLyB1c2VyLXdyaXR0ZW4gb25lIG1ha2luZyBpdCBpbnRvIHRoZSBvdXRwdXQgYmVjYXVzZSBDbG9zdXJlIGludGVycHJldHNcbiAgICAgICAgICAvLyBpdCBhcyB3ZWxsLlxuICAgICAgICAgIC8vIERyb3AgaXQgd2l0aG91dCBhbnkgd2FybmluZy4gIChXZSBhbHNvIGRvbid0IGVuc3VyZSBpdHMgY29ycmVjdG5lc3MuKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEpTRE9DX1RBR1NfV0lUSF9UWVBFUy5oYXModGFnTmFtZSkpIHtcbiAgICAgICAgaWYgKHRleHRbMF0gPT09ICd7Jykge1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goXG4gICAgICAgICAgICAgIGB0aGUgdHlwZSBhbm5vdGF0aW9uIG9uIEAke3RhZ05hbWV9IGlzIHJlZHVuZGFudCB3aXRoIGl0cyBUeXBlU2NyaXB0IHR5cGUsIGAgK1xuICAgICAgICAgICAgICBgcmVtb3ZlIHRoZSB7Li4ufSBwYXJ0YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ3N1cHByZXNzJykge1xuICAgICAgICBjb25zdCB0eXBlTWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eXFx7KC4qKVxcfSguKikkLyk7XG4gICAgICAgIGlmICh0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBbLCB0eXBlLCB0ZXh0XSA9IHR5cGVNYXRjaDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5ncy5wdXNoKGBtYWxmb3JtZWQgQCR7dGFnTmFtZX0gdGFnOiBcIiR7dGV4dH1cImApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdkaWN0Jykge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKCd1c2UgaW5kZXggc2lnbmF0dXJlcyAoYFtrOiBzdHJpbmddOiB0eXBlYCkgaW5zdGVhZCBvZiBAZGljdCcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gR3JhYiB0aGUgcGFyYW1ldGVyIG5hbWUgZnJvbSBAcGFyYW0gdGFncy5cbiAgICAgIGxldCBwYXJhbWV0ZXJOYW1lOiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgICAgaWYgKHRhZ05hbWUgPT09ICdwYXJhbScpIHtcbiAgICAgICAgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxcUyspID8oLiopLyk7XG4gICAgICAgIGlmIChtYXRjaCkgW18sIHBhcmFtZXRlck5hbWUsIHRleHRdID0gbWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhZzogVGFnID0ge3RhZ05hbWV9O1xuICAgICAgaWYgKHBhcmFtZXRlck5hbWUpIHRhZy5wYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZTtcbiAgICAgIGlmICh0ZXh0KSB0YWcudGV4dCA9IHRleHQ7XG4gICAgICBpZiAodHlwZSkgdGFnLnR5cGUgPSB0eXBlO1xuICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRleHQgd2l0aG91dCBhIHByZWNlZGluZyBAdGFnIG9uIGl0IGlzIGVpdGhlciB0aGUgcGxhaW4gdGV4dFxuICAgICAgLy8gZG9jdW1lbnRhdGlvbiBvciBhIGNvbnRpbnVhdGlvbiBvZiBhIHByZXZpb3VzIHRhZy5cbiAgICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICcnLCB0ZXh0OiBsaW5lfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYXN0VGFnID0gdGFnc1t0YWdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsYXN0VGFnLnRleHQgPSAobGFzdFRhZy50ZXh0IHx8ICcnKSArICdcXG4nICsgbGluZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge3RhZ3MsIHdhcm5pbmdzfTtcbiAgfVxuICByZXR1cm4ge3RhZ3N9O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgYSBUYWcgaW50byBhIHN0cmluZyB1c2FibGUgaW4gYSBjb21tZW50LlxuICogUmV0dXJucyBhIHN0cmluZyBsaWtlIFwiIEBmb28ge2Jhcn0gYmF6XCIgKG5vdGUgdGhlIHdoaXRlc3BhY2UpLlxuICovXG5mdW5jdGlvbiB0YWdUb1N0cmluZyh0YWc6IFRhZywgZXNjYXBlRXh0cmFUYWdzID0gbmV3IFNldDxzdHJpbmc+KCkpOiBzdHJpbmcge1xuICBsZXQgb3V0ID0gJyc7XG4gIGlmICh0YWcudGFnTmFtZSkge1xuICAgIGlmICghSlNET0NfVEFHU19PVVRQVVRfV0hJVEVMSVNULmhhcyh0YWcudGFnTmFtZSkgfHwgZXNjYXBlRXh0cmFUYWdzLmhhcyh0YWcudGFnTmFtZSkpIHtcbiAgICAgIC8vIEVzY2FwZSB0YWdzIHdlIGRvbid0IHVuZGVyc3RhbmQuICBUaGlzIGlzIGEgc3VidGxlXG4gICAgICAvLyBjb21wcm9taXNlIGJldHdlZW4gbXVsdGlwbGUgaXNzdWVzLlxuICAgICAgLy8gMSkgSWYgd2UgcGFzcyB0aHJvdWdoIHRoZXNlIG5vbi1DbG9zdXJlIHRhZ3MsIHRoZSB1c2VyIHdpbGxcbiAgICAgIC8vICAgIGdldCBhIHdhcm5pbmcgZnJvbSBDbG9zdXJlLCBhbmQgdGhlIHBvaW50IG9mIHRzaWNrbGUgaXNcbiAgICAgIC8vICAgIHRvIGluc3VsYXRlIHRoZSB1c2VyIGZyb20gQ2xvc3VyZS5cbiAgICAgIC8vIDIpIFRoZSBvdXRwdXQgb2YgdHNpY2tsZSBpcyBmb3IgQ2xvc3VyZSBidXQgYWxzbyBtYXkgYmUgcmVhZFxuICAgICAgLy8gICAgYnkgaHVtYW5zLCBmb3IgZXhhbXBsZSBub24tVHlwZVNjcmlwdCB1c2VycyBvZiBBbmd1bGFyLlxuICAgICAgLy8gMykgRmluYWxseSwgd2UgZG9uJ3Qgd2FudCB0byB3YXJuIGJlY2F1c2UgdXNlcnMgc2hvdWxkIGJlXG4gICAgICAvLyAgICBmcmVlIHRvIGFkZCB3aGljaGV2ZXIgSlNEb2MgdGhleSBmZWVsIGxpa2UuICBJZiB0aGUgdXNlclxuICAgICAgLy8gICAgd2FudHMgaGVscCBlbnN1cmluZyB0aGV5IGRpZG4ndCB0eXBvIGEgdGFnLCB0aGF0IGlzIHRoZVxuICAgICAgLy8gICAgcmVzcG9uc2liaWxpdHkgb2YgYSBsaW50ZXIuXG4gICAgICBvdXQgKz0gYCBcXFxcQCR7dGFnLnRhZ05hbWV9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IGAgQCR7dGFnLnRhZ05hbWV9YDtcbiAgICB9XG4gIH1cbiAgaWYgKHRhZy50eXBlKSB7XG4gICAgb3V0ICs9ICcgeyc7XG4gICAgaWYgKHRhZy5yZXN0UGFyYW0pIHtcbiAgICAgIG91dCArPSAnLi4uJztcbiAgICB9XG4gICAgb3V0ICs9IHRhZy50eXBlO1xuICAgIGlmICh0YWcub3B0aW9uYWwpIHtcbiAgICAgIG91dCArPSAnPSc7XG4gICAgfVxuICAgIG91dCArPSAnfSc7XG4gIH1cbiAgaWYgKHRhZy5wYXJhbWV0ZXJOYW1lKSB7XG4gICAgb3V0ICs9ICcgJyArIHRhZy5wYXJhbWV0ZXJOYW1lO1xuICB9XG4gIGlmICh0YWcudGV4dCkge1xuICAgIG91dCArPSAnICcgKyB0YWcudGV4dC5yZXBsYWNlKC9AL2csICdcXFxcQCcpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKiBUYWdzIHRoYXQgbXVzdCBvbmx5IG9jY3VyIG9uY2VzIGluIGEgY29tbWVudCAoZmlsdGVyZWQgYmVsb3cpLiAqL1xuY29uc3QgU0lOR0xFVE9OX1RBR1MgPSBuZXcgU2V0KFsnZGVwcmVjYXRlZCddKTtcblxuLyoqIFRhZ3MgdGhhdCBjb25mbGljdCB3aXRoIFxcQHR5cGUgaW4gQ2xvc3VyZSBDb21waWxlciAoZS5nLiBcXEBwYXJhbSkuICovXG5leHBvcnQgY29uc3QgVEFHU19DT05GTElDVElOR19XSVRIX1RZUEUgPSBuZXcgU2V0KFsncGFyYW0nLCAncmV0dXJuJ10pO1xuXG4vKipcbiAqIEEgc3ludGhlc2l6ZWQgY29tbWVudCB0aGF0IChwb3NzaWJseSkgaW5jbHVkZXMgdGhlIG9yaWdpbmFsIGNvbW1lbnQgcmFuZ2UgaXQgd2FzIGNyZWF0ZWQgZnJvbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTeW50aGVzaXplZENvbW1lbnRXaXRoT3JpZ2luYWwgZXh0ZW5kcyB0cy5TeW50aGVzaXplZENvbW1lbnQge1xuICAvKipcbiAgICogVGhlIG9yaWdpbmFsIHRleHQgcmFuZ2Ugb2YgdGhlIGNvbW1lbnQgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2UgZmlsZSdzIGZ1bGwgdGV4dCkuXG4gICAqL1xuICBvcmlnaW5hbFJhbmdlPzogdHMuVGV4dFJhbmdlO1xufVxuXG4vKipcbiAqIHN5bnRoZXNpemVMZWFkaW5nQ29tbWVudHMgcGFyc2VzIHRoZSBsZWFkaW5nIGNvbW1lbnRzIG9mIG5vZGUsIGNvbnZlcnRzIHRoZW1cbiAqIHRvIHN5bnRoZXRpYyBjb21tZW50cywgYW5kIG1ha2VzIHN1cmUgdGhlIG9yaWdpbmFsIHRleHQgY29tbWVudHMgZG8gbm90IGdldFxuICogZW1pdHRlZCBieSBUeXBlU2NyaXB0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ludGhlc2l6ZUxlYWRpbmdDb21tZW50cyhub2RlOiB0cy5Ob2RlKTogU3ludGhlc2l6ZWRDb21tZW50V2l0aE9yaWdpbmFsW10ge1xuICBjb25zdCBleGlzdGluZyA9IHRzLmdldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhub2RlKTtcbiAgaWYgKGV4aXN0aW5nKSByZXR1cm4gZXhpc3Rpbmc7XG4gIGNvbnN0IHRleHQgPSBub2RlLmdldEZ1bGxUZXh0KCk7XG4gIGNvbnN0IHN5bnRoQ29tbWVudHMgPSBnZXRMZWFkaW5nQ29tbWVudFJhbmdlc1N5bnRoZXNpemVkKHRleHQsIG5vZGUuZ2V0RnVsbFN0YXJ0KCkpO1xuICBpZiAoc3ludGhDb21tZW50cy5sZW5ndGgpIHtcbiAgICB0cy5zZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHMobm9kZSwgc3ludGhDb21tZW50cyk7XG4gICAgc3VwcHJlc3NMZWFkaW5nQ29tbWVudHNSZWN1cnNpdmVseShub2RlKTtcbiAgfVxuICByZXR1cm4gc3ludGhDb21tZW50cztcbn1cblxuLyoqXG4gKiBwYXJzZUxlYWRpbmdDb21tZW50UmFuZ2VzU3ludGhlc2l6ZWQgcGFyc2VzIHRoZSBsZWFkaW5nIGNvbW1lbnQgcmFuZ2VzIG91dCBvZiB0aGUgZ2l2ZW4gdGV4dCBhbmRcbiAqIGNvbnZlcnRzIHRoZW0gdG8gU3ludGhlc2l6ZWRDb21tZW50cy5cbiAqIEBwYXJhbSBvZmZzZXQgdGhlIG9mZnNldCBvZiB0ZXh0IGluIHRoZSBzb3VyY2UgZmlsZSwgZS5nLiBub2RlLmdldEZ1bGxTdGFydCgpLlxuICovXG4vLyBWaXNpYmxlRm9yVGVzdGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlYWRpbmdDb21tZW50UmFuZ2VzU3ludGhlc2l6ZWQoXG4gICAgdGV4dDogc3RyaW5nLCBvZmZzZXQgPSAwKTogU3ludGhlc2l6ZWRDb21tZW50V2l0aE9yaWdpbmFsW10ge1xuICBjb25zdCBjb21tZW50cyA9IHRzLmdldExlYWRpbmdDb21tZW50UmFuZ2VzKHRleHQsIDApIHx8IFtdO1xuICByZXR1cm4gY29tbWVudHMubWFwKChjcik6IFN5bnRoZXNpemVkQ29tbWVudFdpdGhPcmlnaW5hbCA9PiB7XG4gICAgLy8gQ29uZnVzaW5nbHksIENvbW1lbnRSYW5nZSBpbiBUeXBlU2NyaXB0IGluY2x1ZGVzIHN0YXJ0IGFuZCBlbmQgbWFya2VycywgYnV0XG4gICAgLy8gU3ludGhlc2l6ZWRDb21tZW50cyBkbyBub3QuXG4gICAgY29uc3QgY29tbWVudFRleHQgPSBjci5raW5kID09PSB0cy5TeW50YXhLaW5kLlNpbmdsZUxpbmVDb21tZW50VHJpdmlhID9cbiAgICAgICAgdGV4dC5zdWJzdHJpbmcoY3IucG9zICsgMiwgY3IuZW5kKSA6XG4gICAgICAgIHRleHQuc3Vic3RyaW5nKGNyLnBvcyArIDIsIGNyLmVuZCAtIDIpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jcixcbiAgICAgIHRleHQ6IGNvbW1lbnRUZXh0LFxuICAgICAgcG9zOiAtMSxcbiAgICAgIGVuZDogLTEsXG4gICAgICBvcmlnaW5hbFJhbmdlOiB7cG9zOiBjci5wb3MgKyBvZmZzZXQsIGVuZDogY3IuZW5kICsgb2Zmc2V0fVxuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIHN1cHByZXNzQ29tbWVudHNSZWN1cnNpdmVseSBwcmV2ZW50cyBlbWl0IG9mIGxlYWRpbmcgY29tbWVudHMgb24gbm9kZSwgYW5kIGFueSByZWN1cnNpdmUgbm9kZXNcbiAqIHVuZGVybmVhdGggaXQgdGhhdCBzdGFydCBhdCB0aGUgc2FtZSBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXBwcmVzc0xlYWRpbmdDb21tZW50c1JlY3Vyc2l2ZWx5KG5vZGU6IHRzLk5vZGUpIHtcbiAgLy8gVHlwZVNjcmlwdCBlbWl0cyBsZWFkaW5nIGNvbW1lbnRzIG9uIGEgbm9kZSwgdW5sZXNzOlxuICAvLyAtIHRoZSBjb21tZW50IHdhcyBlbWl0dGVkIGJ5IHRoZSBwYXJlbnQgbm9kZVxuICAvLyAtIHRoZSBub2RlIGhhcyB0aGUgTm9MZWFkaW5nQ29tbWVudHMgZW1pdCBmbGFnLlxuICAvLyBIb3dldmVyLCB0cmFuc2Zvcm1hdGlvbiBzdGVwcyBzb21ldGltZXMgY29weSBub2RlcyB3aXRob3V0IGtlZXBpbmcgdGhlaXIgZW1pdCBmbGFncywgc28ganVzdFxuICAvLyBzZXR0aW5nIE5vTGVhZGluZ0NvbW1lbnRzIHJlY3Vyc2l2ZWx5IGlzIG5vdCBlbm91Z2gsIHdlIG11c3QgYWxzbyBzZXQgdGhlIHRleHQgcmFuZ2UgdG8gYXZvaWRcbiAgLy8gdGhlIGNvcGllZCBub2RlIHRvIGhhdmUgY29tbWVudHMgZW1pdHRlZC5cbiAgY29uc3Qgb3JpZ2luYWxTdGFydCA9IG5vZGUuZ2V0RnVsbFN0YXJ0KCk7XG4gIGNvbnN0IGFjdHVhbFN0YXJ0ID0gbm9kZS5nZXRTdGFydCgpO1xuICBmdW5jdGlvbiBzdXBwcmVzc0NvbW1lbnRzSW50ZXJuYWwobm9kZTogdHMuTm9kZSk6IGJvb2xlYW4ge1xuICAgIHRzLnNldEVtaXRGbGFncyhub2RlLCB0cy5FbWl0RmxhZ3MuTm9MZWFkaW5nQ29tbWVudHMpO1xuICAgIHJldHVybiAhIXRzLmZvckVhY2hDaGlsZChub2RlLCAoY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5wb3MgIT09IG9yaWdpbmFsU3RhcnQpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIHN1cHByZXNzQ29tbWVudHNJbnRlcm5hbChjaGlsZCk7XG4gICAgfSk7XG4gIH1cbiAgc3VwcHJlc3NDb21tZW50c0ludGVybmFsKG5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9TeW50aGVzaXplZENvbW1lbnQoXG4gICAgdGFnczogVGFnW10sIGVzY2FwZUV4dHJhVGFncz86IFNldDxzdHJpbmc+KTogdHMuU3ludGhlc2l6ZWRDb21tZW50IHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiB0cy5TeW50YXhLaW5kLk11bHRpTGluZUNvbW1lbnRUcml2aWEsXG4gICAgdGV4dDogdG9TdHJpbmdXaXRob3V0U3RhcnRFbmQodGFncywgZXNjYXBlRXh0cmFUYWdzKSxcbiAgICBwb3M6IC0xLFxuICAgIGVuZDogLTEsXG4gICAgaGFzVHJhaWxpbmdOZXdMaW5lOiB0cnVlLFxuICB9O1xufVxuXG4vKiogU2VyaWFsaXplcyBhIENvbW1lbnQgb3V0IHRvIGEgc3RyaW5nLCBidXQgZG9lcyBub3QgaW5jbHVkZSB0aGUgc3RhcnQgYW5kIGVuZCBjb21tZW50IHRva2Vucy4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ1dpdGhvdXRTdGFydEVuZCh0YWdzOiBUYWdbXSwgZXNjYXBlRXh0cmFUYWdzID0gbmV3IFNldDxzdHJpbmc+KCkpOiBzdHJpbmcge1xuICByZXR1cm4gc2VyaWFsaXplKHRhZ3MsIGZhbHNlLCBlc2NhcGVFeHRyYVRhZ3MpO1xufVxuXG4vKiogU2VyaWFsaXplcyBhIENvbW1lbnQgb3V0IHRvIGEgc3RyaW5nIHVzYWJsZSBpbiBzb3VyY2UgY29kZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyh0YWdzOiBUYWdbXSwgZXNjYXBlRXh0cmFUYWdzID0gbmV3IFNldDxzdHJpbmc+KCkpOiBzdHJpbmcge1xuICByZXR1cm4gc2VyaWFsaXplKHRhZ3MsIHRydWUsIGVzY2FwZUV4dHJhVGFncyk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShcbiAgICB0YWdzOiBUYWdbXSwgaW5jbHVkZVN0YXJ0RW5kOiBib29sZWFuLCBlc2NhcGVFeHRyYVRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKSk6IHN0cmluZyB7XG4gIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICBpZiAodGFncy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB0YWcgPSB0YWdzWzBdO1xuICAgIGlmICgodGFnLnRhZ05hbWUgPT09ICd0eXBlJyB8fCB0YWcudGFnTmFtZSA9PT0gJ3R5cGVkZWYnIHx8IHRhZy50YWdOYW1lID09PSAnbm9jb2xsYXBzZScpICYmXG4gICAgICAgICghdGFnLnRleHQgfHwgIXRhZy50ZXh0Lm1hdGNoKCdcXG4nKSkpIHtcbiAgICAgIC8vIFNwZWNpYWwtY2FzZSBvbmUtbGluZXIgXCJ0eXBlXCIgYW5kIFwibm9jb2xsYXBzZVwiIHRhZ3MgdG8gZml0IG9uIG9uZSBsaW5lLCBlLmcuXG4gICAgICAvLyAgIC8qKiBAdHlwZSB7Zm9vfSAqL1xuICAgICAgY29uc3QgdGV4dCA9IHRhZ1RvU3RyaW5nKHRhZywgZXNjYXBlRXh0cmFUYWdzKTtcbiAgICAgIHJldHVybiBpbmNsdWRlU3RhcnRFbmQgPyBgLyoqJHt0ZXh0fSAqL2AgOiBgKiR7dGV4dH0gYDtcbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBmYWxsIHRocm91Z2ggdG8gdGhlIG11bHRpLWxpbmUgb3V0cHV0LlxuICB9XG5cbiAgbGV0IG91dCA9IGluY2x1ZGVTdGFydEVuZCA/ICcvKipcXG4nIDogJypcXG4nO1xuICBjb25zdCBlbWl0dGVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICBpZiAoZW1pdHRlZC5oYXModGFnLnRhZ05hbWUpICYmIFNJTkdMRVRPTl9UQUdTLmhhcyh0YWcudGFnTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBlbWl0dGVkLmFkZCh0YWcudGFnTmFtZSk7XG4gICAgb3V0ICs9ICcgKic7XG4gICAgLy8gSWYgdGhlIHRhZ1RvU3RyaW5nIGlzIG11bHRpLWxpbmUsIGluc2VydCBcIiAqIFwiIHByZWZpeGVzIG9uIHN1YnNlcXVlbnQgbGluZXMuXG4gICAgb3V0ICs9IHRhZ1RvU3RyaW5nKHRhZywgZXNjYXBlRXh0cmFUYWdzKS5zcGxpdCgnXFxuJykuam9pbignXFxuICogJyk7XG4gICAgb3V0ICs9ICdcXG4nO1xuICB9XG4gIG91dCArPSBpbmNsdWRlU3RhcnRFbmQgPyAnICovXFxuJyA6ICcgJztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqIE1lcmdlcyBtdWx0aXBsZSB0YWdzIChvZiB0aGUgc2FtZSB0YWdOYW1lIHR5cGUpIGludG8gYSBzaW5nbGUgdW5pZmllZCB0YWcuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UodGFnczogVGFnW10pOiBUYWcge1xuICBjb25zdCB0YWdOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBjb25zdCBwYXJhbWV0ZXJOYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBjb25zdCB0eXBlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBjb25zdCB0ZXh0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAvLyBJZiBhbnkgb2YgdGhlIHRhZ3MgYXJlIG9wdGlvbmFsL3Jlc3QsIHRoZW4gdGhlIG1lcmdlZCBvdXRwdXQgaXMgb3B0aW9uYWwvcmVzdC5cbiAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gIGxldCByZXN0UGFyYW0gPSBmYWxzZTtcbiAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgIHRhZ05hbWVzLmFkZCh0YWcudGFnTmFtZSk7XG4gICAgaWYgKHRhZy5wYXJhbWV0ZXJOYW1lICE9PSB1bmRlZmluZWQpIHBhcmFtZXRlck5hbWVzLmFkZCh0YWcucGFyYW1ldGVyTmFtZSk7XG4gICAgaWYgKHRhZy50eXBlICE9PSB1bmRlZmluZWQpIHR5cGVzLmFkZCh0YWcudHlwZSk7XG4gICAgaWYgKHRhZy50ZXh0ICE9PSB1bmRlZmluZWQpIHRleHRzLmFkZCh0YWcudGV4dCk7XG4gICAgaWYgKHRhZy5vcHRpb25hbCkgb3B0aW9uYWwgPSB0cnVlO1xuICAgIGlmICh0YWcucmVzdFBhcmFtKSByZXN0UGFyYW0gPSB0cnVlO1xuICB9XG5cbiAgaWYgKHRhZ05hbWVzLnNpemUgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBtZXJnZSBkaWZmZXJpbmcgdGFnczogJHtKU09OLnN0cmluZ2lmeSh0YWdzKX1gKTtcbiAgfVxuICBjb25zdCB0YWdOYW1lID0gdGFnTmFtZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICBjb25zdCBwYXJhbWV0ZXJOYW1lID1cbiAgICAgIHBhcmFtZXRlck5hbWVzLnNpemUgPiAwID8gQXJyYXkuZnJvbShwYXJhbWV0ZXJOYW1lcykuam9pbignX29yXycpIDogdW5kZWZpbmVkO1xuICBjb25zdCB0eXBlID0gdHlwZXMuc2l6ZSA+IDAgPyBBcnJheS5mcm9tKHR5cGVzKS5qb2luKCd8JykgOiB1bmRlZmluZWQ7XG4gIC8vIEB0ZW1wbGF0ZSB1c2VzIHRleHQgKG5vdCB0eXBlISkgdG8gZGVjbGFyZSBpdHMgdHlwZSBwYXJhbWV0ZXJzLCB3aXRoICcsJy1zZXBhcmF0ZWQgdGV4dC5cbiAgY29uc3QgaXNUZW1wbGF0ZVRhZyA9IHRhZ05hbWUgPT09ICd0ZW1wbGF0ZSc7XG4gIGNvbnN0IHRleHQgPSB0ZXh0cy5zaXplID4gMCA/IEFycmF5LmZyb20odGV4dHMpLmpvaW4oaXNUZW1wbGF0ZVRhZyA/ICcsJyA6ICcgLyAnKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdGFnOiBUYWcgPSB7dGFnTmFtZSwgcGFyYW1ldGVyTmFtZSwgdHlwZSwgdGV4dH07XG4gIC8vIE5vdGU6IGEgcGFyYW0gY2FuIGVpdGhlciBiZSBvcHRpb25hbCBvciBhIHJlc3QgcGFyYW07IGlmIHdlIG1lcmdlZCBhblxuICAvLyBvcHRpb25hbCBhbmQgcmVzdCBwYXJhbSB0b2dldGhlciwgcHJlZmVyIG1hcmtpbmcgaXQgYXMgYSByZXN0IHBhcmFtLlxuICBpZiAocmVzdFBhcmFtKSB7XG4gICAgdGFnLnJlc3RQYXJhbSA9IHRydWU7XG4gIH0gZWxzZSBpZiAob3B0aW9uYWwpIHtcbiAgICB0YWcub3B0aW9uYWwgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0YWc7XG59XG4iXX0=